{"ast":null,"code":"import { is_empty } from '../utils/index.js';\nimport { scan, iterator } from './tokenizer.js';\nfunction parse(input) {\n  let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    symbol: ',',\n    noSpace: false,\n    verbose: false\n  };\n  let group = [];\n  let skip = false;\n  let tokens = [];\n  let parenStack = [];\n  let quoteStack = [];\n  let lastGroupName = '';\n  if (is_empty(input)) {\n    return group;\n  }\n  let iter = iterator(scan(input));\n  function isSeperator(token) {\n    let symbol = option.symbol || [','];\n    if (!Array.isArray(symbol)) {\n      symbol = [symbol];\n    }\n    if (option.noSpace) {\n      return token.isSymbol(...symbol);\n    }\n    return token.isSymbol(...symbol) || token.isSpace();\n  }\n  function addGroup(tokens) {\n    let value = joinTokens(tokens);\n    if (option.verbose) {\n      if (lastGroupName.length || value.length) {\n        group.push({\n          group: lastGroupName,\n          value\n        });\n      }\n    } else {\n      group.push(value);\n    }\n  }\n  while (iter.next()) {\n    let {\n      prev,\n      curr,\n      next\n    } = iter.get();\n    if (curr.isSymbol('(')) {\n      parenStack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      parenStack.pop();\n    }\n    if (curr.status === 'open') {\n      quoteStack.push(curr.value);\n    }\n    if (curr.status === 'close') {\n      quoteStack.pop();\n    }\n    let emptyStack = !parenStack.length && !quoteStack.length;\n    if (emptyStack) {\n      let isNextSpace = option.noSpace && curr.isSpace() && isSeperator(next);\n      let isPrevSpace = option.noSpace && curr.isSpace() && isSeperator(prev);\n      if (isNextSpace || isPrevSpace) continue;\n    }\n    if (emptyStack && isSeperator(curr)) {\n      let groupName = lastGroupName;\n      addGroup(tokens);\n      lastGroupName = curr.value;\n      tokens = [];\n    } else {\n      tokens.push(curr);\n    }\n  }\n  if (tokens.length) {\n    addGroup(tokens);\n  }\n  return group;\n}\nfunction joinTokens(tokens) {\n  return tokens.map(n => n.value).join('');\n}\nexport default parse;","map":{"version":3,"names":["is_empty","scan","iterator","parse","input","option","arguments","length","undefined","symbol","noSpace","verbose","group","skip","tokens","parenStack","quoteStack","lastGroupName","iter","isSeperator","token","Array","isArray","isSymbol","isSpace","addGroup","value","joinTokens","push","next","prev","curr","get","pop","status","emptyStack","isNextSpace","isPrevSpace","groupName","map","n","join"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/parser/parse-value-group.js"],"sourcesContent":["import { is_empty } from '../utils/index.js';\nimport { scan, iterator } from './tokenizer.js';\n\nfunction parse(input, option = {symbol: ',', noSpace: false, verbose: false }) {\n  let group = [];\n  let skip = false;\n  let tokens = [];\n  let parenStack = [];\n  let quoteStack = [];\n  let lastGroupName = '';\n\n  if (is_empty(input)) {\n    return group;\n  }\n\n  let iter = iterator(scan(input));\n\n  function isSeperator(token) {\n    let symbol = option.symbol || [','];\n    if (!Array.isArray(symbol)) {\n      symbol = [symbol];\n    }\n    if (option.noSpace) {\n      return token.isSymbol(...symbol);\n    }\n    return token.isSymbol(...symbol) || token.isSpace();\n  }\n\n  function addGroup(tokens) {\n    let value = joinTokens(tokens);\n    if (option.verbose) {\n      if (lastGroupName.length || value.length) {\n        group.push({ group: lastGroupName, value });\n      }\n    } else {\n      group.push(value);\n    }\n  }\n\n  while (iter.next()) {\n    let { prev, curr, next }  = iter.get();\n    if (curr.isSymbol('(')) {\n      parenStack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      parenStack.pop();\n    }\n    if (curr.status === 'open') {\n      quoteStack.push(curr.value);\n    }\n    if (curr.status === 'close') {\n      quoteStack.pop();\n    }\n    let emptyStack = (!parenStack.length && !quoteStack.length);\n    if (emptyStack) {\n      let isNextSpace = option.noSpace && curr.isSpace() && isSeperator(next);\n      let isPrevSpace = option.noSpace && curr.isSpace() && isSeperator(prev);\n      if (isNextSpace || isPrevSpace) continue;\n    }\n    if (emptyStack && isSeperator(curr)) {\n      let groupName = lastGroupName;\n      addGroup(tokens);\n      lastGroupName = curr.value;\n      tokens = [];\n    } else {\n      tokens.push(curr);\n    }\n  }\n\n  if (tokens.length) {\n    addGroup(tokens);\n  }\n\n  return group;\n}\n\nfunction joinTokens(tokens) {\n  return tokens.map(n => n.value).join('');\n}\n\nexport default parse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}