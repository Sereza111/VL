{"ast":null,"code":"import { scan, iterator } from './tokenizer.js';\nimport parseValueGroup from './parse-value-group.js';\nfunction readStatement(iter, token) {\n  let fragment = [];\n  let inlineBlock;\n  let stackQuote = [];\n  let stackParen = [];\n  let isInline = false;\n  while (iter.next()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    if (curr.isSymbol('(') && !stackQuote.length) {\n      stackParen.push(curr);\n    } else if (curr.isSymbol(')') && !stackQuote.length) {\n      stackParen.pop();\n    }\n    if (curr.isSymbol(\"'\", '\"')) {\n      if (curr.status === 'open') {\n        stackQuote.push(curr);\n      } else {\n        stackQuote.pop();\n      }\n    }\n    let isStatementBreak = !stackQuote.length && !stackParen.length && (!next || curr.isSymbol(';') || next.isSymbol('}'));\n    if (curr.isSymbol(\"'\", '\"')) {\n      if (next && next.isSymbol('}') && !stackQuote.length) {\n        isStatementBreak = true;\n      }\n    }\n    if (!stackParen.length && !stackQuote.length && curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, tokenName);\n      inlineBlock = resolveId(walk(iter, splitTimes(tokenName, {\n        type: 'block',\n        name: tokenName,\n        value: []\n      })), skip);\n      while (tokenName = selectors.pop()) {\n        inlineBlock = resolveId(splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: [inlineBlock]\n        }), skip);\n      }\n      isInline = true;\n      break;\n    }\n    fragment.push(curr);\n    if (isStatementBreak) {\n      break;\n    }\n  }\n  if (fragment.length && !inlineBlock) {\n    token._valueTokens = fragment;\n    token.value = joinToken(fragment);\n  } else if (inlineBlock) {\n    token.value = inlineBlock;\n  }\n  if (isInline) {\n    token.value.inline = true;\n  }\n  if (token.origin) {\n    token.origin.value = token.value;\n  }\n  return token;\n}\nfunction readStyle(iter) {\n  let stack = [];\n  let style = [];\n  while (iter.next()) {\n    let {\n      curr\n    } = iter.get();\n    if (curr.isSymbol('{')) {\n      stack.push(curr.value);\n    } else if (curr.isSymbol('}')) {\n      if (stack.length) {\n        stack.pop();\n      } else {\n        break;\n      }\n    }\n    style.push(curr.value);\n  }\n  return style.join('');\n}\nfunction walk(iter, parentToken) {\n  let rules = [];\n  let fragment = [];\n  let tokenType = parentToken && parentToken.type || '';\n  let stack = [];\n  while (iter.next()) {\n    let {\n      prev,\n      curr,\n      next\n    } = iter.get();\n    if (curr.isSymbol('(')) {\n      stack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      stack.pop();\n    }\n    let isBlockBreak = !next || curr.isSymbol('}');\n    if (isBlock(tokenType) && isBlockBreak) {\n      if (!next && rules.length && !curr.isSymbol('}')) {\n        let last = rules[rules.length - 1].value;\n        if (typeof last === 'string') {\n          rules[rules.length - 1].value += ';' + curr.value;\n        }\n      }\n      parentToken.value = rules;\n      break;\n    } else if (curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      if (isSkip(parentToken.name)) {\n        selectors = [joinToken(fragment)];\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, parentToken.name, tokenName);\n      if (tokenName === 'style') {\n        rules.push({\n          type: 'block',\n          name: tokenName,\n          value: readStyle(iter)\n        });\n      } else {\n        let block = resolveId(walk(iter, splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: []\n        })), skip);\n        while (tokenName = selectors.pop()) {\n          block = resolveId(splitTimes(tokenName, {\n            type: 'block',\n            name: tokenName,\n            value: [block]\n          }), skip);\n        }\n        rules.push(block);\n      }\n      fragment = [];\n    } else if (curr.isSymbol(':') && !stack.length && !isSpecialProperty(prev, next) && fragment.length) {\n      let props = getGroups(fragment, token => token.isSymbol(','));\n      let intial = {\n        type: 'statement',\n        name: 'unkown',\n        value: ''\n      };\n      if (props.length > 1) {\n        intial.origin = {\n          name: props\n        };\n      }\n      let statement = readStatement(iter, intial);\n      let groupdValue = parseValueGroup(statement.value);\n      let expand = props.length > 1 && groupdValue.length === props.length;\n      props.forEach((prop, i) => {\n        let item = Object.assign({}, statement, {\n          name: prop\n        });\n        if (/^\\-\\-/.test(prop)) {\n          item.variable = true;\n        }\n        if (expand) {\n          item.value = groupdValue[i];\n        }\n        if (/viewBox/i.test(prop)) {\n          item.detail = parseViewBox(item.value, item._valueTokens);\n        }\n        delete item._valueTokens;\n        rules.push(item);\n      });\n      if (isBlock(tokenType)) {\n        parentToken.value = rules;\n      }\n      fragment = [];\n    } else if (curr.isSymbol(';')) {\n      if (rules.length && fragment.length) {\n        rules[rules.length - 1].value += ';' + joinToken(fragment);\n        fragment = [];\n      }\n    } else {\n      fragment.push(curr);\n    }\n  }\n  if (rules.length && isBlock(tokenType)) {\n    parentToken.value = rules;\n  }\n  return tokenType ? parentToken : rules;\n}\nfunction isSpecialProperty(prev, next) {\n  const names = ['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'];\n  let prevValue = prev && prev.value;\n  let nextValue = next && next.value;\n  return names.includes(prevValue + ':' + nextValue);\n}\nfunction joinToken(tokens) {\n  return tokens.filter((token, i) => {\n    if (token.isSymbol(';', '}') && i === tokens.length - 1) return false;\n    return true;\n  }).map(n => n.value).join('');\n}\nfunction resolveId(block, skip) {\n  let name = block.name || '';\n  let [tokenName, ...ids] = name.split(/#/);\n  let id = ids[ids.length - 1];\n  if (tokenName && id && !skip) {\n    block.name = tokenName;\n    block.value.push({\n      type: 'statement',\n      name: 'id',\n      value: id\n    });\n  }\n  return block;\n}\nfunction getGroups(tokens, fn) {\n  let group = [];\n  let temp = [];\n  tokens.forEach(token => {\n    if (fn(token)) {\n      group.push(joinToken(temp));\n      temp = [];\n    } else {\n      temp.push(token);\n    }\n  });\n  if (temp.length) {\n    group.push(joinToken(temp));\n  }\n  return group;\n}\nfunction getSelectors(tokens) {\n  let result = [];\n  let it = iterator(tokens);\n  let temp = [];\n  let hasSymbol;\n  while (it.next()) {\n    let {\n      prev,\n      curr,\n      next\n    } = it.get();\n    let isTimeSymbol = prev && next && curr.value === 'x' && prev.isNumber() && next.isNumber();\n    if (curr.isWord() && !hasSymbol && !isTimeSymbol) {\n      result.push(curr.value.trim());\n    } else {\n      result[result.length - 1] = (result[result.length - 1] + curr.value).trim();\n    }\n    if (curr.isSymbol()) {\n      hasSymbol = true;\n    } else if (!curr.isSpace()) {\n      hasSymbol = false;\n    }\n  }\n  return result;\n}\nfunction parseViewBox(value, tokens) {\n  const viewBox = {\n    value: []\n  };\n  let temp;\n  if (!Array.isArray(tokens)) {\n    return viewBox;\n  }\n  for (let token of tokens) {\n    if (token.isSpace() || token.isSymbol(',', ';')) {\n      continue;\n    }\n    if (viewBox.value.length < 4 && token.isNumber()) {\n      viewBox.value.push(Number(token.value));\n    } else if (token.isNumber() && temp) {\n      viewBox[temp] = Number(token.value);\n      temp = null;\n    } else if (token.isWord()) {\n      temp = token.value;\n    }\n  }\n  return viewBox;\n}\nfunction splitTimes(name, object) {\n  let target = Object.assign({}, object);\n  if (/\\*\\s*[0-9]/.test(name)) {\n    let [tokenName, times] = name.split('*');\n    if (times) {\n      target.times = times.trim();\n      target.pureName = tokenName.trim();\n    }\n  }\n  return target;\n}\nfunction isSkip() {\n  for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\n    names[_key] = arguments[_key];\n  }\n  return names.some(n => n === 'style');\n}\nfunction isBlock(type) {\n  return type === 'block';\n}\nfunction skipHeadSVG(block) {\n  let headSVG,\n    headVariables = [];\n  for (let item of block.value) {\n    if (item.name === 'svg') {\n      headSVG = item;\n    }\n    if (item.variable) {\n      headVariables.push(item);\n    }\n  }\n  if (headSVG && Array.isArray(headSVG.value)) {\n    for (let variable of headVariables) {\n      if (!headSVG.value.find(n => n.name == variable.name)) {\n        headSVG.value.unshift(variable);\n      }\n    }\n    return headSVG;\n  }\n  return block;\n}\nfunction parse(source, root) {\n  let iter = iterator(scan(source));\n  let tokens = walk(iter, root || {\n    type: 'block',\n    name: 'svg',\n    value: []\n  });\n  return skipHeadSVG(tokens);\n}\nexport default parse;","map":{"version":3,"names":["scan","iterator","parseValueGroup","readStatement","iter","token","fragment","inlineBlock","stackQuote","stackParen","isInline","next","curr","get","isSymbol","length","push","pop","status","isStatementBreak","selectors","getSelectors","tokenName","skip","isSkip","resolveId","walk","splitTimes","type","name","value","_valueTokens","joinToken","inline","origin","readStyle","stack","style","join","parentToken","rules","tokenType","prev","isBlockBreak","isBlock","last","block","isSpecialProperty","props","getGroups","intial","statement","groupdValue","expand","forEach","prop","i","item","Object","assign","test","variable","detail","parseViewBox","names","prevValue","nextValue","includes","tokens","filter","map","n","ids","split","id","fn","group","temp","result","it","hasSymbol","isTimeSymbol","isNumber","isWord","trim","isSpace","viewBox","Array","isArray","Number","object","target","times","pureName","_len","arguments","_key","some","skipHeadSVG","headSVG","headVariables","find","unshift","parse","source","root"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/parser/parse-svg.js"],"sourcesContent":["import { scan, iterator } from './tokenizer.js';\nimport parseValueGroup from './parse-value-group.js';\n\nfunction readStatement(iter, token) {\n  let fragment = [];\n  let inlineBlock;\n  let stackQuote = [];\n  let stackParen = [];\n  let isInline = false;\n  while (iter.next()) {\n    let { curr, next } = iter.get();\n    if (curr.isSymbol('(') && !stackQuote.length) {\n      stackParen.push(curr);\n    } else if (curr.isSymbol(')') && !stackQuote.length) {\n      stackParen.pop();\n    }\n    if (curr.isSymbol(\"'\", '\"')) {\n      if (curr.status === 'open') {\n        stackQuote.push(curr);\n      } else {\n        stackQuote.pop();\n      }\n    }\n    let isStatementBreak = !stackQuote.length\n      && !stackParen.length\n      && (!next || curr.isSymbol(';') || next.isSymbol('}'));\n\n    if (curr.isSymbol(\"'\", '\"')) {\n      if ((next && next.isSymbol('}')) && !stackQuote.length) {\n        isStatementBreak = true;\n      }\n    }\n    if (!stackParen.length && !stackQuote.length && curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, tokenName);\n      inlineBlock = resolveId(walk(iter, splitTimes(tokenName, {\n        type: 'block',\n        name: tokenName,\n        value: [],\n      })), skip);\n\n      while (tokenName = selectors.pop()) {\n        inlineBlock = resolveId(splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: [inlineBlock]\n        }), skip);\n      }\n      isInline = true;\n      break;\n    }\n    fragment.push(curr);\n    if (isStatementBreak) {\n      break;\n    }\n  }\n  if (fragment.length && !inlineBlock) {\n    token._valueTokens = fragment;\n    token.value = joinToken(fragment);\n  } else if (inlineBlock) {\n    token.value = inlineBlock;\n  }\n  if (isInline) {\n    token.value.inline = true;\n  }\n  if (token.origin) {\n    token.origin.value = token.value;\n  }\n  return token;\n}\n\nfunction readStyle(iter) {\n  let stack = [];\n  let style = [];\n  while (iter.next()) {\n    let { curr } = iter.get();\n    if (curr.isSymbol('{')) {\n      stack.push(curr.value);\n    } else if (curr.isSymbol('}')) {\n      if (stack.length) {\n        stack.pop();\n      } else {\n        break;\n      }\n    }\n    style.push(curr.value);\n  }\n  return style.join('');\n}\n\nfunction walk(iter, parentToken) {\n  let rules = [];\n  let fragment = [];\n  let tokenType = parentToken && parentToken.type || '';\n  let stack = [];\n\n  while (iter.next()) {\n    let { prev, curr, next } = iter.get();\n    if (curr.isSymbol('(')) {\n      stack.push(curr.value);\n    }\n    if (curr.isSymbol(')')) {\n      stack.pop();\n    }\n    let isBlockBreak = !next || curr.isSymbol('}');\n    if (isBlock(tokenType) && isBlockBreak) {\n      if (!next && rules.length && !curr.isSymbol('}')) {\n        let last = rules[rules.length - 1].value;\n        if (typeof last === 'string') {\n          rules[rules.length - 1].value += (';' + curr.value);\n        }\n      }\n      parentToken.value = rules;\n      break;\n    }\n    else if (curr.isSymbol('{')) {\n      let selectors = getSelectors(fragment);\n      if (!selectors.length) {\n        continue;\n      }\n      if (isSkip(parentToken.name)) {\n        selectors = [joinToken(fragment)];\n      }\n      let tokenName = selectors.pop();\n      let skip = isSkip(...selectors, parentToken.name, tokenName);\n\n      if (tokenName === 'style') {\n        rules.push({\n          type: 'block',\n          name: tokenName,\n          value: readStyle(iter)\n        });\n      } else {\n        let block = resolveId(walk(iter, splitTimes(tokenName, {\n          type: 'block',\n          name: tokenName,\n          value: []\n        })), skip);\n\n        while (tokenName = selectors.pop()) {\n          block = resolveId(splitTimes(tokenName, {\n            type: 'block',\n            name: tokenName,\n            value: [block]\n          }), skip);\n        }\n        rules.push(block);\n      }\n      fragment = [];\n    }\n    else if (\n      curr.isSymbol(':')\n      && !stack.length\n      && !isSpecialProperty(prev, next)\n      && fragment.length\n    ) {\n      let props = getGroups(fragment, token => token.isSymbol(','));\n      let intial = {\n        type: 'statement',\n        name: 'unkown',\n        value: ''\n      }\n      if (props.length > 1) {\n        intial.origin = {\n          name: props\n        };\n      }\n      let statement = readStatement(iter, intial);\n      let groupdValue = parseValueGroup(statement.value);\n      let expand = (props.length > 1 && groupdValue.length === props.length);\n\n      props.forEach((prop, i) => {\n        let item = Object.assign({}, statement, { name: prop });\n        if (/^\\-\\-/.test(prop)) {\n          item.variable = true;\n        }\n        if (expand) {\n          item.value = groupdValue[i];\n        }\n        if (/viewBox/i.test(prop)) {\n          item.detail = parseViewBox(item.value, item._valueTokens);\n        }\n        delete item._valueTokens;\n        rules.push(item);\n      });\n      if (isBlock(tokenType)) {\n        parentToken.value = rules;\n      }\n      fragment = [];\n    }\n    else if (curr.isSymbol(';')) {\n      if (rules.length && fragment.length) {\n        rules[rules.length - 1].value += (';' + joinToken(fragment));\n        fragment = [];\n      }\n    }\n    else {\n      fragment.push(curr);\n    }\n  }\n\n  if (rules.length && isBlock(tokenType)) {\n    parentToken.value = rules;\n  }\n  return tokenType ? parentToken : rules;\n}\n\nfunction isSpecialProperty(prev, next) {\n  const names = [\n    'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role',\n    'xlink:show',    'xlink:title',   'xlink:type',\n    'xml:base',      'xml:lang',      'xml:space',\n  ];\n  let prevValue = prev && prev.value;\n  let nextValue = next && next.value;\n  return names.includes(prevValue + ':' + nextValue);\n}\n\nfunction joinToken(tokens) {\n  return tokens\n    .filter((token, i) => {\n      if (token.isSymbol(';', '}') && i === tokens.length - 1) return false;\n      return true;\n    })\n    .map(n => n.value).join('');\n}\n\nfunction resolveId(block, skip) {\n  let name = block.name || '';\n  let [tokenName, ...ids] = name.split(/#/);\n  let id = ids[ids.length - 1];\n  if (tokenName && id && !skip) {\n    block.name = tokenName;\n    block.value.push({\n      type: 'statement',\n      name: 'id',\n      value: id,\n    });\n  }\n  return block;\n}\n\nfunction getGroups(tokens, fn) {\n  let group = [];\n  let temp = [];\n  tokens.forEach(token => {\n    if (fn(token)) {\n      group.push(joinToken(temp));\n      temp = [];\n    } else {\n      temp.push(token);\n    }\n  });\n  if (temp.length) {\n    group.push(joinToken(temp));\n  }\n  return group;\n}\n\nfunction getSelectors(tokens) {\n  let result = [];\n  let it = iterator(tokens);\n  let temp = [];\n  let hasSymbol;\n  while (it.next()) {\n    let { prev, curr, next } = it.get();\n    let isTimeSymbol = (\n      prev && next &&\n      curr.value === 'x' &&\n      prev.isNumber()  &&\n      next.isNumber()\n    );\n    if (curr.isWord() && !hasSymbol && !isTimeSymbol) {\n      result.push(curr.value.trim());\n    } else {\n      result[result.length - 1] =\n        (result[result.length - 1] + curr.value).trim();\n    }\n    if (curr.isSymbol()) {\n      hasSymbol = true;\n    } else if (!curr.isSpace()) {\n      hasSymbol = false;\n    }\n  }\n  return result;\n}\n\nfunction parseViewBox(value, tokens) {\n  const viewBox = { value: [] };\n  let temp;\n  if (!Array.isArray(tokens)) {\n    return viewBox;\n  }\n  for (let token of tokens) {\n    if (token.isSpace() || token.isSymbol(',', ';')) {\n      continue;\n    }\n    if (viewBox.value.length < 4 && token.isNumber()) {\n      viewBox.value.push(Number(token.value));\n    }\n    else if (token.isNumber() && temp) {\n      viewBox[temp] = Number(token.value);\n      temp = null;\n    }\n    else if (token.isWord()) {\n      temp = token.value;\n    }\n  }\n  return viewBox;\n}\n\nfunction splitTimes(name, object) {\n  let target = Object.assign({}, object);\n  if (/\\*\\s*[0-9]/.test(name)) {\n    let [tokenName, times] = name.split('*');\n    if (times) {\n      target.times = times.trim();\n      target.pureName = tokenName.trim();\n    }\n  }\n  return target;\n}\n\nfunction isSkip(...names) {\n  return names.some(n => n === 'style');\n}\n\nfunction isBlock(type) {\n  return type === 'block';\n}\n\nfunction skipHeadSVG(block) {\n  let headSVG, headVariables = [];\n  for (let item of block.value) {\n    if (item.name === 'svg') {\n      headSVG = item;\n    }\n    if (item.variable) {\n      headVariables.push(item);\n    }\n  }\n  if (headSVG && Array.isArray(headSVG.value)) {\n    for (let variable of headVariables) {\n      if (!headSVG.value.find(n => n.name == variable.name)) {\n        headSVG.value.unshift(variable);\n      }\n    }\n    return headSVG;\n  }\n  return block;\n}\n\nfunction parse(source, root) {\n  let iter = iterator(scan(source));\n  let tokens = walk(iter, root || {\n    type: 'block',\n    name: 'svg',\n    value: []\n  });\n  return skipHeadSVG(tokens);\n}\n\nexport default parse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}