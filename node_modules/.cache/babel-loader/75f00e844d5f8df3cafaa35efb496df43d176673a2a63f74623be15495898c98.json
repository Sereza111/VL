{"ast":null,"code":"import _objectSpread from \"/var/www/www-root/data/www/knigavl.ru/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/var/www/www-root/data/www/knigavl.ru/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"rampType\", \"rampStart\", \"rampEnd\", \"startColor\", \"endColor\", \"rampBias\", \"rampGain\", \"rampMask\", \"rampInvert\"];\nimport { Uniform } from \"three\";\nimport { Effect } from \"postprocessing\";\nimport { wrapEffect } from \"../util.js\";\nconst RampShader = {\n  fragmentShader: /* glsl */\"\\n    uniform int rampType;\\n\\n    uniform vec2 rampStart;\\n    uniform vec2 rampEnd;\\n\\n    uniform vec4 startColor;\\n    uniform vec4 endColor;\\n\\n    uniform float rampBias;\\n    uniform float rampGain;\\n\\n    uniform bool rampMask;\\n    uniform bool rampInvert;\\n\\n    float getBias(float time, float bias) {\\n      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);\\n    }\\n\\n    float getGain(float time, float gain) {\\n      if (time < 0.5)\\n        return getBias(time * 2.0, gain) / 2.0;\\n      else\\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\\n    }\\n\\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\\n      vec2 centerPixel = uv * resolution;\\n      vec2 startPixel = rampStart * resolution;\\n      vec2 endPixel = rampEnd * resolution;\\n\\n      float rampAlpha;\\n\\n      if (rampType == 1) {\\n        vec2 fuv = centerPixel / resolution.y;\\n        vec2 suv = startPixel / resolution.y;\\n        vec2 euv = endPixel / resolution.y;\\n\\n        float radius = length(suv - euv);\\n        float falloff = length(fuv - suv);\\n        rampAlpha = smoothstep(0.0, radius, falloff);\\n      } else {\\n        float radius = length(startPixel - endPixel);\\n        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));\\n\\n        float fade = dot(centerPixel - startPixel, direction);\\n        if (rampType == 2) fade = abs(fade);\\n\\n        rampAlpha = smoothstep(0.0, 1.0, fade / radius);\\n      }\\n\\n      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));\\n\\n      if (rampMask) {\\n        vec4 inputBuff = texture2D(inputBuffer, uv);\\n        outputColor = mix(inputBuff, inputColor, rampAlpha);\\n      } else {\\n        outputColor = mix(startColor, endColor, rampAlpha);\\n      }\\n    }\\n  \"\n};\nvar RampType = /* @__PURE__ */(RampType2 => {\n  RampType2[RampType2[\"Linear\"] = 0] = \"Linear\";\n  RampType2[RampType2[\"Radial\"] = 1] = \"Radial\";\n  RampType2[RampType2[\"MirroredLinear\"] = 2] = \"MirroredLinear\";\n  return RampType2;\n})(RampType || {});\nclass RampEffect extends Effect {\n  constructor() {\n    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      {\n        /**\n         * Type of ramp gradient.\n         */\n        rampType = 0,\n        /**\n         * Starting point of the ramp gradient in normalized coordinates.\n         *\n         * Ranges from `[0 - 1]` as `[x, y]`. Default is `[0.5, 0.5]`.\n         */\n        rampStart = [0.5, 0.5],\n        /**\n         * Ending point of the ramp gradient in normalized coordinates.\n         *\n         * Ranges from `[0 - 1]` as `[x, y]`. Default is `[1, 1]`\n         */\n        rampEnd = [1, 1],\n        /**\n         * Color at the starting point of the gradient.\n         *\n         * Default is black: `[0, 0, 0, 1]`\n         */\n        startColor = [0, 0, 0, 1],\n        /**\n         * Color at the ending point of the gradient.\n         *\n         * Default is white: `[1, 1, 1, 1]`\n         */\n        endColor = [1, 1, 1, 1],\n        /**\n         * Bias for the interpolation curve when both bias and gain are 0.5.\n         *\n         * Ranges from `[0 - 1]`. Default is `0.5`.\n         */\n        rampBias = 0.5,\n        /**\n         * Gain for the interpolation curve when both bias and gain are 0.5.\n         *\n         * Ranges from `[0 - 1]`. Default is `0.5`.\n         */\n        rampGain = 0.5,\n        /**\n         * When enabled, the ramp gradient is used as an effect mask, and colors are ignored.\n         *\n         * Default is `false`.\n         */\n        rampMask = false,\n        /**\n         * Controls whether the ramp gradient is inverted.\n         *\n         * When disabled, rampStart is transparent and rampEnd is opaque.\n         *\n         * Default is `false`.\n         */\n        rampInvert = false\n      } = _ref,\n      params = _objectWithoutProperties(_ref, _excluded);\n    super(\"RampEffect\", RampShader.fragmentShader, _objectSpread(_objectSpread({}, params), {}, {\n      uniforms: /* @__PURE__ */new Map([[\"rampType\", new Uniform(rampType)], [\"rampStart\", new Uniform(rampStart)], [\"rampEnd\", new Uniform(rampEnd)], [\"startColor\", new Uniform(startColor)], [\"endColor\", new Uniform(endColor)], [\"rampBias\", new Uniform(rampBias)], [\"rampGain\", new Uniform(rampGain)], [\"rampMask\", new Uniform(rampMask)], [\"rampInvert\", new Uniform(rampInvert)]])\n    }));\n  }\n}\nconst Ramp = /* @__PURE__ */wrapEffect(RampEffect);\nexport { Ramp, RampEffect, RampType };","map":{"version":3,"names":["RampShader","fragmentShader","RampType","RampType2","RampEffect","Effect","constructor","_ref","arguments","length","undefined","rampType","rampStart","rampEnd","startColor","endColor","rampBias","rampGain","rampMask","rampInvert","params","_objectWithoutProperties","_excluded","_objectSpread","uniforms","Map","Uniform","Ramp","wrapEffect"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/@react-three/postprocessing/src/effects/Ramp.tsx"],"sourcesContent":["import { Uniform } from 'three'\nimport { Effect } from 'postprocessing'\nimport { wrapEffect } from '../util'\n\nconst RampShader = {\n  fragmentShader: /* glsl */ `\n    uniform int rampType;\n\n    uniform vec2 rampStart;\n    uniform vec2 rampEnd;\n\n    uniform vec4 startColor;\n    uniform vec4 endColor;\n\n    uniform float rampBias;\n    uniform float rampGain;\n\n    uniform bool rampMask;\n    uniform bool rampInvert;\n\n    float getBias(float time, float bias) {\n      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);\n    }\n\n    float getGain(float time, float gain) {\n      if (time < 0.5)\n        return getBias(time * 2.0, gain) / 2.0;\n      else\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n      vec2 centerPixel = uv * resolution;\n      vec2 startPixel = rampStart * resolution;\n      vec2 endPixel = rampEnd * resolution;\n\n      float rampAlpha;\n\n      if (rampType == 1) {\n        vec2 fuv = centerPixel / resolution.y;\n        vec2 suv = startPixel / resolution.y;\n        vec2 euv = endPixel / resolution.y;\n\n        float radius = length(suv - euv);\n        float falloff = length(fuv - suv);\n        rampAlpha = smoothstep(0.0, radius, falloff);\n      } else {\n        float radius = length(startPixel - endPixel);\n        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));\n\n        float fade = dot(centerPixel - startPixel, direction);\n        if (rampType == 2) fade = abs(fade);\n\n        rampAlpha = smoothstep(0.0, 1.0, fade / radius);\n      }\n\n      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));\n\n      if (rampMask) {\n        vec4 inputBuff = texture2D(inputBuffer, uv);\n        outputColor = mix(inputBuff, inputColor, rampAlpha);\n      } else {\n        outputColor = mix(startColor, endColor, rampAlpha);\n      }\n    }\n  `,\n}\n\nexport enum RampType {\n  Linear,\n  Radial,\n  MirroredLinear,\n}\n\nexport class RampEffect extends Effect {\n  constructor({\n    /**\n     * Type of ramp gradient.\n     */\n    rampType = RampType.Linear,\n    /**\n     * Starting point of the ramp gradient in normalized coordinates.\n     *\n     * Ranges from `[0 - 1]` as `[x, y]`. Default is `[0.5, 0.5]`.\n     */\n    rampStart = [0.5, 0.5],\n    /**\n     * Ending point of the ramp gradient in normalized coordinates.\n     *\n     * Ranges from `[0 - 1]` as `[x, y]`. Default is `[1, 1]`\n     */\n    rampEnd = [1, 1],\n    /**\n     * Color at the starting point of the gradient.\n     *\n     * Default is black: `[0, 0, 0, 1]`\n     */\n    startColor = [0, 0, 0, 1],\n    /**\n     * Color at the ending point of the gradient.\n     *\n     * Default is white: `[1, 1, 1, 1]`\n     */\n    endColor = [1, 1, 1, 1],\n    /**\n     * Bias for the interpolation curve when both bias and gain are 0.5.\n     *\n     * Ranges from `[0 - 1]`. Default is `0.5`.\n     */\n    rampBias = 0.5,\n    /**\n     * Gain for the interpolation curve when both bias and gain are 0.5.\n     *\n     * Ranges from `[0 - 1]`. Default is `0.5`.\n     */\n    rampGain = 0.5,\n    /**\n     * When enabled, the ramp gradient is used as an effect mask, and colors are ignored.\n     *\n     * Default is `false`.\n     */\n    rampMask = false,\n    /**\n     * Controls whether the ramp gradient is inverted.\n     *\n     * When disabled, rampStart is transparent and rampEnd is opaque.\n     *\n     * Default is `false`.\n     */\n    rampInvert = false,\n    ...params\n  } = {}) {\n    super('RampEffect', RampShader.fragmentShader, {\n      ...params,\n      uniforms: new Map<string, Uniform>([\n        ['rampType', new Uniform(rampType)],\n        ['rampStart', new Uniform(rampStart)],\n        ['rampEnd', new Uniform(rampEnd)],\n        ['startColor', new Uniform(startColor)],\n        ['endColor', new Uniform(endColor)],\n        ['rampBias', new Uniform(rampBias)],\n        ['rampGain', new Uniform(rampGain)],\n        ['rampMask', new Uniform(rampMask)],\n        ['rampInvert', new Uniform(rampInvert)],\n      ]),\n    })\n  }\n}\n\nexport const Ramp = /* @__PURE__ */ wrapEffect(RampEffect)\n"],"mappings":";;;;;;AAIA,MAAMA,UAAA,GAAa;EACjBC,cAAA;AA6DF;AAEY,IAAAC,QAAA,mBAAAC,SAAA,IAAL;EACLA,SAAA,CAAAA,SAAA;EACAA,SAAA,CAAAA,SAAA;EACAA,SAAA,CAAAA,SAAA;EAHU,OAAAA,SAAA;AAAA,GAAAD,QAAA;AAML,MAAME,UAAA,SAAmBC,MAAA,CAAO;EACrCC,YAAA,EAwDQ;IAAA,IAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAJ;MAxDQ;QAAA;AAAA;AAAA;QAIVG,QAAA,GAAW;QAAA;AAAA;AAAA;AAAA;AAAA;QAMXC,SAAA,GAAY,CAAC,KAAK,GAAG;QAAA;AAAA;AAAA;AAAA;AAAA;QAMrBC,OAAA,GAAU,CAAC,GAAG,CAAC;QAAA;AAAA;AAAA;AAAA;AAAA;QAMfC,UAAA,GAAa,CAAC,GAAG,GAAG,GAAG,CAAC;QAAA;AAAA;AAAA;AAAA;AAAA;QAMxBC,QAAA,GAAW,CAAC,GAAG,GAAG,GAAG,CAAC;QAAA;AAAA;AAAA;AAAA;AAAA;QAMtBC,QAAA,GAAW;QAAA;AAAA;AAAA;AAAA;AAAA;QAMXC,QAAA,GAAW;QAAA;AAAA;AAAA;AAAA;AAAA;QAMXC,QAAA,GAAW;QAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;QAQXC,UAAA,GAAa;MAEf,IAAAZ,IAAA;MADKa,MAAA,GAAAC,wBAAA,CAAAd,IAAA,EAAAe,SAAA;IAEG,oBAActB,UAAA,CAAWC,cAAA,EAAAsB,aAAA,CAAAA,aAAA,KAC1BH,MAAA;MACHI,QAAA,qBAAcC,GAAA,CAAqB,CACjC,CAAC,YAAY,IAAIC,OAAA,CAAQf,QAAQ,CAAC,GAClC,CAAC,aAAa,IAAIe,OAAA,CAAQd,SAAS,CAAC,GACpC,CAAC,WAAW,IAAIc,OAAA,CAAQb,OAAO,CAAC,GAChC,CAAC,cAAc,IAAIa,OAAA,CAAQZ,UAAU,CAAC,GACtC,CAAC,YAAY,IAAIY,OAAA,CAAQX,QAAQ,CAAC,GAClC,CAAC,YAAY,IAAIW,OAAA,CAAQV,QAAQ,CAAC,GAClC,CAAC,YAAY,IAAIU,OAAA,CAAQT,QAAQ,CAAC,GAClC,CAAC,YAAY,IAAIS,OAAA,CAAQR,QAAQ,CAAC,GAClC,CAAC,cAAc,IAAIQ,OAAA,CAAQP,UAAU,CAAC,EACvC;IAAA,EACF;EACH;AACF;AAEa,MAAAQ,IAAA,kBAAAC,UAAA,CAAkCxB,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}