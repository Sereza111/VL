{"ast":null,"code":"/**\n * This is totally rewrite for the old parser module\n * I'll improve and replace them little by little.\n */\n\nconst symbols = [':', ';', ',', '(', ')', '[', ']', '{', '}', 'π', '±', '+', '-', '*', '/', '%', '\"', \"'\", '`', '@', '=', '^'];\nconst is = {\n  escape: c => c == '\\\\',\n  space: c => /[\\r\\n\\t\\s]/.test(c),\n  digit: c => /^[0-9]$/.test(c),\n  sign: c => /^[+-]$/.test(c),\n  dot: c => c == '.',\n  quote: c => /^[\"'`]$/.test(c),\n  symbol: c => symbols.includes(c),\n  hexNum: c => /^[0-9a-f]$/i.test(c),\n  hex: (a, b, c) => a == '0' && is.letter(b, 'x') && is.hexNum(c),\n  expWithSign: (a, b, c) => is.letter(a, 'e') && is.sign(b) && is.digit(c),\n  exp: (a, b) => is.letter(a, 'e') && is.digit(b),\n  dots: (a, b) => is.dot(a) && is.dot(b),\n  letter: (a, b) => String(a).toLowerCase() == String(b).toLowerCase(),\n  comment: (a, b) => a == '/' && b == '*',\n  inlineComment: (a, b) => a == '/' && b === '/',\n  selfClosedTag: (a, b) => a == '/' && b == '>',\n  closedTag: (a, b) => a == '<' && b == '/'\n};\nclass Token {\n  constructor(_ref) {\n    let {\n      type,\n      value,\n      pos,\n      status\n    } = _ref;\n    this.type = type;\n    this.value = value;\n    this.pos = pos;\n    if (status) {\n      this.status = status;\n    }\n  }\n  isSymbol() {\n    let isSymbol = this.type == 'Symbol';\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    if (!values.length) return isSymbol;\n    return values.some(c => c === this.value);\n  }\n  isSpace() {\n    return this.type == 'Space';\n  }\n  isNumber() {\n    return this.type == 'Number';\n  }\n  isWord() {\n    return this.type == 'Word';\n  }\n}\nfunction iterator(input) {\n  let pointer = -1;\n  let max = input.length;\n  let col = -1,\n    row = 0;\n  return {\n    curr() {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return input[pointer + n];\n    },\n    next() {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      let next = input[pointer += n];\n      if (next === '\\n') row++, col = 0;else col += n;\n      return next;\n    },\n    end() {\n      return pointer >= max;\n    },\n    get() {\n      return {\n        prev: input[pointer - 1],\n        curr: input[pointer + 0],\n        next: input[pointer + 1],\n        next2: input[pointer + 2],\n        next3: input[pointer + 3],\n        pos: [col, row]\n      };\n    }\n  };\n}\nfunction skipComments(iter) {\n  while (iter.next()) {\n    let {\n      curr,\n      prev\n    } = iter.get();\n    if (is.comment(curr, prev)) break;\n  }\n}\nfunction skipInlineComments(iter) {\n  while (iter.next()) {\n    if (iter.curr() === '\\n') break;\n  }\n}\nfunction ignoreSpacingSymbol(value) {\n  return [':', ';', ',', '{', '}', '(', ')', '[', ']'].includes(value);\n}\nfunction readWord(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    temp += curr;\n    let isBreak = is.symbol(next) || is.space(next) || is.digit(next);\n    if (temp.length && isBreak) {\n      if (!is.closedTag(curr, next)) break;\n    }\n    iter.next();\n  }\n  return temp.trim();\n}\nfunction readSpaces(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    temp += curr;\n    if (!is.space(next)) break;\n    iter.next();\n  }\n  return temp;\n}\nfunction readNumber(iter) {\n  let temp = '';\n  let hasDot = false;\n  while (!iter.end()) {\n    let {\n      curr,\n      next,\n      next2,\n      next3\n    } = iter.get();\n    temp += curr;\n    if (hasDot && is.dot(next)) break;\n    if (is.dot(curr)) hasDot = true;\n    if (is.dots(next, next2)) break;\n    if (is.expWithSign(next, next2, next3)) {\n      temp += iter.next() + iter.next();\n    } else if (is.exp(next, next2)) {\n      temp += iter.next();\n    } else if (!is.digit(next) && !is.dot(next)) {\n      break;\n    }\n    iter.next();\n  }\n  return temp;\n}\nfunction readHexNumber(iter) {\n  let temp = '0x';\n  iter.next(2);\n  while (!iter.end()) {\n    let {\n      curr,\n      next\n    } = iter.get();\n    temp += curr;\n    if (!is.hexNum(next)) break;\n    iter.next();\n  }\n  return temp;\n}\nfunction last(array) {\n  return array[array.length - 1];\n}\nfunction scan(source) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let iter = iterator(String(source).trim());\n  let tokens = [];\n  let quoteStack = [];\n  while (iter.next()) {\n    let {\n      prev,\n      curr,\n      next,\n      next2,\n      pos\n    } = iter.get();\n    if (is.comment(curr, next)) {\n      skipComments(iter);\n    } else if (options.ignoreInlineComment && is.inlineComment(curr, next)) {\n      skipInlineComments(iter);\n    } else if (is.hex(curr, next, next2)) {\n      let num = readHexNumber(iter);\n      tokens.push(new Token({\n        type: 'Number',\n        value: num,\n        pos\n      }));\n    } else if (is.digit(curr) || is.digit(next) && is.dot(curr) && !is.dots(prev, curr)) {\n      let num = readNumber(iter);\n      tokens.push(new Token({\n        type: 'Number',\n        value: num,\n        pos\n      }));\n    } else if (is.symbol(curr) && !is.selfClosedTag(curr, next)) {\n      let lastToken = last(tokens);\n      // negative\n      let isNextDigit = is.digit(next) || is.dot(next) && is.digit(next2);\n      if (curr === '-' && isNextDigit && (!lastToken || !lastToken.isNumber())) {\n        let num = readNumber(iter);\n        tokens.push(new Token({\n          type: 'Number',\n          value: num,\n          pos\n        }));\n        continue;\n      }\n      let token = {\n        type: 'Symbol',\n        value: curr,\n        pos\n      };\n      // Escaped symbols\n      if (quoteStack.length && is.escape(lastToken.value)) {\n        tokens.pop();\n        let word = readWord(iter);\n        if (word.length) {\n          tokens.push(new Token({\n            type: 'Word',\n            value: word,\n            pos\n          }));\n        }\n      } else {\n        if (is.quote(curr)) {\n          let lastQuote = last(quoteStack);\n          if (lastQuote == curr) {\n            quoteStack.pop();\n            token.status = 'close';\n          } else {\n            quoteStack.push(curr);\n            token.status = 'open';\n          }\n        }\n        tokens.push(new Token(token));\n      }\n    } else if (is.space(curr)) {\n      let spaces = readSpaces(iter);\n      let lastToken = last(tokens);\n      let {\n        next\n      } = iter.get();\n      // Reduce unnecessary spaces\n      if (!quoteStack.length && lastToken) {\n        let prev = lastToken.value;\n        let ignoreLeft = ignoreSpacingSymbol(prev) && prev !== ')';\n        let ignoreRight = ignoreSpacingSymbol(next) && next !== '(';\n        if (ignoreLeft || ignoreRight) {\n          continue;\n        } else {\n          spaces = options.preserveLineBreak ? curr : ' ';\n        }\n      }\n      if (tokens.length && next && next.trim()) {\n        tokens.push(new Token({\n          type: 'Space',\n          value: spaces,\n          pos\n        }));\n      }\n    } else {\n      let word = readWord(iter);\n      if (word.length) {\n        tokens.push(new Token({\n          type: 'Word',\n          value: word,\n          pos\n        }));\n      }\n    }\n  }\n\n  // Remove last space token\n  let lastToken = last(tokens);\n  if (lastToken && lastToken.isSpace()) {\n    tokens.length = tokens.length - 1;\n  }\n  return tokens;\n}\nexport { symbols, is, iterator, scan, Token };","map":{"version":3,"names":["symbols","is","escape","c","space","test","digit","sign","dot","quote","symbol","includes","hexNum","hex","a","b","letter","expWithSign","exp","dots","String","toLowerCase","comment","inlineComment","selfClosedTag","closedTag","Token","constructor","_ref","type","value","pos","status","isSymbol","_len","arguments","length","values","Array","_key","some","isSpace","isNumber","isWord","iterator","input","pointer","max","col","row","curr","n","undefined","next","end","get","prev","next2","next3","skipComments","iter","skipInlineComments","ignoreSpacingSymbol","readWord","temp","isBreak","trim","readSpaces","readNumber","hasDot","readHexNumber","last","array","scan","source","options","tokens","quoteStack","ignoreInlineComment","num","push","lastToken","isNextDigit","token","pop","word","lastQuote","spaces","ignoreLeft","ignoreRight","preserveLineBreak"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/parser/tokenizer.js"],"sourcesContent":["/**\n * This is totally rewrite for the old parser module\n * I'll improve and replace them little by little.\n */\n\nconst symbols = [\n  ':', ';', ',', '(', ')', '[', ']',\n  '{', '}', 'π', '±', '+', '-', '*',\n  '/', '%', '\"', \"'\", '`', '@', '=',\n  '^',\n];\n\nconst is = {\n  escape: c => c == '\\\\',\n  space:  c => /[\\r\\n\\t\\s]/.test(c),\n  digit:  c => /^[0-9]$/.test(c),\n  sign:   c => /^[+-]$/.test(c),\n  dot:    c => c == '.',\n  quote:  c => /^[\"'`]$/.test(c),\n  symbol: c => symbols.includes(c),\n  hexNum: c => /^[0-9a-f]$/i.test(c),\n  hex:           (a, b, c) => a == '0' && is.letter(b, 'x') && is.hexNum(c),\n  expWithSign:   (a, b, c) => is.letter(a, 'e') && is.sign(b) && is.digit(c),\n  exp:           (a, b) => is.letter(a, 'e') && is.digit(b),\n  dots:          (a, b) => is.dot(a) && is.dot(b),\n  letter:        (a, b) => String(a).toLowerCase() == String(b).toLowerCase(),\n  comment:       (a, b) => a == '/' && b == '*',\n  inlineComment: (a, b) => a == '/' && b === '/',\n  selfClosedTag: (a, b) => a == '/' && b == '>',\n  closedTag:     (a, b) => a == '<' && b == '/',\n}\n\nclass Token {\n  constructor({ type, value, pos, status }) {\n    this.type = type;\n    this.value = value;\n    this.pos = pos;\n    if (status) {\n      this.status = status;\n    }\n  }\n  isSymbol(...values) {\n    let isSymbol = this.type == 'Symbol';\n    if (!values.length) return isSymbol;\n    return values.some(c => c === this.value);\n  }\n  isSpace() {\n    return this.type == 'Space';\n  }\n  isNumber() {\n    return this.type == 'Number';\n  }\n  isWord() {\n    return this.type == 'Word';\n  }\n}\n\nfunction iterator(input) {\n  let pointer = -1;\n  let max = input.length;\n  let col = -1, row = 0;\n  return {\n    curr(n = 0) {\n      return input[pointer + n];\n    },\n    next(n = 1) {\n      let next = input[pointer += n];\n      if (next === '\\n') row++, col = 0;\n      else col += n;\n      return next;\n    },\n    end() {\n      return pointer >= max;\n    },\n    get() {\n      return {\n        prev:  input[pointer - 1],\n        curr:  input[pointer + 0],\n        next:  input[pointer + 1],\n        next2: input[pointer + 2],\n        next3: input[pointer + 3],\n        pos:   [col, row],\n      }\n    }\n  }\n}\n\nfunction skipComments(iter) {\n  while (iter.next()) {\n    let { curr, prev } = iter.get();\n    if (is.comment(curr, prev)) break;\n  }\n}\n\nfunction skipInlineComments(iter) {\n  while (iter.next()) {\n    if (iter.curr() === '\\n') break;\n  }\n}\n\nfunction ignoreSpacingSymbol(value) {\n   return [':', ';', ',', '{', '}', '(', ')', '[', ']'].includes(value);\n}\n\nfunction readWord(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let { curr, next } = iter.get();\n    temp += curr;\n    let isBreak = is.symbol(next) || is.space(next) || is.digit(next);\n    if (temp.length && isBreak) {\n      if (!is.closedTag(curr, next)) break;\n    }\n    iter.next();\n  }\n  return temp.trim();\n}\n\nfunction readSpaces(iter) {\n  let temp = '';\n  while (!iter.end()) {\n    let { curr, next } = iter.get();\n    temp += curr;\n    if (!is.space(next)) break;\n    iter.next();\n  }\n  return temp;\n}\n\nfunction readNumber(iter) {\n  let temp = '';\n  let hasDot = false;\n  while (!iter.end()) {\n    let { curr, next, next2, next3 } = iter.get();\n    temp += curr;\n    if (hasDot && is.dot(next)) break;\n    if (is.dot(curr)) hasDot = true;\n    if (is.dots(next, next2)) break;\n    if (is.expWithSign(next, next2, next3)) {\n      temp += iter.next() + iter.next();\n    }\n    else if (is.exp(next, next2)) {\n      temp += iter.next();\n    }\n    else if (!is.digit(next) && !is.dot(next)) {\n      break;\n    }\n    iter.next();\n  }\n  return temp;\n}\n\nfunction readHexNumber(iter) {\n  let temp = '0x';\n  iter.next(2);\n  while (!iter.end()) {\n    let { curr, next } = iter.get();\n    temp += curr;\n    if (!is.hexNum(next)) break;\n    iter.next();\n  }\n  return temp;\n}\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n\nfunction scan(source, options = {}) {\n  let iter = iterator(String(source).trim());\n  let tokens = [];\n  let quoteStack = [];\n\n  while (iter.next()) {\n    let { prev, curr, next, next2, pos } = iter.get();\n    if (is.comment(curr, next)) {\n      skipComments(iter);\n    }\n    else if (options.ignoreInlineComment && is.inlineComment(curr, next)) {\n      skipInlineComments(iter);\n    }\n    else if (is.hex(curr, next, next2)) {\n      let num = readHexNumber(iter);\n      tokens.push(new Token({\n        type: 'Number', value: num, pos\n      }));\n    }\n    else if (is.digit(curr) || (\n        is.digit(next) && is.dot(curr) && !is.dots(prev, curr))) {\n      let num = readNumber(iter);\n      tokens.push(new Token({\n        type: 'Number', value: num, pos\n      }));\n    }\n    else if (is.symbol(curr) && !is.selfClosedTag(curr, next)) {\n      let lastToken = last(tokens);\n      // negative\n      let isNextDigit = is.digit(next) || (is.dot(next) && is.digit(next2));\n      if (curr === '-' && isNextDigit && (!lastToken || !lastToken.isNumber())) {\n        let num = readNumber(iter);\n        tokens.push(new Token({\n          type: 'Number', value: num, pos\n        }));\n        continue;\n      }\n\n      let token = {\n        type: 'Symbol', value: curr, pos\n      }\n      // Escaped symbols\n      if (quoteStack.length && is.escape(lastToken.value)) {\n        tokens.pop();\n        let word = readWord(iter);\n        if (word.length) {\n          tokens.push(new Token({\n            type: 'Word', value: word, pos\n          }));\n        }\n      }\n      else {\n        if (is.quote(curr)) {\n          let lastQuote = last(quoteStack);\n          if (lastQuote == curr) {\n            quoteStack.pop();\n            token.status = 'close';\n          } else {\n            quoteStack.push(curr);\n            token.status = 'open';\n          }\n        }\n\n        tokens.push(new Token(token));\n      }\n    }\n    else if (is.space(curr)) {\n      let spaces = readSpaces(iter);\n      let lastToken = last(tokens);\n      let { next } = iter.get();\n      // Reduce unnecessary spaces\n      if (!quoteStack.length && lastToken) {\n        let prev = lastToken.value;\n        let ignoreLeft = (ignoreSpacingSymbol(prev) && prev !== ')');\n        let ignoreRight = (ignoreSpacingSymbol(next) && next !== '(');\n        if (ignoreLeft || ignoreRight)  {\n          continue;\n        } else {\n          spaces = options.preserveLineBreak ? curr : ' ';\n        }\n      }\n      if (tokens.length && (next && next.trim())) {\n        tokens.push(new Token({\n          type: 'Space', value: spaces, pos\n        }));\n      }\n    }\n    else {\n      let word = readWord(iter);\n      if (word.length) {\n        tokens.push(new Token({\n          type: 'Word', value: word, pos\n        }));\n      }\n    }\n  }\n\n  // Remove last space token\n  let lastToken = last(tokens);\n  if (lastToken && lastToken.isSpace()) {\n    tokens.length = tokens.length - 1;\n  }\n  return tokens;\n}\n\nexport {\n  symbols,\n  is,\n  iterator,\n  scan,\n  Token\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}