{"ast":null,"code":"import { create_svg_url, normalize_svg } from './utils/svg.js';\nimport { generate_svg } from './generator/svg.js';\nimport { cell_id, is_letter, is_nil, is_empty, add_alias, unique_id, lerp } from './utils/index.js';\nimport { lazy, clamp, sequence, get_value } from './utils/index.js';\nimport { by_unit, by_charcode } from './utils/transform.js';\nimport { last } from './utils/list.js';\nimport calc from './calc.js';\nimport { memo } from './utils/memo.js';\nimport { expand } from './utils/expand.js';\nimport Stack from './utils/stack.js';\nimport Noise from './utils/noise.js';\nimport get_named_arguments from './utils/get-named-arguments.js';\nimport { shapes, create_shape_points } from './generator/shapes.js';\nimport parse_value_group from './parser/parse-value-group.js';\nimport parse_shape_commands from './parser/parse-shape-commands.js';\nimport parse_svg from './parser/parse-svg.js';\nimport parse_svg_path from './parser/parse-svg-path.js';\nimport parse_compound_value from './parser/parse-compound-value.js';\nimport * as Uniforms from './uniforms.js';\nfunction make_sequence(c) {\n  return lazy(function (_, n) {\n    for (var _len = arguments.length, actions = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      actions[_key - 2] = arguments[_key];\n    }\n    if (!actions || !n) return '';\n    let count = get_value(n());\n    let evaluated = count;\n    if (/\\D/.test(count) && !/\\d+[x-]\\d+/.test(count)) {\n      evaluated = calc(count);\n      if (evaluated === 0) {\n        evaluated = count;\n      }\n    }\n    let signature = Math.random();\n    return sequence(evaluated, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return actions.map(action => {\n        return get_value(action(...args, signature));\n      }).join(',');\n    }).join(c);\n  });\n}\nfunction push_stack(context, name, value) {\n  if (!context[name]) context[name] = new Stack(1024);\n  context[name].push(value);\n  return value;\n}\nfunction flip_value(num) {\n  return -1 * num;\n}\nfunction map2d(value, min, max) {\n  let amp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  let dimension = 2;\n  let v = Math.sqrt(dimension / 4) * amp;\n  let [ma, mb] = [-v, v];\n  return lerp((value - ma) / (mb - ma), min * amp, max * amp);\n}\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+':\n      return a + b;\n    case '-':\n      return a - b;\n    case '*':\n      return a * b;\n    case '/':\n      return a / b;\n    case '%':\n      return a % b;\n    default:\n      return 0;\n  }\n}\nfunction calc_with(base) {\n  return v => {\n    if (is_empty(v) || is_empty(base)) {\n      return base;\n    }\n    if (/^[+*-\\/%][\\-.\\d\\s]/.test(v)) {\n      let op = v[0];\n      let {\n        unit = '',\n        value\n      } = parse_compound_value(v.substr(1).trim() || 0);\n      return compute(op, base, value) + unit;\n    } else if (/[+*-\\/%]$/.test(v)) {\n      let op = v.substr(-1);\n      let {\n        unit = '',\n        value\n      } = parse_compound_value(v.substr(0, v.length - 1).trim() || 0);\n      return compute(op, value, base) + unit;\n    } else {\n      let {\n        unit = '',\n        value\n      } = parse_compound_value(v || 0);\n      return base + value + unit;\n    }\n  };\n}\nconst Expose = add_alias({\n  i(_ref) {\n    let {\n      count\n    } = _ref;\n    return calc_with(count);\n  },\n  y(_ref2) {\n    let {\n      y\n    } = _ref2;\n    return calc_with(y);\n  },\n  x(_ref3) {\n    let {\n      x\n    } = _ref3;\n    return calc_with(x);\n  },\n  z(_ref4) {\n    let {\n      z\n    } = _ref4;\n    return calc_with(z);\n  },\n  I(_ref5) {\n    let {\n      grid\n    } = _ref5;\n    return calc_with(grid.count);\n  },\n  Y(_ref6) {\n    let {\n      grid\n    } = _ref6;\n    return calc_with(grid.y);\n  },\n  X(_ref7) {\n    let {\n      grid\n    } = _ref7;\n    return calc_with(grid.x);\n  },\n  Z(_ref8) {\n    let {\n      grid\n    } = _ref8;\n    return calc_with(grid.z);\n  },\n  id(_ref9) {\n    let {\n      x,\n      y,\n      z\n    } = _ref9;\n    return _ => cell_id(x, y, z);\n  },\n  dx(_ref0) {\n    let {\n      x,\n      grid\n    } = _ref0;\n    return n => {\n      n = Number(n) || 0;\n      return x - .5 - n - grid.x / 2;\n    };\n  },\n  dy(_ref1) {\n    let {\n      y,\n      grid\n    } = _ref1;\n    return n => {\n      n = Number(n) || 0;\n      return y - .5 - n - grid.y / 2;\n    };\n  },\n  n(_ref10) {\n    let {\n      extra\n    } = _ref10;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[0]) : '@n';\n  },\n  nx(_ref11) {\n    let {\n      extra\n    } = _ref11;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[1]) : '@nx';\n  },\n  ny(_ref12) {\n    let {\n      extra\n    } = _ref12;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[2]) : '@ny';\n  },\n  N(_ref13) {\n    let {\n      extra\n    } = _ref13;\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[3]) : '@N';\n  },\n  m: make_sequence(','),\n  M: make_sequence(' '),\n  µ: make_sequence(''),\n  p(_ref14) {\n    let {\n      context,\n      pick\n    } = _ref14;\n    return expand(function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      if (!args.length) {\n        args = context.last_pick_args || [];\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n  P(_ref15) {\n    let {\n      context,\n      pick,\n      position\n    } = _ref15;\n    let counter = 'P-counter' + position;\n    return expand(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      let normal = true;\n      if (!args.length) {\n        args = context.last_pick_args || [];\n        normal = false;\n      }\n      let stack = context.last_pick;\n      let last = stack ? stack.last(1) : '';\n      if (normal) {\n        if (!context[counter]) {\n          context[counter] = {};\n        }\n        last = context[counter].last_pick;\n      }\n      if (args.length > 1) {\n        let i = args.findIndex(n => n === last);\n        if (i !== -1) {\n          args.splice(i, 1);\n        }\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      if (normal) {\n        context[counter].last_pick = picked;\n      }\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n  pl(_ref16) {\n    let {\n      context,\n      extra,\n      position\n    } = _ref16;\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pl-counter' + position + sig;\n    return expand(function () {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = arguments.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = pos < 0 || arguments.length <= pos ? undefined : arguments[pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n  pr(_ref17) {\n    let {\n      context,\n      extra,\n      position\n    } = _ref17;\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pr-counter' + position + sig;\n    return expand(function () {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = arguments.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = max - pos - 1 < 0 || arguments.length <= max - pos - 1 ? undefined : arguments[max - pos - 1];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n  pd(_ref18) {\n    let {\n      context,\n      extra,\n      position,\n      shuffle\n    } = _ref18;\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pd-counter' + position + sig;\n    let values = 'pd-values' + position + sig;\n    ;\n    return expand(function () {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      if (!context[values]) {\n        context[values] = shuffle(args || []);\n      }\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = context[values][pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n  lp(_ref19) {\n    let {\n      context\n    } = _ref19;\n    return function () {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      let stack = context.last_pick;\n      return stack ? stack.last(n) : '';\n    };\n  },\n  r(_ref20) {\n    let {\n      context,\n      rand\n    } = _ref20;\n    return function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      let transform = args.every(is_letter) ? by_charcode : by_unit;\n      let value = transform(rand)(...args);\n      return push_stack(context, 'last_rand', value);\n    };\n  },\n  rn(_ref21) {\n    let {\n      x,\n      y,\n      context,\n      position,\n      grid,\n      extra,\n      random\n    } = _ref21;\n    let counter = 'noise-2d' + position;\n    let counterX = counter + 'offset-x';\n    let counterY = counter + 'offset-y';\n    let [ni, nx, ny, nm, NX, NY] = last(extra) || [];\n    let isSeqContext = ni && nm;\n    return function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      let {\n        from = 0,\n        to = from,\n        frequency = 1,\n        scale = 1,\n        octave = 1\n      } = get_named_arguments(args, ['from', 'to', 'frequency', 'scale', 'octave']);\n      frequency = clamp(frequency, 0, Infinity);\n      scale = clamp(scale, 0, Infinity);\n      octave = clamp(octave, 1, 100);\n      if (args.length == 1) [from, to] = [0, from];\n      if (!context[counter]) context[counter] = new Noise();\n      if (!context[counterX]) context[counterX] = random();\n      if (!context[counterY]) context[counterY] = random();\n      let transform = is_letter(from) && is_letter(to) ? by_charcode : by_unit;\n      let noise2d = context[counter];\n      let offsetX = context[counterX];\n      let offsetY = context[counterY];\n      let _x = (isSeqContext ? (nx - 1) / NX : (x - 1) / grid.x) + offsetX;\n      let _y = (isSeqContext ? (ny - 1) / NY : (y - 1) / grid.y) + offsetY;\n\n      // 1-dimentional\n      if (NX <= 1 || grid.x <= 1) _x = 0;\n      if (NY <= 1 || grid.y <= 1) _y = 0;\n\n      // 1x1\n      if (_x == 0 && _y == 0) {\n        _x = offsetX;\n        _y = offsetY;\n      }\n      let t = noise2d.noise(_x * frequency, _y * frequency, 0) * scale;\n      for (let i = 1; i < octave; ++i) {\n        let i2 = i * 2;\n        t += noise2d.noise(_x * frequency * i2, _y * frequency * i2, 0) * (scale / i2);\n      }\n      let fn = transform((from, to) => map2d(t, from, to, scale));\n      return push_stack(context, 'last_rand', fn(from, to));\n    };\n  },\n  lr(_ref22) {\n    let {\n      context\n    } = _ref22;\n    return function () {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      let stack = context.last_rand;\n      return stack ? stack.last(n) : '';\n    };\n  },\n  stripe() {\n    return function () {\n      for (var _len8 = arguments.length, input = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        input[_key8] = arguments[_key8];\n      }\n      let colors = input.map(get_value);\n      let max = colors.length;\n      let default_count = 0;\n      let custom_sizes = [];\n      let prev;\n      if (!max) {\n        return '';\n      }\n      colors.forEach(step => {\n        let [_, size] = parse_value_group(step);\n        if (size !== undefined) custom_sizes.push(size);else default_count += 1;\n      });\n      let default_size = custom_sizes.length ? \"(100% - \".concat(custom_sizes.join(' - '), \") / \").concat(default_count) : \"100% / \".concat(max);\n      return colors.map((step, i) => {\n        if (custom_sizes.length) {\n          let [color, size] = parse_value_group(step);\n          let prefix = prev ? prev + ' + ' : '';\n          prev = prefix + (size !== undefined ? size : default_size);\n          return \"\".concat(color, \" 0 calc(\").concat(prev, \")\");\n        }\n        return \"\".concat(step, \" 0 \").concat(100 / max * (i + 1), \"%\");\n      }).join(',');\n    };\n  },\n  calc() {\n    return (value, context) => {\n      return calc(get_value(value), context);\n    };\n  },\n  hex() {\n    return value => parseInt(get_value(value)).toString(16);\n  },\n  svg: lazy(function (_) {\n    for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      args[_key9 - 1] = arguments[_key9];\n    }\n    let value = args.map(input => get_value(input())).join(',');\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value);\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value);\n    return create_svg_url(svg);\n  }),\n  'svg-filter': lazy(function (upstream) {\n    for (var _len0 = arguments.length, args = new Array(_len0 > 1 ? _len0 - 1 : 0), _key0 = 1; _key0 < _len0; _key0++) {\n      args[_key0 - 1] = arguments[_key0];\n    }\n    let values = args.map(input => get_value(input()));\n    let value = values.join(',');\n    let id = unique_id('filter-');\n    // shorthand\n    if (values.every(n => /^[\\-\\d.]/.test(n) || /^(\\w+)/.test(n) && !/[{}<>]/.test(n))) {\n      let {\n        frequency,\n        scale,\n        octave,\n        seed = upstream.seed,\n        blur,\n        erode,\n        dilate\n      } = get_named_arguments(values, ['frequency', 'scale', 'octave', 'seed', 'blur', 'erode', 'dilate']);\n      value = \"\\n        x: -20%;\\n        y: -20%;\\n        width: 140%;\\n        height: 140%;\\n      \";\n      if (!is_nil(dilate)) {\n        value += \"\\n          feMorphology {\\n            operator: dilate;\\n            radius: \".concat(dilate, \";\\n          }\\n        \");\n      }\n      if (!is_nil(erode)) {\n        value += \"\\n          feMorphology {\\n            operator: erode;\\n            radius: \".concat(erode, \";\\n          }\\n        \");\n      }\n      if (!is_nil(blur)) {\n        value += \"\\n          feGaussianBlur {\\n            stdDeviation: \".concat(blur, \";\\n          }\\n        \");\n      }\n      if (!is_nil(frequency)) {\n        let [bx, by = bx] = parse_value_group(frequency);\n        octave = octave ? \"numOctaves: \".concat(octave, \";\") : '';\n        value += \"\\n          feTurbulence {\\n            type: fractalNoise;\\n            baseFrequency: \".concat(bx, \" \").concat(by, \";\\n            seed: \").concat(seed, \";\\n            \").concat(octave, \"\\n          }\\n        \");\n        if (scale) {\n          value += \"\\n            feDisplacementMap {\\n              in: SourceGraphic;\\n              scale: \".concat(scale, \";\\n            }\\n          \");\n        }\n      }\n    }\n    // new svg syntax\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value, {\n        type: 'block',\n        name: 'filter'\n      });\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value).replace(/<filter([\\s>])/, \"<filter id=\\\"\".concat(id, \"\\\"$1\"));\n    return create_svg_url(svg, id);\n  }),\n  'svg-pattern': lazy(function (_) {\n    for (var _len1 = arguments.length, args = new Array(_len1 > 1 ? _len1 - 1 : 0), _key1 = 1; _key1 < _len1; _key1++) {\n      args[_key1 - 1] = arguments[_key1];\n    }\n    let value = args.map(input => get_value(input())).join(',');\n    let parsed = parse_svg(\"\\n      viewBox: 0 0 1 1;\\n      preserveAspectRatio: xMidYMid slice;\\n      rect {\\n        width, height: 100%;\\n        fill: defs pattern { \".concat(value, \" }\\n      }\\n    \"));\n    let svg = generate_svg(parsed);\n    return create_svg_url(svg);\n  }),\n  'svg-polygon': lazy(function (_) {\n    var _strokeWidth, _config$_strokeWidth, _stroke, _config$_stroke, _fill, _config$_fill;\n    for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n      args[_key10 - 1] = arguments[_key10];\n    }\n    let value = args.map(input => get_value(input())).join(',');\n    let config = parse_shape_commands(value);\n    delete config.frame;\n    config['unit'] = 'none';\n    (_config$_strokeWidth = config[_strokeWidth = 'stroke-width']) !== null && _config$_strokeWidth !== void 0 ? _config$_strokeWidth : config[_strokeWidth] = .01;\n    (_config$_stroke = config[_stroke = 'stroke']) !== null && _config$_stroke !== void 0 ? _config$_stroke : config[_stroke] = 'currentColor';\n    (_config$_fill = config[_fill = 'fill']) !== null && _config$_fill !== void 0 ? _config$_fill : config[_fill] = 'none';\n    let points = \"points: \".concat(create_shape_points(config, {\n      min: 3,\n      max: 65536\n    }), \";\");\n    let props = '';\n    for (let name of Object.keys(config)) {\n      if (/^(stroke|fill|clip|marker|mask|animate|draw)/.test(name)) {\n        props += \"\".concat(name, \": \").concat(config[name], \";\");\n      }\n    }\n    ;\n    let parsed = parse_svg(\"\\n      viewBox: -1 -1 2 2 p \".concat(Number(config['stroke-width']) / 2, \";\\n      polygon {\\n        \").concat(props, \" \").concat(points, \"\\n      }\\n    \"));\n    return create_svg_url(generate_svg(parsed));\n  }),\n  var() {\n    return value => \"var(\".concat(get_value(value), \")\");\n  },\n  ut() {\n    return value => \"var(--\".concat(Uniforms.uniform_time.name, \")\");\n  },\n  uw() {\n    return value => \"var(--\".concat(Uniforms.uniform_width.name, \")\");\n  },\n  uh() {\n    return value => \"var(--\".concat(Uniforms.uniform_height.name, \")\");\n  },\n  ux() {\n    return value => \"var(--\".concat(Uniforms.uniform_mousex.name, \")\");\n  },\n  uy() {\n    return value => \"var(--\".concat(Uniforms.uniform_mousey.name, \")\");\n  },\n  plot(_ref23) {\n    let {\n      count,\n      context,\n      extra,\n      position,\n      grid\n    } = _ref23;\n    let key = 'offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        context[key] = create_shape_points(config, {\n          min: 1,\n          max: 65536\n        });\n      }\n      return context[key][idx - 1];\n    };\n  },\n  Plot(_ref24) {\n    let {\n      count,\n      context,\n      extra,\n      position,\n      grid\n    } = _ref24;\n    let key = 'Offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        config.unit = config.unit || 'none';\n        context[key] = create_shape_points(config, {\n          min: 1,\n          max: 65536\n        });\n      }\n      return context[key][idx - 1];\n    };\n  },\n  shape() {\n    return memo('shape-function', function () {\n      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      type = String(type).trim();\n      let points = [];\n      if (type.length) {\n        for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n          args[_key11 - 1] = arguments[_key11];\n        }\n        if (typeof shapes[type] === 'function') {\n          points = shapes[type](args);\n        } else {\n          let commands = type;\n          let rest = args.join(',');\n          if (rest.length) {\n            commands = type + ',' + rest;\n          }\n          let config = parse_shape_commands(commands);\n          points = create_shape_points(config, {\n            min: 3,\n            max: 3600\n          });\n        }\n      }\n      return \"polygon(\".concat(points.join(','), \")\");\n    });\n  },\n  doodle() {\n    return value => value;\n  },\n  shaders() {\n    return value => value;\n  },\n  canvas() {\n    return value => value;\n  },\n  pattern() {\n    return value => value;\n  },\n  invert() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(_ref25 => {\n        let {\n          name,\n          value\n        } = _ref25;\n        switch (name) {\n          case 'v':\n            return 'h' + value.join(' ');\n          case 'V':\n            return 'H' + value.join(' ');\n          case 'h':\n            return 'v' + value.join(' ');\n          case 'H':\n            return 'V' + value.join(' ');\n          default:\n            return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n  flipH() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(_ref26 => {\n        let {\n          name,\n          value\n        } = _ref26;\n        switch (name) {\n          case 'h':\n          case 'H':\n            return name + value.map(flip_value).join(' ');\n          default:\n            return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n  flipV() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(_ref27 => {\n        let {\n          name,\n          value\n        } = _ref27;\n        switch (name) {\n          case 'v':\n          case 'V':\n            return name + value.map(flip_value).join(' ');\n          default:\n            return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n  flip() {\n    let flipH = Expose.flipH(...arguments);\n    let flipV = Expose.flipV(...arguments);\n    return commands => {\n      return flipV(flipH(commands));\n    };\n  },\n  reverse() {\n    return function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      let commands = args.map(get_value);\n      let parsed = parse_svg_path(commands.join(','));\n      if (parsed.valid) {\n        let result = [];\n        for (let i = parsed.commands.length - 1; i >= 0; --i) {\n          let {\n            name,\n            value\n          } = parsed.commands[i];\n          result.push(name + value.join(' '));\n        }\n        return result.join(' ');\n      }\n      return commands.reverse();\n    };\n  },\n  cycle() {\n    return function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      args = args.map(n => '(' + n + ')');\n      let list = [];\n      let separator;\n      if (args.length == 1) {\n        separator = ' ';\n        ;\n        list = parse_value_group(args[0], {\n          symbol: separator\n        });\n      } else {\n        separator = ',';\n        list = parse_value_group(args.map(get_value).join(separator), {\n          symbol: separator\n        });\n      }\n      list = list.map(n => n.replace(/^\\(|\\)$/g, ''));\n      let size = list.length - 1;\n      let result = [list.join(separator)];\n      // Just ignore the performance\n      for (let i = 0; i < size; ++i) {\n        let item = list.shift();\n        list.push(item);\n        result.push(list.join(separator));\n      }\n      return result;\n    };\n  },\n  mirror() {\n    return function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      for (let i = args.length - 1; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    };\n  },\n  Mirror() {\n    return function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      for (let i = args.length - 2; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    };\n  },\n  code() {\n    return function () {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return args.map(code => String.fromCharCode(code));\n    };\n  },\n  once(_ref28) {\n    let {\n      context,\n      extra,\n      position\n    } = _ref28;\n    let counter = 'once-counter' + position;\n    return function () {\n      if (is_nil(context[counter])) {\n        for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n          args[_key17] = arguments[_key17];\n        }\n        context[counter] = args;\n      }\n      return context[counter];\n    };\n  },\n  raw(_ref29) {\n    let {\n      rules\n    } = _ref29;\n    return function () {\n      let raw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      try {\n        let cut = raw.substring(raw.indexOf(',') + 1, raw.lastIndexOf('\")'));\n        if (raw.startsWith('${doodle') && raw.endsWith('}')) {\n          let key = raw.substring(2, raw.length - 1);\n          let doodles = rules.doodles;\n          if (doodles && doodles[key]) {\n            return \"<css-doodle>\".concat(doodles[key].doodle, \"</css-doodle>\");\n          }\n        }\n        if (raw.startsWith('url(\"data:image/svg+xml;utf8')) {\n          return decodeURIComponent(cut);\n        }\n        /* future forms */\n        if (raw.startsWith('url(\"data:image/svg+xml;base64')) {\n          return atob(cut);\n        }\n        if (raw.startsWith('url(\"data:image/png;base64')) {\n          return \"<img src=\\\"\".concat(raw, \"\\\" alt=\\\"\\\" />\");\n        }\n      } catch (e) {\n        /* ignore */\n      }\n      return raw;\n    };\n  }\n}, {\n  'index': 'i',\n  'col': 'x',\n  'row': 'y',\n  'depth': 'z',\n  'rand': 'r',\n  'pick': 'p',\n  'pn': 'pl',\n  'pnr': 'pr',\n  // error prone\n  'stripes': 'stripe',\n  'strip': 'stripe',\n  'patern': 'pattern',\n  'flipv': 'flipV',\n  'fliph': 'flipH',\n  // legacy names, keep them before 1.0\n  't': 'ut',\n  'filter': 'svg-filter',\n  'last-rand': 'lr',\n  'last-pick': 'lp',\n  'multiple': 'm',\n  'multi': 'm',\n  'rep': 'µ',\n  'repeat': 'µ',\n  'ms': 'M',\n  's': 'I',\n  'size': 'I',\n  'sx': 'X',\n  'size-x': 'X',\n  'size-col': 'X',\n  'max-col': 'X',\n  'sy': 'Y',\n  'size-y': 'Y',\n  'size-row': 'Y',\n  'max-row': 'Y',\n  'sz': 'Z',\n  'size-z': 'Z',\n  'size-depth': 'Z',\n  'Svg': 'svg',\n  'pick-by-turn': 'pl',\n  'pick-n': 'pl',\n  'pick-d': 'pd',\n  'offset': 'plot',\n  'Offset': 'Plot',\n  'point': 'plot',\n  'Point': 'Plot',\n  'paint': 'canvas',\n  'unicode': 'code'\n});\nexport default Expose;","map":{"version":3,"names":["create_svg_url","normalize_svg","generate_svg","cell_id","is_letter","is_nil","is_empty","add_alias","unique_id","lerp","lazy","clamp","sequence","get_value","by_unit","by_charcode","last","calc","memo","expand","Stack","Noise","get_named_arguments","shapes","create_shape_points","parse_value_group","parse_shape_commands","parse_svg","parse_svg_path","parse_compound_value","Uniforms","make_sequence","c","_","n","_len","arguments","length","actions","Array","_key","count","evaluated","test","signature","Math","random","_len2","args","_key2","map","action","join","push_stack","context","name","value","push","flip_value","num","map2d","min","max","amp","undefined","dimension","v","sqrt","ma","mb","compute","op","a","b","calc_with","base","unit","substr","trim","Expose","i","_ref","y","_ref2","x","_ref3","z","_ref4","I","_ref5","grid","Y","_ref6","X","_ref7","Z","_ref8","id","_ref9","dx","_ref0","Number","dy","_ref1","_ref10","extra","lastExtra","nx","_ref11","ny","_ref12","N","_ref13","m","M","µ","p","_ref14","pick","_len3","_key3","last_pick_args","picked","P","_ref15","position","counter","_len4","_key4","normal","stack","last_pick","findIndex","splice","pl","_ref16","sig","idx","pos","pr","_ref17","pd","_ref18","shuffle","values","_len5","_key5","lp","_ref19","r","_ref20","rand","_len6","_key6","transform","every","rn","_ref21","counterX","counterY","ni","nm","NX","NY","isSeqContext","_len7","_key7","from","to","frequency","scale","octave","Infinity","noise2d","offsetX","offsetY","_x","_y","t","noise","i2","fn","lr","_ref22","last_rand","stripe","_len8","input","_key8","colors","default_count","custom_sizes","prev","forEach","step","size","default_size","concat","color","prefix","hex","parseInt","toString","svg","_len9","_key9","startsWith","parsed","upstream","_len0","_key0","seed","blur","erode","dilate","bx","by","type","replace","_len1","_key1","_strokeWidth","_config$_strokeWidth","_stroke","_config$_stroke","_fill","_config$_fill","_len10","_key10","config","frame","points","props","Object","keys","var","ut","uniform_time","uw","uniform_width","uh","uniform_height","ux","uniform_mousex","uy","uniform_mousey","plot","_ref23","key","commands","__","Plot","_ref24","shape","String","_len11","_key11","rest","doodle","shaders","canvas","pattern","invert","valid","_ref25","flipH","_ref26","flipV","_ref27","flip","reverse","_len12","_key12","result","cycle","_len13","_key13","list","separator","symbol","item","shift","mirror","_len14","_key14","Mirror","_len15","_key15","code","_len16","_key16","fromCharCode","once","_ref28","_len17","_key17","raw","_ref29","rules","cut","substring","indexOf","lastIndexOf","endsWith","doodles","decodeURIComponent","atob","e"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/function.js"],"sourcesContent":["import { create_svg_url, normalize_svg } from './utils/svg.js';\nimport { generate_svg } from './generator/svg.js';\n\nimport { cell_id, is_letter, is_nil, is_empty, add_alias, unique_id, lerp } from './utils/index.js';\nimport { lazy, clamp, sequence, get_value } from './utils/index.js';\nimport { by_unit, by_charcode } from './utils/transform.js';\nimport { last } from './utils/list.js';\n\nimport calc from './calc.js';\nimport { memo } from './utils/memo.js';\nimport { expand } from './utils/expand.js';\nimport Stack from './utils/stack.js';\nimport Noise from './utils/noise.js';\nimport get_named_arguments from './utils/get-named-arguments.js';\n\nimport { shapes, create_shape_points } from './generator/shapes.js';\nimport parse_value_group from './parser/parse-value-group.js';\nimport parse_shape_commands from './parser/parse-shape-commands.js';\nimport parse_svg from './parser/parse-svg.js';\nimport parse_svg_path from './parser/parse-svg-path.js';\nimport parse_compound_value from './parser/parse-compound-value.js';\n\nimport * as Uniforms from './uniforms.js';\n\nfunction make_sequence(c) {\n  return lazy((_, n, ...actions) => {\n    if (!actions || !n) return '';\n    let count = get_value(n());\n    let evaluated = count;\n    if (/\\D/.test(count) && !/\\d+[x-]\\d+/.test(count)) {\n      evaluated = calc(count);\n      if (evaluated === 0) {\n        evaluated = count;\n      }\n    }\n    let signature = Math.random();\n    return sequence(\n      evaluated,\n      (...args) => {\n        return actions.map(action => {\n          return get_value(action(...args, signature))\n        }).join(',');\n      }\n    ).join(c);\n  });\n}\n\nfunction push_stack(context, name, value) {\n  if (!context[name]) context[name] = new Stack(1024);\n  context[name].push(value);\n  return value;\n}\n\nfunction flip_value(num) {\n  return -1 * num;\n}\n\nfunction map2d(value, min, max, amp = 1) {\n  let dimension = 2;\n  let v = Math.sqrt(dimension / 4) * amp;\n  let [ma, mb] = [-v, v];\n  return lerp((value - ma) / (mb - ma), min * amp, max * amp);\n}\n\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+': return a + b;\n    case '-': return a - b;\n    case '*': return a * b;\n    case '/': return a / b;\n    case '%': return a % b;\n    default: return 0;\n  }\n}\n\nfunction calc_with(base) {\n  return v => {\n    if (is_empty(v) || is_empty(base)) {\n      return base;\n    }\n    if (/^[+*-\\/%][\\-.\\d\\s]/.test(v)) {\n      let op = v[0];\n      let { unit = '', value } = parse_compound_value(v.substr(1).trim() || 0);\n      return compute(op, base, value) + unit;\n    }\n    else if (/[+*-\\/%]$/.test(v)) {\n      let op = v.substr(-1);\n      let { unit = '', value } = parse_compound_value(v.substr(0, v.length - 1).trim() || 0);\n      return compute(op, value, base) + unit;\n    } else {\n      let { unit = '', value } = parse_compound_value(v || 0);\n      return (base + value) + unit;\n    }\n  }\n}\n\nconst Expose = add_alias({\n\n  i({ count }) {\n    return calc_with(count);\n  },\n\n  y({ y }) {\n    return calc_with(y);\n  },\n\n  x({ x }) {\n    return calc_with(x);\n  },\n\n  z({ z }) {\n    return calc_with(z);\n  },\n\n  I({ grid }) {\n    return calc_with(grid.count);\n  },\n\n  Y({ grid }) {\n    return calc_with(grid.y);\n  },\n\n  X({ grid }) {\n    return calc_with(grid.x);\n  },\n\n  Z({ grid }) {\n    return calc_with(grid.z);\n  },\n\n  id({ x, y, z }) {\n    return _ => cell_id(x, y, z);\n  },\n\n  dx({ x, grid }) {\n    return n => {\n      n = Number(n) || 0;\n      return x - .5 - n - grid.x / 2;\n    }\n  },\n\n  dy({ y, grid }) {\n    return n => {\n      n = Number(n) || 0;\n      return y - .5 - n - grid.y / 2;\n    }\n  },\n\n  n({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[0]) : '@n';\n  },\n\n  nx({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[1]) : '@nx';\n  },\n\n  ny({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[2]) : '@ny';\n  },\n\n  N({ extra }) {\n    let lastExtra = last(extra);\n    return lastExtra ? calc_with(lastExtra[3]) : '@N';\n  },\n\n  m: make_sequence(','),\n\n  M: make_sequence(' '),\n\n  µ: make_sequence(''),\n\n  p({ context, pick }) {\n    return expand((...args) => {\n      if (!args.length) {\n        args = context.last_pick_args || [];\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n\n  P({ context, pick, position }) {\n    let counter = 'P-counter' + position;\n    return expand((...args) => {\n      let normal = true;\n      if (!args.length) {\n        args = context.last_pick_args || [];\n        normal = false;\n      }\n      let stack = context.last_pick;\n      let last = stack ? stack.last(1) : '';\n      if (normal) {\n        if (!context[counter]) {\n          context[counter] = {};\n        }\n        last = context[counter].last_pick;\n      }\n      if (args.length > 1) {\n        let i = args.findIndex(n => n === last);\n        if (i !== -1) {\n          args.splice(i, 1);\n        }\n      }\n      let picked = pick(args);\n      context.last_pick_args = args;\n      if (normal) {\n        context[counter].last_pick = picked;\n      }\n      return push_stack(context, 'last_pick', picked);\n    });\n  },\n\n  pl({ context, extra, position }) {\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pl-counter' + position + sig;\n    return expand((...args) => {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = args[pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n\n  pr({ context, extra, position }) {\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pr-counter' + position + sig;\n    return expand((...args) => {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = args[max - pos - 1];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n\n  pd({ context, extra, position, shuffle }) {\n    let lastExtra = last(extra);\n    let sig = lastExtra ? last(lastExtra) : '';\n    let counter = 'pd-counter' + position  + sig;\n    let values = 'pd-values' + position + sig;;\n    return expand((...args) => {\n      if (!context[counter]) context[counter] = 0;\n      context[counter] += 1;\n      if (!context[values]) {\n        context[values] = shuffle(args || []);\n      }\n      let max = args.length;\n      let idx = lastExtra && lastExtra[6];\n      if (is_nil(idx)) idx = context[counter];\n      let pos = (idx - 1) % max;\n      let value = context[values][pos];\n      return push_stack(context, 'last_pick', value);\n    });\n  },\n\n  lp({ context }) {\n    return (n = 1) => {\n      let stack = context.last_pick;\n      return stack ? stack.last(n) : '';\n    };\n  },\n\n  r({ context, rand }) {\n    return (...args) => {\n      let transform = args.every(is_letter)\n        ? by_charcode\n        : by_unit;\n      let value = transform(rand)(...args);\n      return push_stack(context, 'last_rand', value);\n    };\n  },\n\n  rn({ x, y, context, position, grid, extra, random }) {\n    let counter = 'noise-2d' + position;\n    let counterX = counter + 'offset-x';\n    let counterY = counter + 'offset-y';\n    let [ni, nx, ny, nm, NX, NY] = last(extra) || [];\n    let isSeqContext = (ni && nm);\n    return (...args) => {\n      let {from = 0, to = from, frequency = 1, scale = 1, octave = 1} = get_named_arguments(args, [\n        'from', 'to', 'frequency', 'scale', 'octave'\n      ]);\n\n      frequency = clamp(frequency, 0, Infinity);\n      scale = clamp(scale, 0, Infinity);\n      octave = clamp(octave, 1, 100);\n\n      if (args.length == 1) [from, to] = [0, from];\n      if (!context[counter]) context[counter] = new Noise();\n      if (!context[counterX]) context[counterX] = random();\n      if (!context[counterY]) context[counterY] = random();\n\n      let transform = (is_letter(from) && is_letter(to)) ? by_charcode : by_unit;\n      let noise2d = context[counter];\n      let offsetX = context[counterX];\n      let offsetY = context[counterY];\n      let _x = (isSeqContext ? ((nx - 1) / NX) : ((x - 1) / grid.x)) + offsetX;\n      let _y = (isSeqContext ? ((ny - 1) / NY) : ((y - 1) / grid.y)) + offsetY;\n\n      // 1-dimentional\n      if (NX <= 1 || grid.x <= 1) _x = 0;\n      if (NY <= 1 || grid.y <= 1) _y = 0;\n\n      // 1x1\n      if (_x == 0 && _y == 0) {\n        _x = offsetX;\n        _y = offsetY;\n      }\n\n      let t = noise2d.noise(_x * frequency, _y * frequency, 0) * scale;\n\n      for (let i = 1; i < octave; ++i) {\n        let i2 = i * 2;\n        t += noise2d.noise(_x * frequency * i2, _y * frequency * i2, 0) * (scale / i2);\n      }\n      let fn = transform((from, to) => map2d(t, from, to, scale));\n      return push_stack(context, 'last_rand', fn(from, to));\n    };\n  },\n\n  lr({ context }) {\n    return (n = 1) => {\n      let stack = context.last_rand;\n      return stack ? stack.last(n) : '';\n    };\n  },\n\n  stripe() {\n    return (...input) => {\n      let colors = input.map(get_value);\n      let max = colors.length;\n      let default_count = 0;\n      let custom_sizes = [];\n      let prev;\n      if (!max) {\n        return '';\n      }\n      colors.forEach(step => {\n        let [_, size] = parse_value_group(step);\n        if (size !== undefined) custom_sizes.push(size);\n        else default_count += 1;\n      });\n      let default_size = custom_sizes.length\n        ? `(100% - ${custom_sizes.join(' - ')}) / ${default_count}`\n        : `100% / ${max}`\n      return colors.map((step, i) => {\n        if (custom_sizes.length) {\n          let [color, size] = parse_value_group(step);\n          let prefix = prev ? (prev + ' + ') : '';\n          prev = prefix + (size !== undefined ? size : default_size);\n          return `${color} 0 calc(${ prev })`\n        }\n        return `${step} 0 ${100 / max * (i + 1)}%`\n      })\n      .join(',');\n    }\n  },\n\n  calc() {\n    return (value, context) => {\n      return calc(get_value(value), context);\n    }\n  },\n\n  hex() {\n    return value => parseInt(get_value(value)).toString(16);\n  },\n\n  svg: lazy((_, ...args) => {\n    let value = args.map(input => get_value(input())).join(',');\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value);\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value);\n    return create_svg_url(svg);\n  }),\n\n  'svg-filter': lazy((upstream, ...args) => {\n    let values = args.map(input => get_value(input()));\n    let value = values.join(',');\n    let id = unique_id('filter-');\n    // shorthand\n    if (values.every(n => /^[\\-\\d.]/.test(n) || (/^(\\w+)/.test(n) && !/[{}<>]/.test(n)))) {\n      let { frequency, scale, octave, seed = upstream.seed, blur, erode, dilate } = get_named_arguments(values, [\n        'frequency', 'scale', 'octave', 'seed', 'blur', 'erode', 'dilate'\n      ]);\n      value = `\n        x: -20%;\n        y: -20%;\n        width: 140%;\n        height: 140%;\n      `;\n      if (!is_nil(dilate)) {\n        value += `\n          feMorphology {\n            operator: dilate;\n            radius: ${dilate};\n          }\n        `\n      }\n      if (!is_nil(erode)) {\n        value += `\n          feMorphology {\n            operator: erode;\n            radius: ${erode};\n          }\n        `\n      }\n      if (!is_nil(blur)) {\n        value += `\n          feGaussianBlur {\n            stdDeviation: ${blur};\n          }\n        `\n      }\n      if (!is_nil(frequency)) {\n        let [bx, by = bx] = parse_value_group(frequency);\n        octave = octave ? `numOctaves: ${octave};` : '';\n        value += `\n          feTurbulence {\n            type: fractalNoise;\n            baseFrequency: ${bx} ${by};\n            seed: ${seed};\n            ${octave}\n          }\n        `;\n        if (scale) {\n          value += `\n            feDisplacementMap {\n              in: SourceGraphic;\n              scale: ${scale};\n            }\n          `;\n        }\n      }\n    }\n    // new svg syntax\n    if (!value.startsWith('<')) {\n      let parsed = parse_svg(value, {\n        type: 'block',\n        name: 'filter'\n      });\n      value = generate_svg(parsed);\n    }\n    let svg = normalize_svg(value).replace(\n      /<filter([\\s>])/,\n      `<filter id=\"${ id }\"$1`\n    );\n    return create_svg_url(svg, id);\n  }),\n\n  'svg-pattern': lazy((_, ...args) => {\n    let value = args.map(input => get_value(input())).join(',');\n    let parsed = parse_svg(`\n      viewBox: 0 0 1 1;\n      preserveAspectRatio: xMidYMid slice;\n      rect {\n        width, height: 100%;\n        fill: defs pattern { ${ value } }\n      }\n    `);\n    let svg = generate_svg(parsed);\n    return create_svg_url(svg);\n  }),\n\n  'svg-polygon': lazy((_, ...args) => {\n    let value = args.map(input => get_value(input())).join(',');\n    let config = parse_shape_commands(value);\n\n    delete config.frame;\n    config['unit'] = 'none';\n    config['stroke-width'] ??= .01;\n    config['stroke'] ??= 'currentColor';\n    config['fill'] ??= 'none';\n\n    let points = `points: ${create_shape_points(config, {min: 3, max: 65536})};`;\n    let props = '';\n    for (let name of Object.keys(config)) {\n      if (/^(stroke|fill|clip|marker|mask|animate|draw)/.test(name)) {\n        props += `${name}: ${config[name]};`\n      }\n    };\n    let parsed = parse_svg(`\n      viewBox: -1 -1 2 2 p ${Number(config['stroke-width'])/2};\n      polygon {\n        ${props} ${points}\n      }\n    `);\n    return create_svg_url(generate_svg(parsed));\n  }),\n\n  var() {\n    return value => `var(${ get_value(value) })`;\n  },\n\n  ut() {\n    return value => `var(--${ Uniforms.uniform_time.name })`;\n  },\n\n  uw() {\n    return value => `var(--${ Uniforms.uniform_width.name })`;\n  },\n\n  uh() {\n    return value => `var(--${ Uniforms.uniform_height.name })`;\n  },\n\n  ux() {\n    return value => `var(--${ Uniforms.uniform_mousex.name })`;\n  },\n\n  uy() {\n    return value => `var(--${ Uniforms.uniform_mousey.name })`;\n  },\n\n  plot({ count, context, extra, position, grid }) {\n    let key = 'offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        context[key] = create_shape_points(config, {min: 1, max: 65536});\n      }\n      return context[key][idx - 1];\n    };\n  },\n\n  Plot({ count, context, extra, position, grid }) {\n    let key = 'Offset-points' + position;\n    let lastExtra = last(extra);\n    return commands => {\n      let [idx = count, _, __, max = grid.count] = lastExtra || [];\n      if (!context[key]) {\n        let config = parse_shape_commands(commands);\n        delete config['fill'];\n        delete config['fill-rule'];\n        delete config['frame'];\n        config.points = max;\n        config.unit = config.unit || 'none';\n        context[key] = create_shape_points(config, {min: 1, max: 65536});\n      }\n      return context[key][idx - 1];\n    };\n  },\n\n  shape() {\n    return memo('shape-function', (type = '', ...args) => {\n      type = String(type).trim();\n      let points = [];\n      if (type.length) {\n        if (typeof shapes[type] === 'function') {\n          points = shapes[type](args);\n        } else {\n          let commands = type;\n          let rest = args.join(',');\n          if (rest.length) {\n            commands = type + ',' + rest;\n          }\n          let config = parse_shape_commands(commands);\n          points = create_shape_points(config, {min: 3, max: 3600});\n        }\n      }\n      return `polygon(${points.join(',')})`;\n    });\n  },\n\n  doodle() {\n    return value => value;\n  },\n\n  shaders() {\n    return value => value;\n  },\n\n  canvas() {\n    return value => value;\n  },\n\n  pattern() {\n    return value => value;\n  },\n\n  invert() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(({ name, value }) => {\n        switch (name) {\n          case 'v': return 'h' + value.join(' ');\n          case 'V': return 'H' + value.join(' ');\n          case 'h': return 'v' + value.join(' ');\n          case 'H': return 'V' + value.join(' ');\n          default:  return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n\n  flipH() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(({ name, value }) => {\n        switch (name) {\n          case 'h':\n          case 'H': return name + value.map(flip_value).join(' ');\n          default:  return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n\n  flipV() {\n    return commands => {\n      let parsed = parse_svg_path(commands);\n      if (!parsed.valid) return commands;\n      return parsed.commands.map(({ name, value }) => {\n        switch (name) {\n          case 'v':\n          case 'V': return name + value.map(flip_value).join(' ');\n          default:  return name + value.join(' ');\n        }\n      }).join(' ');\n    };\n  },\n\n  flip(...args) {\n    let flipH = Expose.flipH(...args);\n    let flipV = Expose.flipV(...args);\n    return commands => {\n      return flipV(flipH(commands));\n    }\n  },\n\n  reverse() {\n    return (...args) => {\n      let commands = args.map(get_value);\n      let parsed = parse_svg_path(commands.join(','));\n      if (parsed.valid) {\n        let result = [];\n        for (let i = parsed.commands.length - 1; i >= 0; --i) {\n          let { name, value } = parsed.commands[i];\n          result.push(name + value.join(' '));\n        }\n        return result.join(' ');\n      }\n      return commands.reverse();\n    }\n  },\n\n  cycle() {\n    return (...args) => {\n      args = args.map(n => '(' + n + ')');\n      let list = [];\n      let separator;\n      if (args.length == 1) {\n        separator = ' ';;\n        list = parse_value_group(args[0], { symbol: separator });\n      } else {\n        separator = ',';\n        list = parse_value_group(args.map(get_value).join(separator), { symbol: separator});\n      }\n      list = list.map(n => n.replace(/^\\(|\\)$/g,''));\n      let size = list.length - 1;\n      let result = [list.join(separator)];\n      // Just ignore the performance\n      for (let i = 0; i < size; ++i) {\n        let item = list.shift();\n        list.push(item);\n        result.push(list.join(separator));\n      }\n      return result;\n    }\n  },\n\n  mirror() {\n    return (...args) => {\n      for (let i = args.length - 1; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    }\n  },\n\n  Mirror() {\n    return (...args) => {\n      for (let i = args.length - 2; i >= 0; --i) {\n        args.push(args[i]);\n      }\n      return args;\n    }\n  },\n\n  code() {\n    return (...args) => {\n      return args.map(code => String.fromCharCode(code));\n    }\n  },\n\n  once({ context, extra, position }) {\n    let counter = 'once-counter' + position;\n    return (...args) => {\n      if (is_nil(context[counter])) {\n        context[counter] = args;\n      }\n      return context[counter];\n    }\n  },\n\n  raw({ rules }) {\n    return (raw = '') => {\n      try {\n        let cut = raw.substring(raw.indexOf(',') + 1, raw.lastIndexOf('\")'));\n        if (raw.startsWith('${doodle') && raw.endsWith('}')) {\n          let key = raw.substring(2, raw.length - 1);\n          let doodles = rules.doodles;\n          if (doodles && doodles[key]) {\n            return `<css-doodle>${doodles[key].doodle}</css-doodle>`\n          }\n        }\n        if (raw.startsWith('url(\"data:image/svg+xml;utf8')) {\n          return decodeURIComponent(cut);\n        }\n        /* future forms */\n        if (raw.startsWith('url(\"data:image/svg+xml;base64')) {\n          return atob(cut);\n        }\n        if (raw.startsWith('url(\"data:image/png;base64')) {\n          return `<img src=\"${raw}\" alt=\"\" />`;\n        }\n      } catch (e) {\n        /* ignore */\n      }\n      return raw;\n    }\n  }\n\n}, {\n\n  'index': 'i',\n  'col': 'x',\n  'row': 'y',\n  'depth': 'z',\n  'rand': 'r',\n  'pick': 'p',\n  'pn':   'pl',\n  'pnr':  'pr',\n\n  // error prone\n  'stripes': 'stripe',\n  'strip':   'stripe',\n  'patern':  'pattern',\n  'flipv': 'flipV',\n  'fliph': 'flipH',\n\n  // legacy names, keep them before 1.0\n  't': 'ut',\n  'filter': 'svg-filter',\n  'last-rand': 'lr',\n  'last-pick': 'lp',\n  'multiple': 'm',\n  'multi': 'm',\n  'rep': 'µ',\n  'repeat': 'µ',\n  'ms': 'M',\n  's':  'I',\n  'size': 'I',\n  'sx': 'X',\n  'size-x': 'X',\n  'size-col': 'X',\n  'max-col': 'X',\n  'sy': 'Y',\n  'size-y': 'Y',\n  'size-row': 'Y',\n  'max-row': 'Y',\n  'sz': 'Z',\n  'size-z': 'Z',\n  'size-depth': 'Z',\n  'Svg': 'svg',\n  'pick-by-turn': 'pl',\n  'pick-n': 'pl',\n  'pick-d': 'pd',\n  'offset': 'plot',\n  'Offset': 'Plot',\n  'point': 'plot',\n  'Point': 'Plot',\n  'paint': 'canvas',\n  'unicode': 'code'\n});\n\nexport default Expose;\n"],"mappings":"AAAA,SAASA,cAAc,EAAEC,aAAa,QAAQ,gBAAgB;AAC9D,SAASC,YAAY,QAAQ,oBAAoB;AAEjD,SAASC,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,SAAS,EAAEC,IAAI,QAAQ,kBAAkB;AACnG,SAASC,IAAI,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,kBAAkB;AACnE,SAASC,OAAO,EAAEC,WAAW,QAAQ,sBAAsB;AAC3D,SAASC,IAAI,QAAQ,iBAAiB;AAEtC,OAAOC,IAAI,MAAM,WAAW;AAC5B,SAASC,IAAI,QAAQ,iBAAiB;AACtC,SAASC,MAAM,QAAQ,mBAAmB;AAC1C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,mBAAmB,MAAM,gCAAgC;AAEhE,SAASC,MAAM,EAAEC,mBAAmB,QAAQ,uBAAuB;AACnE,OAAOC,iBAAiB,MAAM,+BAA+B;AAC7D,OAAOC,oBAAoB,MAAM,kCAAkC;AACnE,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,cAAc,MAAM,4BAA4B;AACvD,OAAOC,oBAAoB,MAAM,kCAAkC;AAEnE,OAAO,KAAKC,QAAQ,MAAM,eAAe;AAEzC,SAASC,aAAaA,CAACC,CAAC,EAAE;EACxB,OAAOtB,IAAI,CAAC,UAACuB,CAAC,EAAEC,CAAC,EAAiB;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAZC,OAAO,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAPF,OAAO,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;IAAA;IAC3B,IAAI,CAACF,OAAO,IAAI,CAACJ,CAAC,EAAE,OAAO,EAAE;IAC7B,IAAIO,KAAK,GAAG5B,SAAS,CAACqB,CAAC,CAAC,CAAC,CAAC;IAC1B,IAAIQ,SAAS,GAAGD,KAAK;IACrB,IAAI,IAAI,CAACE,IAAI,CAACF,KAAK,CAAC,IAAI,CAAC,YAAY,CAACE,IAAI,CAACF,KAAK,CAAC,EAAE;MACjDC,SAAS,GAAGzB,IAAI,CAACwB,KAAK,CAAC;MACvB,IAAIC,SAAS,KAAK,CAAC,EAAE;QACnBA,SAAS,GAAGD,KAAK;MACnB;IACF;IACA,IAAIG,SAAS,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC;IAC7B,OAAOlC,QAAQ,CACb8B,SAAS,EACT,YAAa;MAAA,SAAAK,KAAA,GAAAX,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAQ,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;QAAJD,IAAI,CAAAC,KAAA,IAAAb,SAAA,CAAAa,KAAA;MAAA;MACN,OAAOX,OAAO,CAACY,GAAG,CAACC,MAAM,IAAI;QAC3B,OAAOtC,SAAS,CAACsC,MAAM,CAAC,GAAGH,IAAI,EAAEJ,SAAS,CAAC,CAAC;MAC9C,CAAC,CAAC,CAACQ,IAAI,CAAC,GAAG,CAAC;IACd,CACF,CAAC,CAACA,IAAI,CAACpB,CAAC,CAAC;EACX,CAAC,CAAC;AACJ;AAEA,SAASqB,UAAUA,CAACC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAE;EACxC,IAAI,CAACF,OAAO,CAACC,IAAI,CAAC,EAAED,OAAO,CAACC,IAAI,CAAC,GAAG,IAAInC,KAAK,CAAC,IAAI,CAAC;EACnDkC,OAAO,CAACC,IAAI,CAAC,CAACE,IAAI,CAACD,KAAK,CAAC;EACzB,OAAOA,KAAK;AACd;AAEA,SAASE,UAAUA,CAACC,GAAG,EAAE;EACvB,OAAO,CAAC,CAAC,GAAGA,GAAG;AACjB;AAEA,SAASC,KAAKA,CAACJ,KAAK,EAAEK,GAAG,EAAEC,GAAG,EAAW;EAAA,IAATC,GAAG,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA4B,SAAA,GAAA5B,SAAA,MAAG,CAAC;EACrC,IAAI6B,SAAS,GAAG,CAAC;EACjB,IAAIC,CAAC,GAAGrB,IAAI,CAACsB,IAAI,CAACF,SAAS,GAAG,CAAC,CAAC,GAAGF,GAAG;EACtC,IAAI,CAACK,EAAE,EAAEC,EAAE,CAAC,GAAG,CAAC,CAACH,CAAC,EAAEA,CAAC,CAAC;EACtB,OAAOzD,IAAI,CAAC,CAAC+C,KAAK,GAAGY,EAAE,KAAKC,EAAE,GAAGD,EAAE,CAAC,EAAEP,GAAG,GAAGE,GAAG,EAAED,GAAG,GAAGC,GAAG,CAAC;AAC7D;AAEA,SAASO,OAAOA,CAACC,EAAE,EAAEC,CAAC,EAAEC,CAAC,EAAE;EACzB,QAAQF,EAAE;IACR,KAAK,GAAG;MAAE,OAAOC,CAAC,GAAGC,CAAC;IACtB,KAAK,GAAG;MAAE,OAAOD,CAAC,GAAGC,CAAC;IACtB,KAAK,GAAG;MAAE,OAAOD,CAAC,GAAGC,CAAC;IACtB,KAAK,GAAG;MAAE,OAAOD,CAAC,GAAGC,CAAC;IACtB,KAAK,GAAG;MAAE,OAAOD,CAAC,GAAGC,CAAC;IACtB;MAAS,OAAO,CAAC;EACnB;AACF;AAEA,SAASC,SAASA,CAACC,IAAI,EAAE;EACvB,OAAOT,CAAC,IAAI;IACV,IAAI5D,QAAQ,CAAC4D,CAAC,CAAC,IAAI5D,QAAQ,CAACqE,IAAI,CAAC,EAAE;MACjC,OAAOA,IAAI;IACb;IACA,IAAI,oBAAoB,CAAChC,IAAI,CAACuB,CAAC,CAAC,EAAE;MAChC,IAAIK,EAAE,GAAGL,CAAC,CAAC,CAAC,CAAC;MACb,IAAI;QAAEU,IAAI,GAAG,EAAE;QAAEpB;MAAM,CAAC,GAAG3B,oBAAoB,CAACqC,CAAC,CAACW,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;MACxE,OAAOR,OAAO,CAACC,EAAE,EAAEI,IAAI,EAAEnB,KAAK,CAAC,GAAGoB,IAAI;IACxC,CAAC,MACI,IAAI,WAAW,CAACjC,IAAI,CAACuB,CAAC,CAAC,EAAE;MAC5B,IAAIK,EAAE,GAAGL,CAAC,CAACW,MAAM,CAAC,CAAC,CAAC,CAAC;MACrB,IAAI;QAAED,IAAI,GAAG,EAAE;QAAEpB;MAAM,CAAC,GAAG3B,oBAAoB,CAACqC,CAAC,CAACW,MAAM,CAAC,CAAC,EAAEX,CAAC,CAAC7B,MAAM,GAAG,CAAC,CAAC,CAACyC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;MACtF,OAAOR,OAAO,CAACC,EAAE,EAAEf,KAAK,EAAEmB,IAAI,CAAC,GAAGC,IAAI;IACxC,CAAC,MAAM;MACL,IAAI;QAAEA,IAAI,GAAG,EAAE;QAAEpB;MAAM,CAAC,GAAG3B,oBAAoB,CAACqC,CAAC,IAAI,CAAC,CAAC;MACvD,OAAQS,IAAI,GAAGnB,KAAK,GAAIoB,IAAI;IAC9B;EACF,CAAC;AACH;AAEA,MAAMG,MAAM,GAAGxE,SAAS,CAAC;EAEvByE,CAACA,CAAAC,IAAA,EAAY;IAAA,IAAX;MAAExC;IAAM,CAAC,GAAAwC,IAAA;IACT,OAAOP,SAAS,CAACjC,KAAK,CAAC;EACzB,CAAC;EAEDyC,CAACA,CAAAC,KAAA,EAAQ;IAAA,IAAP;MAAED;IAAE,CAAC,GAAAC,KAAA;IACL,OAAOT,SAAS,CAACQ,CAAC,CAAC;EACrB,CAAC;EAEDE,CAACA,CAAAC,KAAA,EAAQ;IAAA,IAAP;MAAED;IAAE,CAAC,GAAAC,KAAA;IACL,OAAOX,SAAS,CAACU,CAAC,CAAC;EACrB,CAAC;EAEDE,CAACA,CAAAC,KAAA,EAAQ;IAAA,IAAP;MAAED;IAAE,CAAC,GAAAC,KAAA;IACL,OAAOb,SAAS,CAACY,CAAC,CAAC;EACrB,CAAC;EAEDE,CAACA,CAAAC,KAAA,EAAW;IAAA,IAAV;MAAEC;IAAK,CAAC,GAAAD,KAAA;IACR,OAAOf,SAAS,CAACgB,IAAI,CAACjD,KAAK,CAAC;EAC9B,CAAC;EAEDkD,CAACA,CAAAC,KAAA,EAAW;IAAA,IAAV;MAAEF;IAAK,CAAC,GAAAE,KAAA;IACR,OAAOlB,SAAS,CAACgB,IAAI,CAACR,CAAC,CAAC;EAC1B,CAAC;EAEDW,CAACA,CAAAC,KAAA,EAAW;IAAA,IAAV;MAAEJ;IAAK,CAAC,GAAAI,KAAA;IACR,OAAOpB,SAAS,CAACgB,IAAI,CAACN,CAAC,CAAC;EAC1B,CAAC;EAEDW,CAACA,CAAAC,KAAA,EAAW;IAAA,IAAV;MAAEN;IAAK,CAAC,GAAAM,KAAA;IACR,OAAOtB,SAAS,CAACgB,IAAI,CAACJ,CAAC,CAAC;EAC1B,CAAC;EAEDW,EAAEA,CAAAC,KAAA,EAAc;IAAA,IAAb;MAAEd,CAAC;MAAEF,CAAC;MAAEI;IAAE,CAAC,GAAAY,KAAA;IACZ,OAAOjE,CAAC,IAAI9B,OAAO,CAACiF,CAAC,EAAEF,CAAC,EAAEI,CAAC,CAAC;EAC9B,CAAC;EAEDa,EAAEA,CAAAC,KAAA,EAAc;IAAA,IAAb;MAAEhB,CAAC;MAAEM;IAAK,CAAC,GAAAU,KAAA;IACZ,OAAOlE,CAAC,IAAI;MACVA,CAAC,GAAGmE,MAAM,CAACnE,CAAC,CAAC,IAAI,CAAC;MAClB,OAAOkD,CAAC,GAAG,EAAE,GAAGlD,CAAC,GAAGwD,IAAI,CAACN,CAAC,GAAG,CAAC;IAChC,CAAC;EACH,CAAC;EAEDkB,EAAEA,CAAAC,KAAA,EAAc;IAAA,IAAb;MAAErB,CAAC;MAAEQ;IAAK,CAAC,GAAAa,KAAA;IACZ,OAAOrE,CAAC,IAAI;MACVA,CAAC,GAAGmE,MAAM,CAACnE,CAAC,CAAC,IAAI,CAAC;MAClB,OAAOgD,CAAC,GAAG,EAAE,GAAGhD,CAAC,GAAGwD,IAAI,CAACR,CAAC,GAAG,CAAC;IAChC,CAAC;EACH,CAAC;EAEDhD,CAACA,CAAAsE,MAAA,EAAY;IAAA,IAAX;MAAEC;IAAM,CAAC,GAAAD,MAAA;IACT,IAAIE,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,OAAOC,SAAS,GAAGhC,SAAS,CAACgC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;EACnD,CAAC;EAEDC,EAAEA,CAAAC,MAAA,EAAY;IAAA,IAAX;MAAEH;IAAM,CAAC,GAAAG,MAAA;IACV,IAAIF,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,OAAOC,SAAS,GAAGhC,SAAS,CAACgC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK;EACpD,CAAC;EAEDG,EAAEA,CAAAC,MAAA,EAAY;IAAA,IAAX;MAAEL;IAAM,CAAC,GAAAK,MAAA;IACV,IAAIJ,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,OAAOC,SAAS,GAAGhC,SAAS,CAACgC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK;EACpD,CAAC;EAEDK,CAACA,CAAAC,MAAA,EAAY;IAAA,IAAX;MAAEP;IAAM,CAAC,GAAAO,MAAA;IACT,IAAIN,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,OAAOC,SAAS,GAAGhC,SAAS,CAACgC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;EACnD,CAAC;EAEDO,CAAC,EAAElF,aAAa,CAAC,GAAG,CAAC;EAErBmF,CAAC,EAAEnF,aAAa,CAAC,GAAG,CAAC;EAErBoF,CAAC,EAAEpF,aAAa,CAAC,EAAE,CAAC;EAEpBqF,CAACA,CAAAC,MAAA,EAAoB;IAAA,IAAnB;MAAE/D,OAAO;MAAEgE;IAAK,CAAC,GAAAD,MAAA;IACjB,OAAOlG,MAAM,CAAC,YAAa;MAAA,SAAAoG,KAAA,GAAAnF,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAgF,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJxE,IAAI,CAAAwE,KAAA,IAAApF,SAAA,CAAAoF,KAAA;MAAA;MACpB,IAAI,CAACxE,IAAI,CAACX,MAAM,EAAE;QAChBW,IAAI,GAAGM,OAAO,CAACmE,cAAc,IAAI,EAAE;MACrC;MACA,IAAIC,MAAM,GAAGJ,IAAI,CAACtE,IAAI,CAAC;MACvBM,OAAO,CAACmE,cAAc,GAAGzE,IAAI;MAC7B,OAAOK,UAAU,CAACC,OAAO,EAAE,WAAW,EAAEoE,MAAM,CAAC;IACjD,CAAC,CAAC;EACJ,CAAC;EAEDC,CAACA,CAAAC,MAAA,EAA8B;IAAA,IAA7B;MAAEtE,OAAO;MAAEgE,IAAI;MAAEO;IAAS,CAAC,GAAAD,MAAA;IAC3B,IAAIE,OAAO,GAAG,WAAW,GAAGD,QAAQ;IACpC,OAAO1G,MAAM,CAAC,YAAa;MAAA,SAAA4G,KAAA,GAAA3F,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAwF,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJhF,IAAI,CAAAgF,KAAA,IAAA5F,SAAA,CAAA4F,KAAA;MAAA;MACpB,IAAIC,MAAM,GAAG,IAAI;MACjB,IAAI,CAACjF,IAAI,CAACX,MAAM,EAAE;QAChBW,IAAI,GAAGM,OAAO,CAACmE,cAAc,IAAI,EAAE;QACnCQ,MAAM,GAAG,KAAK;MAChB;MACA,IAAIC,KAAK,GAAG5E,OAAO,CAAC6E,SAAS;MAC7B,IAAInH,IAAI,GAAGkH,KAAK,GAAGA,KAAK,CAAClH,IAAI,CAAC,CAAC,CAAC,GAAG,EAAE;MACrC,IAAIiH,MAAM,EAAE;QACV,IAAI,CAAC3E,OAAO,CAACwE,OAAO,CAAC,EAAE;UACrBxE,OAAO,CAACwE,OAAO,CAAC,GAAG,CAAC,CAAC;QACvB;QACA9G,IAAI,GAAGsC,OAAO,CAACwE,OAAO,CAAC,CAACK,SAAS;MACnC;MACA,IAAInF,IAAI,CAACX,MAAM,GAAG,CAAC,EAAE;QACnB,IAAI2C,CAAC,GAAGhC,IAAI,CAACoF,SAAS,CAAClG,CAAC,IAAIA,CAAC,KAAKlB,IAAI,CAAC;QACvC,IAAIgE,CAAC,KAAK,CAAC,CAAC,EAAE;UACZhC,IAAI,CAACqF,MAAM,CAACrD,CAAC,EAAE,CAAC,CAAC;QACnB;MACF;MACA,IAAI0C,MAAM,GAAGJ,IAAI,CAACtE,IAAI,CAAC;MACvBM,OAAO,CAACmE,cAAc,GAAGzE,IAAI;MAC7B,IAAIiF,MAAM,EAAE;QACV3E,OAAO,CAACwE,OAAO,CAAC,CAACK,SAAS,GAAGT,MAAM;MACrC;MACA,OAAOrE,UAAU,CAACC,OAAO,EAAE,WAAW,EAAEoE,MAAM,CAAC;IACjD,CAAC,CAAC;EACJ,CAAC;EAEDY,EAAEA,CAAAC,MAAA,EAA+B;IAAA,IAA9B;MAAEjF,OAAO;MAAEmD,KAAK;MAAEoB;IAAS,CAAC,GAAAU,MAAA;IAC7B,IAAI7B,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,IAAI+B,GAAG,GAAG9B,SAAS,GAAG1F,IAAI,CAAC0F,SAAS,CAAC,GAAG,EAAE;IAC1C,IAAIoB,OAAO,GAAG,YAAY,GAAGD,QAAQ,GAAGW,GAAG;IAC3C,OAAOrH,MAAM,CAAC,YAAa;MACzB,IAAI,CAACmC,OAAO,CAACwE,OAAO,CAAC,EAAExE,OAAO,CAACwE,OAAO,CAAC,GAAG,CAAC;MAC3CxE,OAAO,CAACwE,OAAO,CAAC,IAAI,CAAC;MACrB,IAAIhE,GAAG,GAAG1B,SAAA,CAAKC,MAAM;MACrB,IAAIoG,GAAG,GAAG/B,SAAS,IAAIA,SAAS,CAAC,CAAC,CAAC;MACnC,IAAIrG,MAAM,CAACoI,GAAG,CAAC,EAAEA,GAAG,GAAGnF,OAAO,CAACwE,OAAO,CAAC;MACvC,IAAIY,GAAG,GAAG,CAACD,GAAG,GAAG,CAAC,IAAI3E,GAAG;MACzB,IAAIN,KAAK,GAAQkF,GAAG,QAAAtG,SAAA,CAAAC,MAAA,IAAHqG,GAAG,GAAA1E,SAAA,GAAA5B,SAAA,CAAHsG,GAAG,CAAC;MACrB,OAAOrF,UAAU,CAACC,OAAO,EAAE,WAAW,EAAEE,KAAK,CAAC;IAChD,CAAC,CAAC;EACJ,CAAC;EAEDmF,EAAEA,CAAAC,MAAA,EAA+B;IAAA,IAA9B;MAAEtF,OAAO;MAAEmD,KAAK;MAAEoB;IAAS,CAAC,GAAAe,MAAA;IAC7B,IAAIlC,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,IAAI+B,GAAG,GAAG9B,SAAS,GAAG1F,IAAI,CAAC0F,SAAS,CAAC,GAAG,EAAE;IAC1C,IAAIoB,OAAO,GAAG,YAAY,GAAGD,QAAQ,GAAGW,GAAG;IAC3C,OAAOrH,MAAM,CAAC,YAAa;MACzB,IAAI,CAACmC,OAAO,CAACwE,OAAO,CAAC,EAAExE,OAAO,CAACwE,OAAO,CAAC,GAAG,CAAC;MAC3CxE,OAAO,CAACwE,OAAO,CAAC,IAAI,CAAC;MACrB,IAAIhE,GAAG,GAAG1B,SAAA,CAAKC,MAAM;MACrB,IAAIoG,GAAG,GAAG/B,SAAS,IAAIA,SAAS,CAAC,CAAC,CAAC;MACnC,IAAIrG,MAAM,CAACoI,GAAG,CAAC,EAAEA,GAAG,GAAGnF,OAAO,CAACwE,OAAO,CAAC;MACvC,IAAIY,GAAG,GAAG,CAACD,GAAG,GAAG,CAAC,IAAI3E,GAAG;MACzB,IAAIN,KAAK,GAAQM,GAAG,GAAG4E,GAAG,GAAG,CAAC,QAAAtG,SAAA,CAAAC,MAAA,IAAbyB,GAAG,GAAG4E,GAAG,GAAG,CAAC,GAAA1E,SAAA,GAAA5B,SAAA,CAAb0B,GAAG,GAAG4E,GAAG,GAAG,CAAC,CAAC;MAC/B,OAAOrF,UAAU,CAACC,OAAO,EAAE,WAAW,EAAEE,KAAK,CAAC;IAChD,CAAC,CAAC;EACJ,CAAC;EAEDqF,EAAEA,CAAAC,MAAA,EAAwC;IAAA,IAAvC;MAAExF,OAAO;MAAEmD,KAAK;MAAEoB,QAAQ;MAAEkB;IAAQ,CAAC,GAAAD,MAAA;IACtC,IAAIpC,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,IAAI+B,GAAG,GAAG9B,SAAS,GAAG1F,IAAI,CAAC0F,SAAS,CAAC,GAAG,EAAE;IAC1C,IAAIoB,OAAO,GAAG,YAAY,GAAGD,QAAQ,GAAIW,GAAG;IAC5C,IAAIQ,MAAM,GAAG,WAAW,GAAGnB,QAAQ,GAAGW,GAAG;IAAC;IAC1C,OAAOrH,MAAM,CAAC,YAAa;MACzB,IAAI,CAACmC,OAAO,CAACwE,OAAO,CAAC,EAAExE,OAAO,CAACwE,OAAO,CAAC,GAAG,CAAC;MAC3CxE,OAAO,CAACwE,OAAO,CAAC,IAAI,CAAC;MAAC,SAAAmB,KAAA,GAAA7G,SAAA,CAAAC,MAAA,EAFNW,IAAI,OAAAT,KAAA,CAAA0G,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJlG,IAAI,CAAAkG,KAAA,IAAA9G,SAAA,CAAA8G,KAAA;MAAA;MAGpB,IAAI,CAAC5F,OAAO,CAAC0F,MAAM,CAAC,EAAE;QACpB1F,OAAO,CAAC0F,MAAM,CAAC,GAAGD,OAAO,CAAC/F,IAAI,IAAI,EAAE,CAAC;MACvC;MACA,IAAIc,GAAG,GAAGd,IAAI,CAACX,MAAM;MACrB,IAAIoG,GAAG,GAAG/B,SAAS,IAAIA,SAAS,CAAC,CAAC,CAAC;MACnC,IAAIrG,MAAM,CAACoI,GAAG,CAAC,EAAEA,GAAG,GAAGnF,OAAO,CAACwE,OAAO,CAAC;MACvC,IAAIY,GAAG,GAAG,CAACD,GAAG,GAAG,CAAC,IAAI3E,GAAG;MACzB,IAAIN,KAAK,GAAGF,OAAO,CAAC0F,MAAM,CAAC,CAACN,GAAG,CAAC;MAChC,OAAOrF,UAAU,CAACC,OAAO,EAAE,WAAW,EAAEE,KAAK,CAAC;IAChD,CAAC,CAAC;EACJ,CAAC;EAED2F,EAAEA,CAAAC,MAAA,EAAc;IAAA,IAAb;MAAE9F;IAAQ,CAAC,GAAA8F,MAAA;IACZ,OAAO,YAAW;MAAA,IAAVlH,CAAC,GAAAE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA4B,SAAA,GAAA5B,SAAA,MAAG,CAAC;MACX,IAAI8F,KAAK,GAAG5E,OAAO,CAAC6E,SAAS;MAC7B,OAAOD,KAAK,GAAGA,KAAK,CAAClH,IAAI,CAACkB,CAAC,CAAC,GAAG,EAAE;IACnC,CAAC;EACH,CAAC;EAEDmH,CAACA,CAAAC,MAAA,EAAoB;IAAA,IAAnB;MAAEhG,OAAO;MAAEiG;IAAK,CAAC,GAAAD,MAAA;IACjB,OAAO,YAAa;MAAA,SAAAE,KAAA,GAAApH,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAiH,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJzG,IAAI,CAAAyG,KAAA,IAAArH,SAAA,CAAAqH,KAAA;MAAA;MACb,IAAIC,SAAS,GAAG1G,IAAI,CAAC2G,KAAK,CAACvJ,SAAS,CAAC,GACjCW,WAAW,GACXD,OAAO;MACX,IAAI0C,KAAK,GAAGkG,SAAS,CAACH,IAAI,CAAC,CAAC,GAAGvG,IAAI,CAAC;MACpC,OAAOK,UAAU,CAACC,OAAO,EAAE,WAAW,EAAEE,KAAK,CAAC;IAChD,CAAC;EACH,CAAC;EAEDoG,EAAEA,CAAAC,MAAA,EAAmD;IAAA,IAAlD;MAAEzE,CAAC;MAAEF,CAAC;MAAE5B,OAAO;MAAEuE,QAAQ;MAAEnC,IAAI;MAAEe,KAAK;MAAE3D;IAAO,CAAC,GAAA+G,MAAA;IACjD,IAAI/B,OAAO,GAAG,UAAU,GAAGD,QAAQ;IACnC,IAAIiC,QAAQ,GAAGhC,OAAO,GAAG,UAAU;IACnC,IAAIiC,QAAQ,GAAGjC,OAAO,GAAG,UAAU;IACnC,IAAI,CAACkC,EAAE,EAAErD,EAAE,EAAEE,EAAE,EAAEoD,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGnJ,IAAI,CAACyF,KAAK,CAAC,IAAI,EAAE;IAChD,IAAI2D,YAAY,GAAIJ,EAAE,IAAIC,EAAG;IAC7B,OAAO,YAAa;MAAA,SAAAI,KAAA,GAAAjI,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAA8H,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJtH,IAAI,CAAAsH,KAAA,IAAAlI,SAAA,CAAAkI,KAAA;MAAA;MACb,IAAI;QAACC,IAAI,GAAG,CAAC;QAAEC,EAAE,GAAGD,IAAI;QAAEE,SAAS,GAAG,CAAC;QAAEC,KAAK,GAAG,CAAC;QAAEC,MAAM,GAAG;MAAC,CAAC,GAAGrJ,mBAAmB,CAAC0B,IAAI,EAAE,CAC1F,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,OAAO,EAAE,QAAQ,CAC7C,CAAC;MAEFyH,SAAS,GAAG9J,KAAK,CAAC8J,SAAS,EAAE,CAAC,EAAEG,QAAQ,CAAC;MACzCF,KAAK,GAAG/J,KAAK,CAAC+J,KAAK,EAAE,CAAC,EAAEE,QAAQ,CAAC;MACjCD,MAAM,GAAGhK,KAAK,CAACgK,MAAM,EAAE,CAAC,EAAE,GAAG,CAAC;MAE9B,IAAI3H,IAAI,CAACX,MAAM,IAAI,CAAC,EAAE,CAACkI,IAAI,EAAEC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAED,IAAI,CAAC;MAC5C,IAAI,CAACjH,OAAO,CAACwE,OAAO,CAAC,EAAExE,OAAO,CAACwE,OAAO,CAAC,GAAG,IAAIzG,KAAK,CAAC,CAAC;MACrD,IAAI,CAACiC,OAAO,CAACwG,QAAQ,CAAC,EAAExG,OAAO,CAACwG,QAAQ,CAAC,GAAGhH,MAAM,CAAC,CAAC;MACpD,IAAI,CAACQ,OAAO,CAACyG,QAAQ,CAAC,EAAEzG,OAAO,CAACyG,QAAQ,CAAC,GAAGjH,MAAM,CAAC,CAAC;MAEpD,IAAI4G,SAAS,GAAItJ,SAAS,CAACmK,IAAI,CAAC,IAAInK,SAAS,CAACoK,EAAE,CAAC,GAAIzJ,WAAW,GAAGD,OAAO;MAC1E,IAAI+J,OAAO,GAAGvH,OAAO,CAACwE,OAAO,CAAC;MAC9B,IAAIgD,OAAO,GAAGxH,OAAO,CAACwG,QAAQ,CAAC;MAC/B,IAAIiB,OAAO,GAAGzH,OAAO,CAACyG,QAAQ,CAAC;MAC/B,IAAIiB,EAAE,GAAG,CAACZ,YAAY,GAAI,CAACzD,EAAE,GAAG,CAAC,IAAIuD,EAAE,GAAK,CAAC9E,CAAC,GAAG,CAAC,IAAIM,IAAI,CAACN,CAAE,IAAI0F,OAAO;MACxE,IAAIG,EAAE,GAAG,CAACb,YAAY,GAAI,CAACvD,EAAE,GAAG,CAAC,IAAIsD,EAAE,GAAK,CAACjF,CAAC,GAAG,CAAC,IAAIQ,IAAI,CAACR,CAAE,IAAI6F,OAAO;;MAExE;MACA,IAAIb,EAAE,IAAI,CAAC,IAAIxE,IAAI,CAACN,CAAC,IAAI,CAAC,EAAE4F,EAAE,GAAG,CAAC;MAClC,IAAIb,EAAE,IAAI,CAAC,IAAIzE,IAAI,CAACR,CAAC,IAAI,CAAC,EAAE+F,EAAE,GAAG,CAAC;;MAElC;MACA,IAAID,EAAE,IAAI,CAAC,IAAIC,EAAE,IAAI,CAAC,EAAE;QACtBD,EAAE,GAAGF,OAAO;QACZG,EAAE,GAAGF,OAAO;MACd;MAEA,IAAIG,CAAC,GAAGL,OAAO,CAACM,KAAK,CAACH,EAAE,GAAGP,SAAS,EAAEQ,EAAE,GAAGR,SAAS,EAAE,CAAC,CAAC,GAAGC,KAAK;MAEhE,KAAK,IAAI1F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2F,MAAM,EAAE,EAAE3F,CAAC,EAAE;QAC/B,IAAIoG,EAAE,GAAGpG,CAAC,GAAG,CAAC;QACdkG,CAAC,IAAIL,OAAO,CAACM,KAAK,CAACH,EAAE,GAAGP,SAAS,GAAGW,EAAE,EAAEH,EAAE,GAAGR,SAAS,GAAGW,EAAE,EAAE,CAAC,CAAC,IAAIV,KAAK,GAAGU,EAAE,CAAC;MAChF;MACA,IAAIC,EAAE,GAAG3B,SAAS,CAAC,CAACa,IAAI,EAAEC,EAAE,KAAK5G,KAAK,CAACsH,CAAC,EAAEX,IAAI,EAAEC,EAAE,EAAEE,KAAK,CAAC,CAAC;MAC3D,OAAOrH,UAAU,CAACC,OAAO,EAAE,WAAW,EAAE+H,EAAE,CAACd,IAAI,EAAEC,EAAE,CAAC,CAAC;IACvD,CAAC;EACH,CAAC;EAEDc,EAAEA,CAAAC,MAAA,EAAc;IAAA,IAAb;MAAEjI;IAAQ,CAAC,GAAAiI,MAAA;IACZ,OAAO,YAAW;MAAA,IAAVrJ,CAAC,GAAAE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA4B,SAAA,GAAA5B,SAAA,MAAG,CAAC;MACX,IAAI8F,KAAK,GAAG5E,OAAO,CAACkI,SAAS;MAC7B,OAAOtD,KAAK,GAAGA,KAAK,CAAClH,IAAI,CAACkB,CAAC,CAAC,GAAG,EAAE;IACnC,CAAC;EACH,CAAC;EAEDuJ,MAAMA,CAAA,EAAG;IACP,OAAO,YAAc;MAAA,SAAAC,KAAA,GAAAtJ,SAAA,CAAAC,MAAA,EAAVsJ,KAAK,OAAApJ,KAAA,CAAAmJ,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;QAALD,KAAK,CAAAC,KAAA,IAAAxJ,SAAA,CAAAwJ,KAAA;MAAA;MACd,IAAIC,MAAM,GAAGF,KAAK,CAACzI,GAAG,CAACrC,SAAS,CAAC;MACjC,IAAIiD,GAAG,GAAG+H,MAAM,CAACxJ,MAAM;MACvB,IAAIyJ,aAAa,GAAG,CAAC;MACrB,IAAIC,YAAY,GAAG,EAAE;MACrB,IAAIC,IAAI;MACR,IAAI,CAAClI,GAAG,EAAE;QACR,OAAO,EAAE;MACX;MACA+H,MAAM,CAACI,OAAO,CAACC,IAAI,IAAI;QACrB,IAAI,CAACjK,CAAC,EAAEkK,IAAI,CAAC,GAAG1K,iBAAiB,CAACyK,IAAI,CAAC;QACvC,IAAIC,IAAI,KAAKnI,SAAS,EAAE+H,YAAY,CAACtI,IAAI,CAAC0I,IAAI,CAAC,CAAC,KAC3CL,aAAa,IAAI,CAAC;MACzB,CAAC,CAAC;MACF,IAAIM,YAAY,GAAGL,YAAY,CAAC1J,MAAM,cAAAgK,MAAA,CACvBN,YAAY,CAAC3I,IAAI,CAAC,KAAK,CAAC,UAAAiJ,MAAA,CAAOP,aAAa,cAAAO,MAAA,CAC7CvI,GAAG,CAAE;MACnB,OAAO+H,MAAM,CAAC3I,GAAG,CAAC,CAACgJ,IAAI,EAAElH,CAAC,KAAK;QAC7B,IAAI+G,YAAY,CAAC1J,MAAM,EAAE;UACvB,IAAI,CAACiK,KAAK,EAAEH,IAAI,CAAC,GAAG1K,iBAAiB,CAACyK,IAAI,CAAC;UAC3C,IAAIK,MAAM,GAAGP,IAAI,GAAIA,IAAI,GAAG,KAAK,GAAI,EAAE;UACvCA,IAAI,GAAGO,MAAM,IAAIJ,IAAI,KAAKnI,SAAS,GAAGmI,IAAI,GAAGC,YAAY,CAAC;UAC1D,UAAAC,MAAA,CAAUC,KAAK,cAAAD,MAAA,CAAYL,IAAI;QACjC;QACA,UAAAK,MAAA,CAAUH,IAAI,SAAAG,MAAA,CAAM,GAAG,GAAGvI,GAAG,IAAIkB,CAAC,GAAG,CAAC,CAAC;MACzC,CAAC,CAAC,CACD5B,IAAI,CAAC,GAAG,CAAC;IACZ,CAAC;EACH,CAAC;EAEDnC,IAAIA,CAAA,EAAG;IACL,OAAO,CAACuC,KAAK,EAAEF,OAAO,KAAK;MACzB,OAAOrC,IAAI,CAACJ,SAAS,CAAC2C,KAAK,CAAC,EAAEF,OAAO,CAAC;IACxC,CAAC;EACH,CAAC;EAEDkJ,GAAGA,CAAA,EAAG;IACJ,OAAOhJ,KAAK,IAAIiJ,QAAQ,CAAC5L,SAAS,CAAC2C,KAAK,CAAC,CAAC,CAACkJ,QAAQ,CAAC,EAAE,CAAC;EACzD,CAAC;EAEDC,GAAG,EAAEjM,IAAI,CAAC,UAACuB,CAAC,EAAc;IAAA,SAAA2K,KAAA,GAAAxK,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAqK,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJ7J,IAAI,CAAA6J,KAAA,QAAAzK,SAAA,CAAAyK,KAAA;IAAA;IACnB,IAAIrJ,KAAK,GAAGR,IAAI,CAACE,GAAG,CAACyI,KAAK,IAAI9K,SAAS,CAAC8K,KAAK,CAAC,CAAC,CAAC,CAAC,CAACvI,IAAI,CAAC,GAAG,CAAC;IAC3D,IAAI,CAACI,KAAK,CAACsJ,UAAU,CAAC,GAAG,CAAC,EAAE;MAC1B,IAAIC,MAAM,GAAGpL,SAAS,CAAC6B,KAAK,CAAC;MAC7BA,KAAK,GAAGtD,YAAY,CAAC6M,MAAM,CAAC;IAC9B;IACA,IAAIJ,GAAG,GAAG1M,aAAa,CAACuD,KAAK,CAAC;IAC9B,OAAOxD,cAAc,CAAC2M,GAAG,CAAC;EAC5B,CAAC,CAAC;EAEF,YAAY,EAAEjM,IAAI,CAAC,UAACsM,QAAQ,EAAc;IAAA,SAAAC,KAAA,GAAA7K,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAA0K,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJlK,IAAI,CAAAkK,KAAA,QAAA9K,SAAA,CAAA8K,KAAA;IAAA;IACnC,IAAIlE,MAAM,GAAGhG,IAAI,CAACE,GAAG,CAACyI,KAAK,IAAI9K,SAAS,CAAC8K,KAAK,CAAC,CAAC,CAAC,CAAC;IAClD,IAAInI,KAAK,GAAGwF,MAAM,CAAC5F,IAAI,CAAC,GAAG,CAAC;IAC5B,IAAI6C,EAAE,GAAGzF,SAAS,CAAC,SAAS,CAAC;IAC7B;IACA,IAAIwI,MAAM,CAACW,KAAK,CAACzH,CAAC,IAAI,UAAU,CAACS,IAAI,CAACT,CAAC,CAAC,IAAK,QAAQ,CAACS,IAAI,CAACT,CAAC,CAAC,IAAI,CAAC,QAAQ,CAACS,IAAI,CAACT,CAAC,CAAE,CAAC,EAAE;MACpF,IAAI;QAAEuI,SAAS;QAAEC,KAAK;QAAEC,MAAM;QAAEwC,IAAI,GAAGH,QAAQ,CAACG,IAAI;QAAEC,IAAI;QAAEC,KAAK;QAAEC;MAAO,CAAC,GAAGhM,mBAAmB,CAAC0H,MAAM,EAAE,CACxG,WAAW,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,CAClE,CAAC;MACFxF,KAAK,8FAKJ;MACD,IAAI,CAACnD,MAAM,CAACiN,MAAM,CAAC,EAAE;QACnB9J,KAAK,sFAAA6I,MAAA,CAGSiB,MAAM,6BAEnB;MACH;MACA,IAAI,CAACjN,MAAM,CAACgN,KAAK,CAAC,EAAE;QAClB7J,KAAK,qFAAA6I,MAAA,CAGSgB,KAAK,6BAElB;MACH;MACA,IAAI,CAAChN,MAAM,CAAC+M,IAAI,CAAC,EAAE;QACjB5J,KAAK,+DAAA6I,MAAA,CAEee,IAAI,6BAEvB;MACH;MACA,IAAI,CAAC/M,MAAM,CAACoK,SAAS,CAAC,EAAE;QACtB,IAAI,CAAC8C,EAAE,EAAEC,EAAE,GAAGD,EAAE,CAAC,GAAG9L,iBAAiB,CAACgJ,SAAS,CAAC;QAChDE,MAAM,GAAGA,MAAM,kBAAA0B,MAAA,CAAkB1B,MAAM,SAAM,EAAE;QAC/CnH,KAAK,+FAAA6I,MAAA,CAGgBkB,EAAE,OAAAlB,MAAA,CAAImB,EAAE,2BAAAnB,MAAA,CACjBc,IAAI,qBAAAd,MAAA,CACV1B,MAAM,4BAEX;QACD,IAAID,KAAK,EAAE;UACTlH,KAAK,iGAAA6I,MAAA,CAGQ3B,KAAK,iCAEjB;QACH;MACF;IACF;IACA;IACA,IAAI,CAAClH,KAAK,CAACsJ,UAAU,CAAC,GAAG,CAAC,EAAE;MAC1B,IAAIC,MAAM,GAAGpL,SAAS,CAAC6B,KAAK,EAAE;QAC5BiK,IAAI,EAAE,OAAO;QACblK,IAAI,EAAE;MACR,CAAC,CAAC;MACFC,KAAK,GAAGtD,YAAY,CAAC6M,MAAM,CAAC;IAC9B;IACA,IAAIJ,GAAG,GAAG1M,aAAa,CAACuD,KAAK,CAAC,CAACkK,OAAO,CACpC,gBAAgB,kBAAArB,MAAA,CACApG,EAAE,SACpB,CAAC;IACD,OAAOjG,cAAc,CAAC2M,GAAG,EAAE1G,EAAE,CAAC;EAChC,CAAC,CAAC;EAEF,aAAa,EAAEvF,IAAI,CAAC,UAACuB,CAAC,EAAc;IAAA,SAAA0L,KAAA,GAAAvL,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAoL,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJ5K,IAAI,CAAA4K,KAAA,QAAAxL,SAAA,CAAAwL,KAAA;IAAA;IAC7B,IAAIpK,KAAK,GAAGR,IAAI,CAACE,GAAG,CAACyI,KAAK,IAAI9K,SAAS,CAAC8K,KAAK,CAAC,CAAC,CAAC,CAAC,CAACvI,IAAI,CAAC,GAAG,CAAC;IAC3D,IAAI2J,MAAM,GAAGpL,SAAS,oJAAA0K,MAAA,CAKM7I,KAAK,sBAEhC,CAAC;IACF,IAAImJ,GAAG,GAAGzM,YAAY,CAAC6M,MAAM,CAAC;IAC9B,OAAO/M,cAAc,CAAC2M,GAAG,CAAC;EAC5B,CAAC,CAAC;EAEF,aAAa,EAAEjM,IAAI,CAAC,UAACuB,CAAC,EAAc;IAAA,IAAA4L,YAAA,EAAAC,oBAAA,EAAAC,OAAA,EAAAC,eAAA,EAAAC,KAAA,EAAAC,aAAA;IAAA,SAAAC,MAAA,GAAA/L,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAA4L,MAAA,OAAAA,MAAA,WAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;MAAJpL,IAAI,CAAAoL,MAAA,QAAAhM,SAAA,CAAAgM,MAAA;IAAA;IAC7B,IAAI5K,KAAK,GAAGR,IAAI,CAACE,GAAG,CAACyI,KAAK,IAAI9K,SAAS,CAAC8K,KAAK,CAAC,CAAC,CAAC,CAAC,CAACvI,IAAI,CAAC,GAAG,CAAC;IAC3D,IAAIiL,MAAM,GAAG3M,oBAAoB,CAAC8B,KAAK,CAAC;IAExC,OAAO6K,MAAM,CAACC,KAAK;IACnBD,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM;IACvB,CAAAP,oBAAA,GAAAO,MAAM,CAAAR,YAAA,GAAC,cAAc,CAAC,cAAAC,oBAAA,cAAAA,oBAAA,GAAtBO,MAAM,CAAAR,YAAA,CAAgB,GAAK,GAAG;IAC9B,CAAAG,eAAA,GAAAK,MAAM,CAAAN,OAAA,GAAC,QAAQ,CAAC,cAAAC,eAAA,cAAAA,eAAA,GAAhBK,MAAM,CAAAN,OAAA,CAAU,GAAK,cAAc;IACnC,CAAAG,aAAA,GAAAG,MAAM,CAAAJ,KAAA,GAAC,MAAM,CAAC,cAAAC,aAAA,cAAAA,aAAA,GAAdG,MAAM,CAAAJ,KAAA,CAAQ,GAAK,MAAM;IAEzB,IAAIM,MAAM,cAAAlC,MAAA,CAAc7K,mBAAmB,CAAC6M,MAAM,EAAE;MAACxK,GAAG,EAAE,CAAC;MAAEC,GAAG,EAAE;IAAK,CAAC,CAAC,MAAG;IAC5E,IAAI0K,KAAK,GAAG,EAAE;IACd,KAAK,IAAIjL,IAAI,IAAIkL,MAAM,CAACC,IAAI,CAACL,MAAM,CAAC,EAAE;MACpC,IAAI,8CAA8C,CAAC1L,IAAI,CAACY,IAAI,CAAC,EAAE;QAC7DiL,KAAK,OAAAnC,MAAA,CAAO9I,IAAI,QAAA8I,MAAA,CAAKgC,MAAM,CAAC9K,IAAI,CAAC,MAAG;MACtC;IACF;IAAC;IACD,IAAIwJ,MAAM,GAAGpL,SAAS,iCAAA0K,MAAA,CACGhG,MAAM,CAACgI,MAAM,CAAC,cAAc,CAAC,CAAC,GAAC,CAAC,kCAAAhC,MAAA,CAEnDmC,KAAK,OAAAnC,MAAA,CAAIkC,MAAM,oBAEpB,CAAC;IACF,OAAOvO,cAAc,CAACE,YAAY,CAAC6M,MAAM,CAAC,CAAC;EAC7C,CAAC,CAAC;EAEF4B,GAAGA,CAAA,EAAG;IACJ,OAAOnL,KAAK,WAAA6I,MAAA,CAAYxL,SAAS,CAAC2C,KAAK,CAAC,MAAI;EAC9C,CAAC;EAEDoL,EAAEA,CAAA,EAAG;IACH,OAAOpL,KAAK,aAAA6I,MAAA,CAAcvK,QAAQ,CAAC+M,YAAY,CAACtL,IAAI,MAAI;EAC1D,CAAC;EAEDuL,EAAEA,CAAA,EAAG;IACH,OAAOtL,KAAK,aAAA6I,MAAA,CAAcvK,QAAQ,CAACiN,aAAa,CAACxL,IAAI,MAAI;EAC3D,CAAC;EAEDyL,EAAEA,CAAA,EAAG;IACH,OAAOxL,KAAK,aAAA6I,MAAA,CAAcvK,QAAQ,CAACmN,cAAc,CAAC1L,IAAI,MAAI;EAC5D,CAAC;EAED2L,EAAEA,CAAA,EAAG;IACH,OAAO1L,KAAK,aAAA6I,MAAA,CAAcvK,QAAQ,CAACqN,cAAc,CAAC5L,IAAI,MAAI;EAC5D,CAAC;EAED6L,EAAEA,CAAA,EAAG;IACH,OAAO5L,KAAK,aAAA6I,MAAA,CAAcvK,QAAQ,CAACuN,cAAc,CAAC9L,IAAI,MAAI;EAC5D,CAAC;EAED+L,IAAIA,CAAAC,MAAA,EAA4C;IAAA,IAA3C;MAAE9M,KAAK;MAAEa,OAAO;MAAEmD,KAAK;MAAEoB,QAAQ;MAAEnC;IAAK,CAAC,GAAA6J,MAAA;IAC5C,IAAIC,GAAG,GAAG,eAAe,GAAG3H,QAAQ;IACpC,IAAInB,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,OAAOgJ,QAAQ,IAAI;MACjB,IAAI,CAAChH,GAAG,GAAGhG,KAAK,EAAER,CAAC,EAAEyN,EAAE,EAAE5L,GAAG,GAAG4B,IAAI,CAACjD,KAAK,CAAC,GAAGiE,SAAS,IAAI,EAAE;MAC5D,IAAI,CAACpD,OAAO,CAACkM,GAAG,CAAC,EAAE;QACjB,IAAInB,MAAM,GAAG3M,oBAAoB,CAAC+N,QAAQ,CAAC;QAC3C,OAAOpB,MAAM,CAAC,MAAM,CAAC;QACrB,OAAOA,MAAM,CAAC,WAAW,CAAC;QAC1B,OAAOA,MAAM,CAAC,OAAO,CAAC;QACtBA,MAAM,CAACE,MAAM,GAAGzK,GAAG;QACnBR,OAAO,CAACkM,GAAG,CAAC,GAAGhO,mBAAmB,CAAC6M,MAAM,EAAE;UAACxK,GAAG,EAAE,CAAC;UAAEC,GAAG,EAAE;QAAK,CAAC,CAAC;MAClE;MACA,OAAOR,OAAO,CAACkM,GAAG,CAAC,CAAC/G,GAAG,GAAG,CAAC,CAAC;IAC9B,CAAC;EACH,CAAC;EAEDkH,IAAIA,CAAAC,MAAA,EAA4C;IAAA,IAA3C;MAAEnN,KAAK;MAAEa,OAAO;MAAEmD,KAAK;MAAEoB,QAAQ;MAAEnC;IAAK,CAAC,GAAAkK,MAAA;IAC5C,IAAIJ,GAAG,GAAG,eAAe,GAAG3H,QAAQ;IACpC,IAAInB,SAAS,GAAG1F,IAAI,CAACyF,KAAK,CAAC;IAC3B,OAAOgJ,QAAQ,IAAI;MACjB,IAAI,CAAChH,GAAG,GAAGhG,KAAK,EAAER,CAAC,EAAEyN,EAAE,EAAE5L,GAAG,GAAG4B,IAAI,CAACjD,KAAK,CAAC,GAAGiE,SAAS,IAAI,EAAE;MAC5D,IAAI,CAACpD,OAAO,CAACkM,GAAG,CAAC,EAAE;QACjB,IAAInB,MAAM,GAAG3M,oBAAoB,CAAC+N,QAAQ,CAAC;QAC3C,OAAOpB,MAAM,CAAC,MAAM,CAAC;QACrB,OAAOA,MAAM,CAAC,WAAW,CAAC;QAC1B,OAAOA,MAAM,CAAC,OAAO,CAAC;QACtBA,MAAM,CAACE,MAAM,GAAGzK,GAAG;QACnBuK,MAAM,CAACzJ,IAAI,GAAGyJ,MAAM,CAACzJ,IAAI,IAAI,MAAM;QACnCtB,OAAO,CAACkM,GAAG,CAAC,GAAGhO,mBAAmB,CAAC6M,MAAM,EAAE;UAACxK,GAAG,EAAE,CAAC;UAAEC,GAAG,EAAE;QAAK,CAAC,CAAC;MAClE;MACA,OAAOR,OAAO,CAACkM,GAAG,CAAC,CAAC/G,GAAG,GAAG,CAAC,CAAC;IAC9B,CAAC;EACH,CAAC;EAEDoH,KAAKA,CAAA,EAAG;IACN,OAAO3O,IAAI,CAAC,gBAAgB,EAAE,YAAwB;MAAA,IAAvBuM,IAAI,GAAArL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA4B,SAAA,GAAA5B,SAAA,MAAG,EAAE;MACtCqL,IAAI,GAAGqC,MAAM,CAACrC,IAAI,CAAC,CAAC3I,IAAI,CAAC,CAAC;MAC1B,IAAIyJ,MAAM,GAAG,EAAE;MACf,IAAId,IAAI,CAACpL,MAAM,EAAE;QAAA,SAAA0N,MAAA,GAAA3N,SAAA,CAAAC,MAAA,EAH0BW,IAAI,OAAAT,KAAA,CAAAwN,MAAA,OAAAA,MAAA,WAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;UAAJhN,IAAI,CAAAgN,MAAA,QAAA5N,SAAA,CAAA4N,MAAA;QAAA;QAI7C,IAAI,OAAOzO,MAAM,CAACkM,IAAI,CAAC,KAAK,UAAU,EAAE;UACtCc,MAAM,GAAGhN,MAAM,CAACkM,IAAI,CAAC,CAACzK,IAAI,CAAC;QAC7B,CAAC,MAAM;UACL,IAAIyM,QAAQ,GAAGhC,IAAI;UACnB,IAAIwC,IAAI,GAAGjN,IAAI,CAACI,IAAI,CAAC,GAAG,CAAC;UACzB,IAAI6M,IAAI,CAAC5N,MAAM,EAAE;YACfoN,QAAQ,GAAGhC,IAAI,GAAG,GAAG,GAAGwC,IAAI;UAC9B;UACA,IAAI5B,MAAM,GAAG3M,oBAAoB,CAAC+N,QAAQ,CAAC;UAC3ClB,MAAM,GAAG/M,mBAAmB,CAAC6M,MAAM,EAAE;YAACxK,GAAG,EAAE,CAAC;YAAEC,GAAG,EAAE;UAAI,CAAC,CAAC;QAC3D;MACF;MACA,kBAAAuI,MAAA,CAAkBkC,MAAM,CAACnL,IAAI,CAAC,GAAG,CAAC;IACpC,CAAC,CAAC;EACJ,CAAC;EAED8M,MAAMA,CAAA,EAAG;IACP,OAAO1M,KAAK,IAAIA,KAAK;EACvB,CAAC;EAED2M,OAAOA,CAAA,EAAG;IACR,OAAO3M,KAAK,IAAIA,KAAK;EACvB,CAAC;EAED4M,MAAMA,CAAA,EAAG;IACP,OAAO5M,KAAK,IAAIA,KAAK;EACvB,CAAC;EAED6M,OAAOA,CAAA,EAAG;IACR,OAAO7M,KAAK,IAAIA,KAAK;EACvB,CAAC;EAED8M,MAAMA,CAAA,EAAG;IACP,OAAOb,QAAQ,IAAI;MACjB,IAAI1C,MAAM,GAAGnL,cAAc,CAAC6N,QAAQ,CAAC;MACrC,IAAI,CAAC1C,MAAM,CAACwD,KAAK,EAAE,OAAOd,QAAQ;MAClC,OAAO1C,MAAM,CAAC0C,QAAQ,CAACvM,GAAG,CAACsN,MAAA,IAAqB;QAAA,IAApB;UAAEjN,IAAI;UAAEC;QAAM,CAAC,GAAAgN,MAAA;QACzC,QAAQjN,IAAI;UACV,KAAK,GAAG;YAAE,OAAO,GAAG,GAAGC,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;UACtC,KAAK,GAAG;YAAE,OAAO,GAAG,GAAGI,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;UACtC,KAAK,GAAG;YAAE,OAAO,GAAG,GAAGI,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;UACtC,KAAK,GAAG;YAAE,OAAO,GAAG,GAAGI,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;UACtC;YAAU,OAAOG,IAAI,GAAGC,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;QACzC;MACF,CAAC,CAAC,CAACA,IAAI,CAAC,GAAG,CAAC;IACd,CAAC;EACH,CAAC;EAEDqN,KAAKA,CAAA,EAAG;IACN,OAAOhB,QAAQ,IAAI;MACjB,IAAI1C,MAAM,GAAGnL,cAAc,CAAC6N,QAAQ,CAAC;MACrC,IAAI,CAAC1C,MAAM,CAACwD,KAAK,EAAE,OAAOd,QAAQ;MAClC,OAAO1C,MAAM,CAAC0C,QAAQ,CAACvM,GAAG,CAACwN,MAAA,IAAqB;QAAA,IAApB;UAAEnN,IAAI;UAAEC;QAAM,CAAC,GAAAkN,MAAA;QACzC,QAAQnN,IAAI;UACV,KAAK,GAAG;UACR,KAAK,GAAG;YAAE,OAAOA,IAAI,GAAGC,KAAK,CAACN,GAAG,CAACQ,UAAU,CAAC,CAACN,IAAI,CAAC,GAAG,CAAC;UACvD;YAAU,OAAOG,IAAI,GAAGC,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;QACzC;MACF,CAAC,CAAC,CAACA,IAAI,CAAC,GAAG,CAAC;IACd,CAAC;EACH,CAAC;EAEDuN,KAAKA,CAAA,EAAG;IACN,OAAOlB,QAAQ,IAAI;MACjB,IAAI1C,MAAM,GAAGnL,cAAc,CAAC6N,QAAQ,CAAC;MACrC,IAAI,CAAC1C,MAAM,CAACwD,KAAK,EAAE,OAAOd,QAAQ;MAClC,OAAO1C,MAAM,CAAC0C,QAAQ,CAACvM,GAAG,CAAC0N,MAAA,IAAqB;QAAA,IAApB;UAAErN,IAAI;UAAEC;QAAM,CAAC,GAAAoN,MAAA;QACzC,QAAQrN,IAAI;UACV,KAAK,GAAG;UACR,KAAK,GAAG;YAAE,OAAOA,IAAI,GAAGC,KAAK,CAACN,GAAG,CAACQ,UAAU,CAAC,CAACN,IAAI,CAAC,GAAG,CAAC;UACvD;YAAU,OAAOG,IAAI,GAAGC,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;QACzC;MACF,CAAC,CAAC,CAACA,IAAI,CAAC,GAAG,CAAC;IACd,CAAC;EACH,CAAC;EAEDyN,IAAIA,CAAA,EAAU;IACZ,IAAIJ,KAAK,GAAG1L,MAAM,CAAC0L,KAAK,CAAC,GAAArO,SAAO,CAAC;IACjC,IAAIuO,KAAK,GAAG5L,MAAM,CAAC4L,KAAK,CAAC,GAAAvO,SAAO,CAAC;IACjC,OAAOqN,QAAQ,IAAI;MACjB,OAAOkB,KAAK,CAACF,KAAK,CAAChB,QAAQ,CAAC,CAAC;IAC/B,CAAC;EACH,CAAC;EAEDqB,OAAOA,CAAA,EAAG;IACR,OAAO,YAAa;MAAA,SAAAC,MAAA,GAAA3O,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAwO,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;QAAJhO,IAAI,CAAAgO,MAAA,IAAA5O,SAAA,CAAA4O,MAAA;MAAA;MACb,IAAIvB,QAAQ,GAAGzM,IAAI,CAACE,GAAG,CAACrC,SAAS,CAAC;MAClC,IAAIkM,MAAM,GAAGnL,cAAc,CAAC6N,QAAQ,CAACrM,IAAI,CAAC,GAAG,CAAC,CAAC;MAC/C,IAAI2J,MAAM,CAACwD,KAAK,EAAE;QAChB,IAAIU,MAAM,GAAG,EAAE;QACf,KAAK,IAAIjM,CAAC,GAAG+H,MAAM,CAAC0C,QAAQ,CAACpN,MAAM,GAAG,CAAC,EAAE2C,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;UACpD,IAAI;YAAEzB,IAAI;YAAEC;UAAM,CAAC,GAAGuJ,MAAM,CAAC0C,QAAQ,CAACzK,CAAC,CAAC;UACxCiM,MAAM,CAACxN,IAAI,CAACF,IAAI,GAAGC,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC,CAAC;QACrC;QACA,OAAO6N,MAAM,CAAC7N,IAAI,CAAC,GAAG,CAAC;MACzB;MACA,OAAOqM,QAAQ,CAACqB,OAAO,CAAC,CAAC;IAC3B,CAAC;EACH,CAAC;EAEDI,KAAKA,CAAA,EAAG;IACN,OAAO,YAAa;MAAA,SAAAC,MAAA,GAAA/O,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAA4O,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;QAAJpO,IAAI,CAAAoO,MAAA,IAAAhP,SAAA,CAAAgP,MAAA;MAAA;MACbpO,IAAI,GAAGA,IAAI,CAACE,GAAG,CAAChB,CAAC,IAAI,GAAG,GAAGA,CAAC,GAAG,GAAG,CAAC;MACnC,IAAImP,IAAI,GAAG,EAAE;MACb,IAAIC,SAAS;MACb,IAAItO,IAAI,CAACX,MAAM,IAAI,CAAC,EAAE;QACpBiP,SAAS,GAAG,GAAG;QAAC;QAChBD,IAAI,GAAG5P,iBAAiB,CAACuB,IAAI,CAAC,CAAC,CAAC,EAAE;UAAEuO,MAAM,EAAED;QAAU,CAAC,CAAC;MAC1D,CAAC,MAAM;QACLA,SAAS,GAAG,GAAG;QACfD,IAAI,GAAG5P,iBAAiB,CAACuB,IAAI,CAACE,GAAG,CAACrC,SAAS,CAAC,CAACuC,IAAI,CAACkO,SAAS,CAAC,EAAE;UAAEC,MAAM,EAAED;QAAS,CAAC,CAAC;MACrF;MACAD,IAAI,GAAGA,IAAI,CAACnO,GAAG,CAAChB,CAAC,IAAIA,CAAC,CAACwL,OAAO,CAAC,UAAU,EAAC,EAAE,CAAC,CAAC;MAC9C,IAAIvB,IAAI,GAAGkF,IAAI,CAAChP,MAAM,GAAG,CAAC;MAC1B,IAAI4O,MAAM,GAAG,CAACI,IAAI,CAACjO,IAAI,CAACkO,SAAS,CAAC,CAAC;MACnC;MACA,KAAK,IAAItM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmH,IAAI,EAAE,EAAEnH,CAAC,EAAE;QAC7B,IAAIwM,IAAI,GAAGH,IAAI,CAACI,KAAK,CAAC,CAAC;QACvBJ,IAAI,CAAC5N,IAAI,CAAC+N,IAAI,CAAC;QACfP,MAAM,CAACxN,IAAI,CAAC4N,IAAI,CAACjO,IAAI,CAACkO,SAAS,CAAC,CAAC;MACnC;MACA,OAAOL,MAAM;IACf,CAAC;EACH,CAAC;EAEDS,MAAMA,CAAA,EAAG;IACP,OAAO,YAAa;MAAA,SAAAC,MAAA,GAAAvP,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAoP,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;QAAJ5O,IAAI,CAAA4O,MAAA,IAAAxP,SAAA,CAAAwP,MAAA;MAAA;MACb,KAAK,IAAI5M,CAAC,GAAGhC,IAAI,CAACX,MAAM,GAAG,CAAC,EAAE2C,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QACzChC,IAAI,CAACS,IAAI,CAACT,IAAI,CAACgC,CAAC,CAAC,CAAC;MACpB;MACA,OAAOhC,IAAI;IACb,CAAC;EACH,CAAC;EAED6O,MAAMA,CAAA,EAAG;IACP,OAAO,YAAa;MAAA,SAAAC,MAAA,GAAA1P,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAAuP,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;QAAJ/O,IAAI,CAAA+O,MAAA,IAAA3P,SAAA,CAAA2P,MAAA;MAAA;MACb,KAAK,IAAI/M,CAAC,GAAGhC,IAAI,CAACX,MAAM,GAAG,CAAC,EAAE2C,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QACzChC,IAAI,CAACS,IAAI,CAACT,IAAI,CAACgC,CAAC,CAAC,CAAC;MACpB;MACA,OAAOhC,IAAI;IACb,CAAC;EACH,CAAC;EAEDgP,IAAIA,CAAA,EAAG;IACL,OAAO,YAAa;MAAA,SAAAC,MAAA,GAAA7P,SAAA,CAAAC,MAAA,EAATW,IAAI,OAAAT,KAAA,CAAA0P,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;QAAJlP,IAAI,CAAAkP,MAAA,IAAA9P,SAAA,CAAA8P,MAAA;MAAA;MACb,OAAOlP,IAAI,CAACE,GAAG,CAAC8O,IAAI,IAAIlC,MAAM,CAACqC,YAAY,CAACH,IAAI,CAAC,CAAC;IACpD,CAAC;EACH,CAAC;EAEDI,IAAIA,CAAAC,MAAA,EAA+B;IAAA,IAA9B;MAAE/O,OAAO;MAAEmD,KAAK;MAAEoB;IAAS,CAAC,GAAAwK,MAAA;IAC/B,IAAIvK,OAAO,GAAG,cAAc,GAAGD,QAAQ;IACvC,OAAO,YAAa;MAClB,IAAIxH,MAAM,CAACiD,OAAO,CAACwE,OAAO,CAAC,CAAC,EAAE;QAAA,SAAAwK,MAAA,GAAAlQ,SAAA,CAAAC,MAAA,EADrBW,IAAI,OAAAT,KAAA,CAAA+P,MAAA,GAAAC,MAAA,MAAAA,MAAA,GAAAD,MAAA,EAAAC,MAAA;UAAJvP,IAAI,CAAAuP,MAAA,IAAAnQ,SAAA,CAAAmQ,MAAA;QAAA;QAEXjP,OAAO,CAACwE,OAAO,CAAC,GAAG9E,IAAI;MACzB;MACA,OAAOM,OAAO,CAACwE,OAAO,CAAC;IACzB,CAAC;EACH,CAAC;EAED0K,GAAGA,CAAAC,MAAA,EAAY;IAAA,IAAX;MAAEC;IAAM,CAAC,GAAAD,MAAA;IACX,OAAO,YAAc;MAAA,IAAbD,GAAG,GAAApQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA4B,SAAA,GAAA5B,SAAA,MAAG,EAAE;MACd,IAAI;QACF,IAAIuQ,GAAG,GAAGH,GAAG,CAACI,SAAS,CAACJ,GAAG,CAACK,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEL,GAAG,CAACM,WAAW,CAAC,IAAI,CAAC,CAAC;QACpE,IAAIN,GAAG,CAAC1F,UAAU,CAAC,UAAU,CAAC,IAAI0F,GAAG,CAACO,QAAQ,CAAC,GAAG,CAAC,EAAE;UACnD,IAAIvD,GAAG,GAAGgD,GAAG,CAACI,SAAS,CAAC,CAAC,EAAEJ,GAAG,CAACnQ,MAAM,GAAG,CAAC,CAAC;UAC1C,IAAI2Q,OAAO,GAAGN,KAAK,CAACM,OAAO;UAC3B,IAAIA,OAAO,IAAIA,OAAO,CAACxD,GAAG,CAAC,EAAE;YAC3B,sBAAAnD,MAAA,CAAsB2G,OAAO,CAACxD,GAAG,CAAC,CAACU,MAAM;UAC3C;QACF;QACA,IAAIsC,GAAG,CAAC1F,UAAU,CAAC,8BAA8B,CAAC,EAAE;UAClD,OAAOmG,kBAAkB,CAACN,GAAG,CAAC;QAChC;QACA;QACA,IAAIH,GAAG,CAAC1F,UAAU,CAAC,gCAAgC,CAAC,EAAE;UACpD,OAAOoG,IAAI,CAACP,GAAG,CAAC;QAClB;QACA,IAAIH,GAAG,CAAC1F,UAAU,CAAC,4BAA4B,CAAC,EAAE;UAChD,qBAAAT,MAAA,CAAoBmG,GAAG;QACzB;MACF,CAAC,CAAC,OAAOW,CAAC,EAAE;QACV;MAAA;MAEF,OAAOX,GAAG;IACZ,CAAC;EACH;AAEF,CAAC,EAAE;EAED,OAAO,EAAE,GAAG;EACZ,KAAK,EAAE,GAAG;EACV,KAAK,EAAE,GAAG;EACV,OAAO,EAAE,GAAG;EACZ,MAAM,EAAE,GAAG;EACX,MAAM,EAAE,GAAG;EACX,IAAI,EAAI,IAAI;EACZ,KAAK,EAAG,IAAI;EAEZ;EACA,SAAS,EAAE,QAAQ;EACnB,OAAO,EAAI,QAAQ;EACnB,QAAQ,EAAG,SAAS;EACpB,OAAO,EAAE,OAAO;EAChB,OAAO,EAAE,OAAO;EAEhB;EACA,GAAG,EAAE,IAAI;EACT,QAAQ,EAAE,YAAY;EACtB,WAAW,EAAE,IAAI;EACjB,WAAW,EAAE,IAAI;EACjB,UAAU,EAAE,GAAG;EACf,OAAO,EAAE,GAAG;EACZ,KAAK,EAAE,GAAG;EACV,QAAQ,EAAE,GAAG;EACb,IAAI,EAAE,GAAG;EACT,GAAG,EAAG,GAAG;EACT,MAAM,EAAE,GAAG;EACX,IAAI,EAAE,GAAG;EACT,QAAQ,EAAE,GAAG;EACb,UAAU,EAAE,GAAG;EACf,SAAS,EAAE,GAAG;EACd,IAAI,EAAE,GAAG;EACT,QAAQ,EAAE,GAAG;EACb,UAAU,EAAE,GAAG;EACf,SAAS,EAAE,GAAG;EACd,IAAI,EAAE,GAAG;EACT,QAAQ,EAAE,GAAG;EACb,YAAY,EAAE,GAAG;EACjB,KAAK,EAAE,KAAK;EACZ,cAAc,EAAE,IAAI;EACpB,QAAQ,EAAE,IAAI;EACd,QAAQ,EAAE,IAAI;EACd,QAAQ,EAAE,MAAM;EAChB,QAAQ,EAAE,MAAM;EAChB,OAAO,EAAE,MAAM;EACf,OAAO,EAAE,MAAM;EACf,OAAO,EAAE,QAAQ;EACjB,SAAS,EAAE;AACb,CAAC,CAAC;AAEF,eAAezN,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}