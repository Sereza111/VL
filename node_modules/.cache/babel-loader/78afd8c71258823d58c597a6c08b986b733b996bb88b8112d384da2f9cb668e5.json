{"ast":null,"code":"import Func from '../function.js';\nimport Property from '../property.js';\nimport Selector from '../selector.js';\nimport parse_value_group from '../parser/parse-value-group.js';\nimport calc from '../calc.js';\nimport { uniform_time } from '../uniforms.js';\nimport { seedrandom } from '../lib/seedrandom.js';\nimport { prefixer } from '../utils/prefixer.js';\nimport { maybe, cell_id, is_nil, get_value, lerp, unique_id } from '../utils/index.js';\nimport { join, make_array, remove_empty_values } from '../utils/list.js';\nfunction is_host_selector(s) {\n  return /^\\:(host|doodle)/.test(s);\n}\nfunction is_parent_selector(s) {\n  return /^\\:(container|parent)/.test(s);\n}\nfunction is_special_selector(s) {\n  return is_host_selector(s) || is_parent_selector(s);\n}\nfunction is_pseudo_selecotr(s) {\n  return /\\:before|\\:after/.test(s);\n}\nconst MathFunc = {};\nfor (let name of Object.getOwnPropertyNames(Math)) {\n  MathFunc[name] = () => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (typeof Math[name] === 'number') {\n      return Math[name];\n    }\n    args = args.map(n => calc(get_value(n)));\n    return Math[name](...args);\n  };\n}\nclass Rules {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.rules = {};\n    this.props = {};\n    this.keyframes = {};\n    this.grid = null;\n    this.seed = null;\n    this.is_grid_defined = false;\n    this.is_gap_defined = false;\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.reset();\n    this.custom_properties = {};\n    this.uniforms = {};\n    this.content = {};\n  }\n  reset() {\n    this.styles = {\n      host: '',\n      container: '',\n      cells: '',\n      keyframes: ''\n    };\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.content = {};\n    for (let key in this.rules) {\n      if (key.startsWith('#c')) {\n        delete this.rules[key];\n      }\n    }\n  }\n  add_rule(selector, rule) {\n    let rules = this.rules[selector];\n    if (!rules) {\n      rules = this.rules[selector] = [];\n    }\n    rules.push.apply(rules, make_array(rule));\n  }\n  pick_func(name) {\n    if (name.startsWith('$')) name = 'calc';\n    return Func[name] || MathFunc[name];\n  }\n  apply_func(fn, coords, args, fname) {\n    let contextedVariable = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let _fn = fn(...make_array(coords));\n    let input = [];\n    args.forEach(arg => {\n      let type = typeof arg.value;\n      let is_string_or_number = type === 'number' || type === 'string';\n      if (!arg.cluster && is_string_or_number) {\n        input.push(...parse_value_group(arg.value, {\n          noSpace: true\n        }));\n      } else {\n        if (typeof arg === 'function') {\n          input.push(arg);\n        } else if (!is_nil(arg.value)) {\n          let value = get_value(arg.value);\n          input.push(value);\n        }\n      }\n    });\n    input = make_array(remove_empty_values(input));\n    if (typeof _fn === 'function') {\n      if (fname.startsWith('$')) {\n        let group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[coords.count], contextedVariable);\n        let context = {};\n        let unit = '';\n        for (let [name, key] of Object.entries(group)) {\n          context[name.substr(2)] = key;\n        }\n        if (fname.length > 1) {\n          var _fname$split$;\n          unit = (_fname$split$ = fname.split('$')[1]) !== null && _fname$split$ !== void 0 ? _fname$split$ : '';\n        }\n        return _fn(input, context) + unit;\n      }\n      return _fn(...input);\n    }\n    return _fn;\n  }\n  compose_aname() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return args.join('-');\n  }\n  compose_selector(_ref) {\n    let {\n      x,\n      y,\n      z\n    } = _ref;\n    let pseudo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return \"#\".concat(cell_id(x, y, z)).concat(pseudo);\n  }\n  is_composable(name) {\n    return ['doodle', 'shaders', 'canvas', 'pattern'].includes(name);\n  }\n  read_var(value, coords, contextedVariable) {\n    let count = coords.count;\n    let group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[count], contextedVariable);\n    if (group[value] !== undefined) {\n      let result = String(group[value]).trim();\n      if (result[0] == '(') {\n        let last = result[result.length - 1];\n        if (last === ')') {\n          result = result.substring(1, result.length - 1);\n        }\n      }\n      return result.replace(/;+$/g, '');\n    }\n    return value;\n  }\n  compose_argument(argument, coords) {\n    var _this = this;\n    let extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let parent = arguments.length > 3 ? arguments[3] : undefined;\n    let contextedVariable = arguments.length > 4 ? arguments[4] : undefined;\n    if (!coords.extra) coords.extra = [];\n    coords.extra.push(extra);\n    let result = argument.map(arg => {\n      if (arg.type === 'text') {\n        if (/^\\-\\-\\w/.test(arg.value)) {\n          if (parent && parent.name === '@var') {\n            return arg.value;\n          }\n          return this.read_var(arg.value, coords, contextedVariable);\n        }\n        return arg.value;\n      } else if (arg.type === 'func') {\n        let fname = arg.name.substr(1);\n        let fn = this.pick_func(fname);\n        if (typeof fn === 'function') {\n          this.check_uniforms(fname);\n          if (this.is_composable(fname)) {\n            let value = get_value((arg.arguments[0] || [])[0]);\n            let temp_arg;\n            if (fname === 'doodle') {\n              if (/^\\d/.test(value)) {\n                temp_arg = value;\n                value = get_value((val.arguments[1] || [])[0]);\n              }\n            }\n            if (!is_nil(value)) {\n              switch (fname) {\n                case 'doodle':\n                  return this.compose_doodle(this.inject_variables(value, coords.count), temp_arg);\n                case 'shaders':\n                  return this.compose_shaders(value, coords);\n                case 'canvas':\n                  return this.compose_canvas(value, arg.arguments.slice(1));\n                case 'pattern':\n                  return this.compose_pattern(value, coords);\n              }\n            }\n          }\n          coords.position = arg.position;\n          let args = arg.arguments.map(n => {\n            return fn.lazy ? function () {\n              for (var _len3 = arguments.length, extra = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                extra[_key3] = arguments[_key3];\n              }\n              return _this.compose_argument(n, coords, extra, arg, contextedVariable);\n            } : this.compose_argument(n, coords, extra, arg, contextedVariable);\n          });\n          return this.apply_func(fn, coords, args, fname, contextedVariable);\n        } else {\n          return arg.name;\n        }\n      }\n    });\n    coords.extra.pop();\n    return {\n      cluster: argument.cluster,\n      value: result.length >= 2 ? {\n        value: result.join('')\n      } : result[0]\n    };\n  }\n  compose_doodle(doodle, arg) {\n    let id = unique_id('doodle');\n    this.doodles[id] = {\n      doodle,\n      arg\n    };\n    return '${' + id + '}';\n  }\n  compose_shaders(shader, _ref2) {\n    let {\n      x,\n      y,\n      z\n    } = _ref2;\n    let id = unique_id('shader');\n    this.shaders[id] = {\n      id: '--' + id,\n      shader,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n  compose_pattern(code, _ref3) {\n    let {\n      x,\n      y,\n      z\n    } = _ref3;\n    let id = unique_id('pattern');\n    this.pattern[id] = {\n      id: '--' + id,\n      code,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n  compose_canvas(code) {\n    let rest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let commands = code;\n    let result = rest.map(group => get_value(group[0])).join(',');\n    if (result.length) {\n      commands = code + ',' + result;\n    }\n    let id = unique_id('canvas');\n    this.canvas[id] = {\n      code: commands\n    };\n    return '${' + id + '}';\n  }\n  check_uniforms(name) {\n    switch (name) {\n      case 'ut':\n      case 't':\n        this.uniforms.time = true;\n        break;\n      case 'ux':\n        this.uniforms.mousex = true;\n        break;\n      case 'uy':\n        this.uniforms.mousey = true;\n        break;\n      case 'uw':\n        this.uniforms.width = true;\n        break;\n      case 'uh':\n        this.uniforms.height = true;\n        break;\n    }\n  }\n  inject_variables(value, count) {\n    let group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[count]);\n    let variables = [];\n    for (let [name, key] of Object.entries(group)) {\n      variables.push(\"\".concat(name, \": \").concat(key, \";\"));\n    }\n    variables = variables.join('');\n    if (variables.length) {\n      return \":doodle { \".concat(variables, \" }\") + value;\n    }\n    return value;\n  }\n  compose_variables(variables, coords) {\n    let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    for (let [name, value] of Object.entries(variables)) {\n      let value_group = value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords, result);\n        if (composed && composed.value) {\n          ret.push(composed.value);\n        }\n        return ret;\n      }, []);\n      result[name] = value_group.join(', ');\n    }\n    return result;\n  }\n  compose_value(value, coords) {\n    var _this2 = this;\n    let contextedVariable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!Array.isArray(value)) {\n      return {\n        value: '',\n        extra: ''\n      };\n    }\n    let extra = '';\n    let output = value.reduce((result, val) => {\n      switch (val.type) {\n        case 'text':\n          {\n            result += val.value;\n            break;\n          }\n        case 'func':\n          {\n            let fname = val.name.substr(1);\n            let fn = this.pick_func(fname);\n            if (typeof fn === 'function') {\n              this.check_uniforms(fname);\n              if (this.is_composable(fname)) {\n                let value = get_value((val.arguments[0] || [])[0]);\n                let temp_arg;\n                if (fname === 'doodle') {\n                  if (/^\\d/.test(value)) {\n                    temp_arg = value;\n                    value = get_value((val.arguments[1] || [])[0]);\n                  }\n                }\n                if (!is_nil(value)) {\n                  switch (fname) {\n                    case 'doodle':\n                      result += this.compose_doodle(this.inject_variables(value, coords.count), temp_arg);\n                      break;\n                    case 'shaders':\n                      result += this.compose_shaders(value, coords);\n                      break;\n                    case 'pattern':\n                      result += this.compose_pattern(value, coords);\n                      break;\n                    case 'canvas':\n                      result += this.compose_canvas(value, val.arguments.slice(1));\n                      break;\n                  }\n                }\n              } else {\n                coords.position = val.position;\n                if (val.variables) {\n                  this.compose_variables(val.variables, coords, contextedVariable);\n                }\n                let args = val.arguments.map(arg => {\n                  return fn.lazy ? function () {\n                    for (var _len4 = arguments.length, extra = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                      extra[_key4] = arguments[_key4];\n                    }\n                    return _this2.compose_argument(arg, coords, extra, val, contextedVariable);\n                  } : this.compose_argument(arg, coords, [], val, contextedVariable);\n                });\n                let output = this.apply_func(fn, coords, args, fname, contextedVariable);\n                if (!is_nil(output)) {\n                  result += output;\n                  if (output.extra) {\n                    extra = output.extra;\n                  }\n                }\n              }\n            } else {\n              result += val.name;\n            }\n          }\n      }\n      return result;\n    }, '');\n    return {\n      value: output,\n      extra: extra\n    };\n  }\n  add_grid_style(_ref4) {\n    let {\n      fill,\n      clip,\n      rotate,\n      scale,\n      translate,\n      flexRow,\n      flexColumn\n    } = _ref4;\n    if (fill) {\n      this.add_rule(':host', \"background-color: \".concat(fill, \";\"));\n    }\n    if (!clip) {\n      this.add_rule(':host', 'contain: none;');\n    }\n    if (rotate) {\n      this.add_rule(':container', \"rotate: \".concat(rotate, \";\"));\n    }\n    if (scale) {\n      this.add_rule(':container', \"scale: \".concat(scale, \";\"));\n    }\n    if (translate) {\n      this.add_rule(':container', \"translate: \".concat(translate, \";\"));\n    }\n    if (flexRow) {\n      this.add_rule(':container', \"display: flex;\");\n      this.add_rule('cell', \"flex: 1;\");\n    }\n    if (flexColumn) {\n      this.add_rule(':container', \"display: flex; flex-direction: column;\");\n      this.add_rule('cell', \"flex: 1;\");\n    }\n  }\n  compose_rule(token, _coords, selector) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n    let extra;\n    if (prop === '@seed') {\n      return '';\n    }\n    let value_group = token.value.reduce((ret, v) => {\n      let composed = this.compose_value(v, coords);\n      if (composed) {\n        if (composed.value) {\n          ret.push(composed.value);\n        }\n        if (composed.extra) {\n          extra = composed.extra;\n        }\n      }\n      return ret;\n    }, []);\n    let value = value_group.join(', ');\n    if (/^animation(\\-name)?$/.test(prop)) {\n      this.props.has_animation = true;\n      if (is_host_selector(selector)) {\n        let prefix = uniform_time[prop];\n        if (prefix && value) {\n          value = prefix + ',' + value;\n        }\n      }\n      if (coords.count > 1) {\n        let {\n          count\n        } = coords;\n        switch (prop) {\n          case 'animation-name':\n            {\n              value = value_group.map(n => this.compose_aname(n, count)).join(', ');\n              break;\n            }\n          case 'animation':\n            {\n              value = value_group.map(n => {\n                let group = (n || '').split(/\\s+/);\n                group[0] = this.compose_aname(group[0], count);\n                return group.join(' ');\n              }).join(', ');\n            }\n        }\n      }\n    }\n    if (prop === 'content') {\n      if (!/[\"']|^none\\s?$|^(var|counter|counters|attr|url)\\(/.test(value)) {\n        value = \"'\".concat(value, \"'\");\n      }\n    }\n    if (prop === 'transition') {\n      this.props.has_transition = true;\n    }\n    let rule = \"\".concat(prop, \": \").concat(value, \";\");\n    rule = prefixer(prop, rule);\n    if (prop === 'clip-path') {\n      // fix clip bug\n      rule += ';overflow: hidden;';\n    }\n    if (prop === 'width' || prop === 'height') {\n      if (!is_special_selector(selector)) {\n        rule += \"--internal-cell-\".concat(prop, \": \").concat(value, \";\");\n      }\n    }\n    let is_image = /^(background|background\\-image)$/.test(prop) && /\\$\\{(canvas|shader|pattern)/.test(value);\n    if (is_image) {\n      rule += 'background-size: 100% 100%;';\n    }\n    if (/^\\-\\-/.test(prop)) {\n      let key = _coords.count;\n      if (is_parent_selector(selector)) {\n        key = 'container';\n      }\n      if (is_host_selector(selector)) {\n        key = 'host';\n      }\n      if (!this.custom_properties[key]) {\n        this.custom_properties[key] = {};\n      }\n      this.custom_properties[key][prop] = value;\n    }\n    if (/^@/.test(prop) && Property[prop.substr(1)]) {\n      let name = prop.substr(1);\n      let transformed = Property[name](value, {\n        is_special_selector: is_special_selector(selector),\n        grid: coords.grid,\n        max_grid: coords.max_grid,\n        extra\n      });\n      switch (name) {\n        case 'grid':\n          {\n            if (is_host_selector(selector)) {\n              rule = transformed.size || '';\n              this.add_grid_style(transformed);\n            } else {\n              rule = '';\n              if (!this.is_grid_defined) {\n                transformed = Property[name](value, {\n                  is_special_selector: true,\n                  grid: coords.grid,\n                  max_grid: coords.max_grid\n                });\n                this.add_rule(':host', transformed.size || '');\n                this.add_grid_style(transformed);\n              }\n            }\n            this.grid = coords.grid;\n            this.is_grid_defined = true;\n            break;\n          }\n        case 'gap':\n          {\n            rule = '';\n            if (!this.is_gap_defined) {\n              this.add_rule(':container', \"gap: \".concat(transformed, \";\"));\n              this.is_gap_defined = true;\n            }\n            break;\n          }\n        case 'content':\n          {\n            rule = '';\n            let key = this.compose_selector(coords);\n            if (transformed !== undefined && !is_pseudo_selecotr(selector) && !is_parent_selector(selector)) {\n              this.content[key] = remove_quotes(String(transformed));\n            }\n            this.content[key] = Func.raw({\n              rules: {\n                doodles: this.doodles\n              }\n            })(this.content[key] || '');\n          }\n        case 'seed':\n          {\n            rule = '';\n            break;\n          }\n        case 'place-cell':\n        case 'place':\n        case 'position':\n        case 'offset':\n          {\n            if (!is_host_selector(selector)) {\n              rule = transformed;\n            }\n            break;\n          }\n        case 'use':\n          {\n            if (token.value.length) {\n              this.compose(coords, token.value);\n            }\n            rule = '';\n            break;\n          }\n        default:\n          {\n            rule = transformed;\n          }\n      }\n    }\n    return rule;\n  }\n  get_raw_value(token) {\n    let raw = token.raw();\n    if (is_nil(raw)) {\n      raw = '';\n    }\n    let [_, ...rest] = raw.split(token.property);\n    // It's not accurate, will be solved after the rewrite of css parser.\n    rest = rest.join(token.property).replace(/^\\s*:\\s*/, '').replace(/[;}<]$/, '').trim().replace(/[;}<]$/, '');\n    return rest;\n  }\n  pre_compose_rule(token, _coords) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n    switch (prop) {\n      case '@grid':\n        {\n          let value_group = token.value.reduce((ret, v) => {\n            let composed = this.compose_value(v, coords);\n            if (composed && composed.value) ret.push(composed.value);\n            return ret;\n          }, []);\n          let value = value_group.join(', ');\n          let name = prop.substr(1);\n          let transformed = Property[name](value, {\n            max_grid: _coords.max_grid\n          });\n          this.grid = transformed.grid;\n          break;\n        }\n      case '@use':\n        {\n          if (token.value.length) {\n            this.pre_compose(coords, token.value);\n          }\n          break;\n        }\n    }\n  }\n  pre_compose(coords, tokens) {\n    if (is_nil(this.seed)) {\n      // get seed first\n      ;\n      (tokens || this.tokens).forEach(token => {\n        if (token.type === 'rule' && token.property === '@seed') {\n          this.seed = this.get_raw_value(token);\n        }\n        if (token.type === 'pseudo' && is_host_selector(token.selector)) {\n          for (let t of make_array(token.styles)) {\n            if (t.type === 'rule' && t.property === '@seed') {\n              this.seed = this.get_raw_value(t);\n            }\n          }\n        }\n      });\n      if (is_nil(this.seed)) {\n        //this.seed = coords.seed_value;\n      } else {\n        coords.update_random(this.seed);\n      }\n    }\n    ;\n    (tokens || this.tokens).forEach(token => {\n      switch (token.type) {\n        case 'rule':\n          {\n            this.pre_compose_rule(token, coords);\n            break;\n          }\n        case 'pseudo':\n          {\n            if (is_host_selector(token.selector)) {\n              (token.styles || []).forEach(token => {\n                this.pre_compose_rule(token, coords);\n              });\n            }\n            break;\n          }\n      }\n    });\n  }\n  compose(coords, tokens, initial) {\n    this.coords.push(coords);\n    (tokens || this.tokens).forEach((token, i) => {\n      if (token.skip) return false;\n      if (initial && this.grid) return false;\n      switch (token.type) {\n        case 'rule':\n          {\n            this.add_rule(this.compose_selector(coords), this.compose_rule(token, coords));\n            break;\n          }\n        case 'pseudo':\n          {\n            if (token.selector.startsWith(':doodle')) {\n              token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n            }\n            let special = is_special_selector(token.selector);\n            if (special) {\n              token.skip = true;\n            }\n            token.selector.split(',').forEach(selector => {\n              let pseudo = token.styles.map(s => this.compose_rule(s, coords, selector));\n              let composed = special ? selector : this.compose_selector(coords, selector);\n              this.add_rule(composed, pseudo);\n            });\n            break;\n          }\n        case 'cond':\n          {\n            let name = token.name.substr(1);\n            let fn = Selector[name];\n            if (fn) {\n              let args = token.arguments.map(arg => {\n                return this.compose_argument(arg, coords);\n              });\n              let cond = this.apply_func(fn, coords, args, name);\n              if (Array.isArray(token.addition)) {\n                for (let c of token.addition) {\n                  if (c === 'not') cond = !cond;\n                }\n              }\n              if (cond) {\n                if (cond.selector) {\n                  token.styles.forEach(_token => {\n                    if (_token.type === 'rule') {\n                      this.add_rule(cond.selector.replaceAll('$', this.compose_selector(coords)), this.compose_rule(_token, coords));\n                    }\n                    if (_token.type === 'pseudo') {\n                      _token.selector.split(',').forEach(selector => {\n                        let pseudo = _token.styles.map(s => this.compose_rule(s, coords, selector));\n                        this.add_rule((cond.selector + selector).replaceAll('$', this.compose_selector(coords)), pseudo);\n                      });\n                    }\n                  });\n                } else {\n                  this.compose(coords, token.styles);\n                }\n              }\n            }\n            break;\n          }\n        case 'keyframes':\n          {\n            if (!this.keyframes[token.name]) {\n              this.keyframes[token.name] = coords => \"\\n              \".concat(join(token.steps.map(step => \"\\n                \".concat(step.name, \" {\\n                  \").concat(join(step.styles.map(s => this.compose_rule(s, coords))), \"\\n                }\\n              \"))), \"\\n            \");\n            }\n          }\n      }\n    });\n  }\n  output() {\n    for (let [selector, rule] of Object.entries(this.rules)) {\n      if (is_parent_selector(selector)) {\n        this.styles.container += \"\\n          .container {\\n            \".concat(join(rule), \"\\n          }\\n        \");\n      } else {\n        let target = is_host_selector(selector) ? 'host' : 'cells';\n        let value = join(rule).trim();\n        if (value.length) {\n          let name = target === 'host' ? \"\".concat(selector, \", .host\") : selector;\n          this.styles[target] += \"\".concat(name, \" { \").concat(value, \" }\");\n        }\n      }\n    }\n    if (this.uniforms.time) {\n      this.styles.container += \"\\n        :host, .host {\\n          animation: \".concat(uniform_time.animation, \";\\n        }\\n      \");\n      this.styles.keyframes += \"\\n       @keyframes \".concat(uniform_time['animation-name'], \" {\\n         from { --\").concat(uniform_time.name, \": 0 }\\n         to { --\").concat(uniform_time.name, \": \").concat(uniform_time['animation-duration'] / 10, \" }\\n       }\\n      \");\n    }\n    this.coords.forEach((coords, i) => {\n      for (let [name, keyframe] of Object.entries(this.keyframes)) {\n        let aname = this.compose_aname(name, coords.count);\n        this.styles.keyframes += \"\\n          \".concat(maybe(i === 0, \"@keyframes \".concat(name, \" { \").concat(keyframe(coords), \" }\")), \"\\n          @keyframes \").concat(aname, \" {\\n            \").concat(keyframe(coords), \"\\n          }\\n        \");\n      }\n    });\n    return {\n      props: this.props,\n      styles: this.styles,\n      grid: this.grid,\n      seed: this.seed,\n      random: this.random,\n      doodles: this.doodles,\n      shaders: this.shaders,\n      canvas: this.canvas,\n      pattern: this.pattern,\n      uniforms: this.uniforms,\n      content: this.content\n    };\n  }\n}\nfunction remove_quotes(input) {\n  let remove = input.startsWith('\"') && input.endsWith('\"') || input.startsWith(\"'\") && input.endsWith(\"'\");\n  if (remove) {\n    return input.substring(1, input.length - 1);\n  }\n  return input;\n}\nfunction generate_css(tokens, grid_size, seed_value, max_grid, seed_random) {\n  let rules = new Rules(tokens);\n  let random = seed_random || seedrandom(String(seed_value));\n  let context = {};\n  function update_random(seed) {\n    random = seedrandom(String(seed));\n  }\n  function rand() {\n    let start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let end = arguments.length > 1 ? arguments[1] : undefined;\n    if (arguments.length == 1) {\n      [start, end] = [0, start];\n    }\n    return lerp(random(), start, end);\n  }\n  function pick() {\n    for (var _len5 = arguments.length, items = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      items[_key5] = arguments[_key5];\n    }\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(random() * args.length)];\n  }\n  function shuffle(arr) {\n    let ret = [...arr];\n    let m = arr.length;\n    while (m) {\n      let i = ~~(random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n    return ret;\n  }\n  rules.pre_compose({\n    x: 1,\n    y: 1,\n    z: 1,\n    count: 1,\n    context: {},\n    grid: {\n      x: 1,\n      y: 1,\n      z: 1,\n      count: 1\n    },\n    random,\n    rand,\n    pick,\n    shuffle,\n    max_grid,\n    update_random,\n    seed_value,\n    rules\n  });\n  let {\n    grid,\n    seed\n  } = rules.output();\n  if (grid) {\n    grid_size = grid;\n  }\n  if (seed) {\n    seed = String(seed);\n    random = seedrandom(seed);\n  } else {\n    seed = seed_value;\n  }\n  if (is_nil(seed)) {\n    seed = Date.now();\n    random = seedrandom(seed);\n  }\n  seed = String(seed);\n  rules.seed = seed;\n  rules.random = random;\n  rules.reset();\n  if (grid_size.z == 1) {\n    for (let y = 1, count = 0; y <= grid_size.y; ++y) {\n      for (let x = 1; x <= grid_size.x; ++x) {\n        rules.compose({\n          x,\n          y,\n          z: 1,\n          count: ++count,\n          grid: grid_size,\n          context,\n          rand,\n          pick,\n          shuffle,\n          random,\n          seed,\n          max_grid,\n          rules\n        });\n      }\n    }\n  } else {\n    for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n      rules.compose({\n        x: 1,\n        y: 1,\n        z,\n        count: ++count,\n        grid: grid_size,\n        context,\n        rand,\n        pick,\n        shuffle,\n        random,\n        seed,\n        max_grid,\n        rules\n      });\n    }\n  }\n  return rules.output();\n}\nexport { generate_css };","map":{"version":3,"names":["Func","Property","Selector","parse_value_group","calc","uniform_time","seedrandom","prefixer","maybe","cell_id","is_nil","get_value","lerp","unique_id","join","make_array","remove_empty_values","is_host_selector","s","test","is_parent_selector","is_special_selector","is_pseudo_selecotr","MathFunc","name","Object","getOwnPropertyNames","Math","_len","arguments","length","args","Array","_key","map","n","Rules","constructor","tokens","rules","props","keyframes","grid","seed","is_grid_defined","is_gap_defined","coords","doodles","canvas","pattern","shaders","reset","custom_properties","uniforms","content","styles","host","container","cells","key","startsWith","add_rule","selector","rule","push","apply","pick_func","apply_func","fn","fname","contextedVariable","undefined","_fn","input","forEach","arg","type","value","is_string_or_number","cluster","noSpace","group","assign","count","context","unit","entries","substr","_fname$split$","split","compose_aname","_len2","_key2","compose_selector","_ref","x","y","z","pseudo","concat","is_composable","includes","read_var","result","String","trim","last","substring","replace","compose_argument","argument","_this","extra","parent","check_uniforms","temp_arg","val","compose_doodle","inject_variables","compose_shaders","compose_canvas","slice","compose_pattern","position","lazy","_len3","_key3","pop","doodle","id","shader","_ref2","cell","code","_ref3","rest","commands","time","mousex","mousey","width","height","variables","compose_variables","value_group","reduce","ret","v","composed","compose_value","_this2","isArray","output","_len4","_key4","add_grid_style","_ref4","fill","clip","rotate","scale","translate","flexRow","flexColumn","compose_rule","token","_coords","prop","property","has_animation","prefix","has_transition","is_image","transformed","max_grid","size","remove_quotes","raw","compose","get_raw_value","_","pre_compose_rule","pre_compose","t","update_random","initial","i","skip","special","cond","addition","c","_token","replaceAll","steps","step","target","animation","keyframe","aname","random","remove","endsWith","generate_css","grid_size","seed_value","seed_random","rand","start","end","pick","_len5","items","_key5","acc","shuffle","arr","m","Date","now"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/generator/css.js"],"sourcesContent":["import Func from '../function.js';\nimport Property from '../property.js';\nimport Selector from '../selector.js';\nimport parse_value_group from '../parser/parse-value-group.js';\n\nimport calc from '../calc.js';\nimport { uniform_time } from '../uniforms.js';\nimport { seedrandom } from '../lib/seedrandom.js';\n\nimport { prefixer } from '../utils/prefixer.js';\nimport { maybe, cell_id, is_nil, get_value, lerp, unique_id } from '../utils/index.js';\nimport { join, make_array, remove_empty_values } from '../utils/list.js'\n\nfunction is_host_selector(s) {\n  return /^\\:(host|doodle)/.test(s);\n}\n\nfunction is_parent_selector(s) {\n  return /^\\:(container|parent)/.test(s);\n}\n\nfunction is_special_selector(s) {\n  return is_host_selector(s) || is_parent_selector(s);\n}\n\nfunction is_pseudo_selecotr(s) {\n  return /\\:before|\\:after/.test(s);\n}\n\nconst MathFunc = {};\nfor (let name of Object.getOwnPropertyNames(Math)) {\n  MathFunc[name] = () => (...args) => {\n    if (typeof Math[name] === 'number') {\n      return Math[name];\n    }\n    args = args.map(n => calc(get_value(n)));\n    return Math[name](...args);\n  }\n}\n\nclass Rules {\n\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.rules = {};\n    this.props = {};\n    this.keyframes = {};\n    this.grid = null;\n    this.seed = null;\n    this.is_grid_defined = false;\n    this.is_gap_defined = false;\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.reset();\n    this.custom_properties = {};\n    this.uniforms = {};\n    this.content = {};\n  }\n\n  reset() {\n    this.styles = {\n      host: '',\n      container: '',\n      cells: '',\n      keyframes: ''\n    }\n    this.coords = [];\n    this.doodles = {};\n    this.canvas = {};\n    this.pattern = {};\n    this.shaders = {};\n    this.content = {};\n    for (let key in this.rules) {\n      if (key.startsWith('#c')) {\n        delete this.rules[key];\n      }\n    }\n  }\n\n  add_rule(selector, rule) {\n    let rules = this.rules[selector];\n    if (!rules) {\n      rules = this.rules[selector] = [];\n    }\n    rules.push.apply(rules, make_array(rule));\n  }\n\n  pick_func(name) {\n    if (name.startsWith('$')) name = 'calc';\n    return Func[name] || MathFunc[name];\n  }\n\n  apply_func(fn, coords, args, fname, contextedVariable = {}) {\n    let _fn = fn(...make_array(coords));\n    let input = [];\n    args.forEach(arg => {\n      let type = typeof arg.value;\n      let is_string_or_number = (type === 'number' || type === 'string');\n      if (!arg.cluster && (is_string_or_number)) {\n        input.push(...parse_value_group(arg.value, { noSpace: true }));\n      }\n      else {\n        if (typeof arg === 'function') {\n          input.push(arg);\n        }\n        else if (!is_nil(arg.value)) {\n          let value = get_value(arg.value);\n          input.push(value);\n        }\n      }\n    });\n    input = make_array(remove_empty_values(input));\n    if (typeof _fn === 'function') {\n      if (fname.startsWith('$')) {\n        let group = Object.assign({},\n          this.custom_properties['host'],\n          this.custom_properties['container'],\n          this.custom_properties[coords.count],\n          contextedVariable\n        );\n        let context = {};\n        let unit = '';\n        for (let [name, key] of Object.entries(group)) {\n          context[name.substr(2)] = key;\n        }\n        if (fname.length > 1) {\n          unit = fname.split('$')[1] ?? '';\n        }\n        return _fn(input, context) + unit;\n      }\n      return _fn(...input);\n    }\n    return _fn;\n  }\n\n  compose_aname(...args) {\n    return args.join('-');\n  }\n\n  compose_selector({ x, y, z}, pseudo = '') {\n    return `#${ cell_id(x, y, z) }${ pseudo }`;\n  }\n\n  is_composable(name) {\n    return ['doodle', 'shaders', 'canvas', 'pattern'].includes(name);\n  }\n\n  read_var(value, coords, contextedVariable) {\n    let count = coords.count;\n    let group = Object.assign({},\n      this.custom_properties['host'],\n      this.custom_properties['container'],\n      this.custom_properties[count],\n      contextedVariable\n    );\n    if (group[value] !== undefined) {\n      let result = String(group[value]).trim();\n      if (result[0] == '(') {\n        let last = result[result.length - 1];\n        if (last === ')') {\n          result = result.substring(1, result.length - 1);\n        }\n      }\n      return result.replace(/;+$/g, '');\n    }\n    return value;\n  }\n\n  compose_argument(argument, coords, extra = [], parent, contextedVariable) {\n    if (!coords.extra) coords.extra = [];\n    coords.extra.push(extra);\n    let result = argument.map(arg => {\n      if (arg.type === 'text') {\n        if (/^\\-\\-\\w/.test(arg.value)) {\n          if (parent && parent.name === '@var') {\n            return arg.value;\n          }\n          return this.read_var(arg.value, coords, contextedVariable);\n        }\n        return arg.value;\n      }\n      else if (arg.type === 'func') {\n        let fname = arg.name.substr(1);\n        let fn = this.pick_func(fname);\n        if (typeof fn === 'function') {\n          this.check_uniforms(fname);\n          if (this.is_composable(fname)) {\n            let value = get_value((arg.arguments[0] || [])[0]);\n            let temp_arg;\n            if (fname === 'doodle') {\n              if (/^\\d/.test(value)) {\n                temp_arg = value;\n                value = get_value((val.arguments[1] || [])[0]);\n              }\n            }\n            if (!is_nil(value)) {\n              switch (fname) {\n                case 'doodle':\n                  return this.compose_doodle(this.inject_variables(value, coords.count), temp_arg);\n                case 'shaders':\n                  return this.compose_shaders(value, coords);\n                case 'canvas':\n                  return this.compose_canvas(value, arg.arguments.slice(1));\n                case 'pattern':\n                  return this.compose_pattern(value, coords);\n              }\n            }\n          }\n          coords.position = arg.position;\n          let args = arg.arguments.map(n => {\n            return fn.lazy\n              ? (...extra) => this.compose_argument(n, coords, extra, arg, contextedVariable)\n              : this.compose_argument(n, coords, extra, arg, contextedVariable);\n          });\n          return this.apply_func(fn, coords, args, fname, contextedVariable);\n        } else {\n          return arg.name;\n        }\n      }\n    });\n\n    coords.extra.pop();\n\n    return {\n      cluster: argument.cluster,\n      value: (result.length >= 2 ? ({ value: result.join('') }) : result[0])\n    }\n  }\n\n  compose_doodle(doodle, arg) {\n    let id = unique_id('doodle');\n    this.doodles[id] = { doodle, arg };\n    return '${' + id + '}';\n  }\n\n  compose_shaders(shader, {x, y, z}) {\n    let id = unique_id('shader');\n    this.shaders[id] = {\n      id: '--' + id,\n      shader,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n\n  compose_pattern(code, {x, y, z}) {\n    let id = unique_id('pattern');\n    this.pattern[id] = {\n      id: '--' + id,\n      code,\n      cell: cell_id(x, y, z)\n    };\n    return '${' + id + '}';\n  }\n\n  compose_canvas(code, rest = []) {\n    let commands = code;\n    let result = rest.map(group => get_value(group[0])).join(',');\n    if (result.length) {\n      commands = code + ',' + result;\n    }\n    let id = unique_id('canvas');\n    this.canvas[id] = { code: commands };\n    return '${' + id + '}';\n  }\n\n  check_uniforms(name) {\n    switch (name) {\n      case 'ut': case 't': this.uniforms.time = true; break;\n      case 'ux': this.uniforms.mousex = true; break;\n      case 'uy': this.uniforms.mousey = true; break;\n      case 'uw': this.uniforms.width = true; break;\n      case 'uh': this.uniforms.height = true; break;\n    }\n  }\n\n  inject_variables(value, count) {\n    let group = Object.assign({},\n      this.custom_properties['host'],\n      this.custom_properties['container'],\n      this.custom_properties[count]\n    );\n    let variables = [];\n    for (let [name, key] of Object.entries(group)) {\n      variables.push(`${name}: ${key};`);\n    }\n    variables = variables.join('');\n    if (variables.length) {\n      return `:doodle { ${variables} }` + value;\n    }\n    return value;\n  }\n\n  compose_variables(variables, coords, result = {}) {\n    for (let [name, value] of Object.entries(variables)) {\n      let value_group = value.reduce((ret, v) => {\n        let composed = this.compose_value(v, coords, result);\n        if (composed && composed.value) {\n          ret.push(composed.value);\n        }\n        return ret;\n      }, []);\n      result[name] = value_group.join(', ');\n    }\n    return result;\n  }\n\n  compose_value(value, coords, contextedVariable = {}) {\n    if (!Array.isArray(value)) {\n      return {\n        value: '',\n        extra: '',\n      }\n    }\n    let extra = '';\n    let output = value.reduce((result, val) => {\n      switch (val.type) {\n        case 'text': {\n          result += val.value;\n          break;\n        }\n        case 'func': {\n          let fname = val.name.substr(1);\n          let fn = this.pick_func(fname);\n          if (typeof fn === 'function') {\n            this.check_uniforms(fname);\n            if (this.is_composable(fname)) {\n              let value = get_value((val.arguments[0] || [])[0]);\n              let temp_arg;\n              if (fname === 'doodle') {\n                if (/^\\d/.test(value)) {\n                  temp_arg = value;\n                  value = get_value((val.arguments[1] || [])[0]);\n                }\n              }\n              if (!is_nil(value)) {\n                switch (fname) {\n                  case 'doodle':\n                    result += this.compose_doodle(this.inject_variables(value, coords.count), temp_arg); break;\n                  case 'shaders':\n                    result += this.compose_shaders(value, coords); break;\n                  case 'pattern':\n                    result += this.compose_pattern(value, coords); break;\n                  case 'canvas':\n                    result += this.compose_canvas(value, val.arguments.slice(1)); break;\n                }\n              }\n            } else {\n              coords.position = val.position;\n              if (val.variables) {\n                this.compose_variables(val.variables, coords, contextedVariable);\n              }\n              let args = val.arguments.map(arg => {\n                return fn.lazy\n                  ? (...extra) => this.compose_argument(arg, coords, extra, val, contextedVariable)\n                  : this.compose_argument(arg, coords, [], val, contextedVariable);\n              });\n\n              let output = this.apply_func(fn, coords, args, fname, contextedVariable);\n              if (!is_nil(output)) {\n                result += output;\n                if (output.extra) {\n                  extra = output.extra;\n                }\n              }\n            }\n          } else {\n            result += val.name;\n          }\n        }\n      }\n      return result;\n    }, '');\n\n    return {\n      value: output,\n      extra: extra,\n    }\n  }\n\n  add_grid_style({ fill, clip, rotate, scale, translate, flexRow, flexColumn }) {\n    if (fill) {\n      this.add_rule(':host', `background-color: ${fill};`);\n    }\n    if (!clip) {\n      this.add_rule(':host', 'contain: none;');\n    }\n    if (rotate) {\n      this.add_rule(':container', `rotate: ${rotate};`);\n    }\n    if (scale) {\n      this.add_rule(':container', `scale: ${scale};`);\n    }\n    if (translate) {\n      this.add_rule(':container', `translate: ${translate};`);\n    }\n    if (flexRow) {\n      this.add_rule(':container', `display: flex;`);\n      this.add_rule('cell', `flex: 1;`);\n    }\n    if (flexColumn) {\n      this.add_rule(':container', `display: flex; flex-direction: column;`);\n      this.add_rule('cell', `flex: 1;`);\n    }\n  }\n\n  compose_rule(token, _coords, selector) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n    let extra;\n    if (prop === '@seed') {\n      return '';\n    }\n    let value_group = token.value.reduce((ret, v) => {\n      let composed = this.compose_value(v, coords);\n      if (composed) {\n        if (composed.value) {\n          ret.push(composed.value);\n        }\n        if (composed.extra) {\n          extra = composed.extra;\n        }\n      }\n      return ret;\n    }, []);\n\n    let value = value_group.join(', ');\n\n    if (/^animation(\\-name)?$/.test(prop)) {\n      this.props.has_animation = true;\n\n      if (is_host_selector(selector)) {\n        let prefix = uniform_time[prop];\n        if (prefix && value) {\n          value =  prefix + ',' + value;\n        }\n      }\n\n      if (coords.count > 1) {\n        let { count } = coords;\n        switch (prop) {\n          case 'animation-name': {\n            value = value_group\n              .map(n => this.compose_aname(n, count))\n              .join(', ');\n            break;\n          }\n          case 'animation': {\n            value = value_group\n              .map(n => {\n                let group = (n || '').split(/\\s+/);\n                group[0] = this.compose_aname(group[0], count);\n                return group.join(' ');\n              })\n              .join(', ');\n          }\n        }\n      }\n    }\n\n    if (prop === 'content') {\n      if (!/[\"']|^none\\s?$|^(var|counter|counters|attr|url)\\(/.test(value)) {\n        value = `'${ value }'`;\n      }\n    }\n\n    if (prop === 'transition') {\n      this.props.has_transition = true;\n    }\n\n    let rule = `${ prop }: ${ value };`\n    rule = prefixer(prop, rule);\n\n    if (prop === 'clip-path') {\n      // fix clip bug\n      rule += ';overflow: hidden;';\n    }\n\n    if (prop === 'width' || prop === 'height') {\n      if (!is_special_selector(selector)) {\n        rule += `--internal-cell-${ prop }: ${ value };`;\n      }\n    }\n\n    let is_image = (\n      /^(background|background\\-image)$/.test(prop) &&\n      /\\$\\{(canvas|shader|pattern)/.test(value)\n    );\n    if (is_image) {\n      rule += 'background-size: 100% 100%;';\n    }\n\n    if (/^\\-\\-/.test(prop)) {\n      let key = _coords.count;\n      if (is_parent_selector(selector)) {\n        key = 'container';\n      }\n      if (is_host_selector(selector)) {\n        key = 'host';\n      }\n      if (!this.custom_properties[key]) {\n        this.custom_properties[key] = {};\n      }\n      this.custom_properties[key][prop] = value;\n    }\n\n    if (/^@/.test(prop) && Property[prop.substr(1)]) {\n      let name = prop.substr(1);\n      let transformed = Property[name](value, {\n        is_special_selector: is_special_selector(selector),\n        grid: coords.grid,\n        max_grid: coords.max_grid,\n        extra\n      });\n      switch (name) {\n        case 'grid': {\n          if (is_host_selector(selector)) {\n            rule = transformed.size || '';\n            this.add_grid_style(transformed);\n          } else {\n            rule = '';\n            if (!this.is_grid_defined) {\n              transformed = Property[name](value, {\n                is_special_selector: true,\n                grid: coords.grid,\n                max_grid: coords.max_grid\n              });\n              this.add_rule(':host', transformed.size || '');\n              this.add_grid_style(transformed);\n            }\n          }\n          this.grid = coords.grid;\n          this.is_grid_defined = true;\n          break;\n        }\n        case 'gap': {\n          rule = '';\n          if (!this.is_gap_defined) {\n            this.add_rule(':container', `gap: ${transformed};`);\n            this.is_gap_defined = true;\n          }\n          break;\n        }\n        case 'content': {\n          rule = '';\n          let key = this.compose_selector(coords);\n          if (transformed !== undefined && !is_pseudo_selecotr(selector) && !is_parent_selector(selector)) {\n            this.content[key] = remove_quotes(String(transformed));\n          }\n          this.content[key] = Func.raw({\n            rules: {\n              doodles: this.doodles\n            }\n          })(this.content[key] || '');\n        }\n        case 'seed': {\n          rule = '';\n          break;\n        }\n        case 'place-cell':\n        case 'place':\n        case 'position':\n        case 'offset': {\n          if (!is_host_selector(selector)) {\n            rule = transformed;\n          }\n          break;\n        }\n        case 'use': {\n          if (token.value.length) {\n            this.compose(coords, token.value);\n          }\n          rule = '';\n          break;\n        }\n        default: {\n          rule = transformed;\n        }\n      }\n    }\n\n    return rule;\n  }\n\n  get_raw_value(token) {\n    let raw = token.raw();\n    if (is_nil(raw)){\n      raw = '';\n    }\n    let [_, ...rest] = raw.split(token.property);\n    // It's not accurate, will be solved after the rewrite of css parser.\n    rest = rest.join(token.property)\n      .replace(/^\\s*:\\s*/, '')\n      .replace(/[;}<]$/, '').trim()\n      .replace(/[;}<]$/, '');\n    return rest;\n  }\n\n  pre_compose_rule(token, _coords) {\n    let coords = Object.assign({}, _coords);\n    let prop = token.property;\n\n    switch (prop) {\n      case '@grid': {\n        let value_group = token.value.reduce((ret, v) => {\n          let composed = this.compose_value(v, coords);\n          if (composed && composed.value) ret.push(composed.value);\n          return ret;\n        }, []);\n        let value = value_group.join(', ');\n        let name = prop.substr(1);\n        let transformed = Property[name](value, {\n          max_grid: _coords.max_grid\n        });\n        this.grid = transformed.grid;\n        break;\n      }\n      case '@use': {\n        if (token.value.length) {\n          this.pre_compose(coords, token.value);\n        }\n        break;\n      }\n    }\n  }\n\n  pre_compose(coords, tokens) {\n    if (is_nil(this.seed)) {\n      // get seed first\n      ;(tokens || this.tokens).forEach(token => {\n        if (token.type === 'rule' && token.property === '@seed') {\n          this.seed = this.get_raw_value(token);\n        }\n        if (token.type === 'pseudo' && is_host_selector(token.selector)) {\n          for (let t of make_array(token.styles)) {\n            if (t.type === 'rule' && t.property === '@seed') {\n              this.seed = this.get_raw_value(t);\n            }\n          }\n        }\n      });\n      if (is_nil(this.seed)) {\n        //this.seed = coords.seed_value;\n      } else {\n        coords.update_random(this.seed);\n      }\n    }\n    ;(tokens || this.tokens).forEach(token => {\n      switch (token.type) {\n        case 'rule': {\n          this.pre_compose_rule(token, coords)\n          break;\n        }\n        case 'pseudo': {\n          if (is_host_selector(token.selector)) {\n            (token.styles || []).forEach(token => {\n              this.pre_compose_rule(token, coords);\n            });\n          }\n          break;\n        }\n      }\n    });\n  }\n\n  compose(coords, tokens, initial) {\n    this.coords.push(coords);\n    (tokens || this.tokens).forEach((token, i) => {\n      if (token.skip) return false;\n      if (initial && this.grid) return false;\n\n      switch (token.type) {\n        case 'rule': {\n          this.add_rule(\n            this.compose_selector(coords),\n            this.compose_rule(token, coords)\n          );\n          break;\n        }\n\n        case 'pseudo': {\n          if (token.selector.startsWith(':doodle')) {\n            token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n          }\n          let special = is_special_selector(token.selector);\n          if (special) {\n            token.skip = true;\n          }\n          token.selector.split(',').forEach(selector => {\n            let pseudo = token.styles.map(s =>\n              this.compose_rule(s, coords, selector)\n            );\n            let composed = special\n              ? selector\n              : this.compose_selector(coords, selector);\n            this.add_rule(composed, pseudo);\n          });\n\n          break;\n        }\n\n        case 'cond': {\n          let name = token.name.substr(1);\n          let fn = Selector[name];\n          if (fn) {\n            let args = token.arguments.map(arg => {\n              return this.compose_argument(arg, coords);\n            });\n            let cond = this.apply_func(fn, coords, args, name);\n            if (Array.isArray(token.addition)) {\n              for (let c of token.addition) {\n                if (c === 'not') cond = !cond;\n              }\n            }\n            if (cond) {\n              if (cond.selector) {\n                token.styles.forEach(_token => {\n                  if (_token.type === 'rule') {\n                    this.add_rule(\n                      cond.selector.replaceAll('$', this.compose_selector(coords)),\n                      this.compose_rule(_token, coords)\n                    )\n                  }\n                  if (_token.type === 'pseudo') {\n                    _token.selector.split(',').forEach(selector => {\n                      let pseudo = _token.styles.map(s =>\n                        this.compose_rule(s, coords, selector)\n                      );\n                      this.add_rule(\n                        (cond.selector + selector).replaceAll('$', this.compose_selector(coords)),\n                        pseudo\n                      );\n                    });\n                  }\n                });\n              } else {\n                this.compose(coords, token.styles);\n              }\n            }\n          }\n          break;\n        }\n\n        case 'keyframes': {\n          if (!this.keyframes[token.name]) {\n            this.keyframes[token.name] = coords => `\n              ${ join(token.steps.map(step => `\n                ${ step.name } {\n                  ${ join(\n                    step.styles.map(s => this.compose_rule(s, coords))\n                  )}\n                }\n              `)) }\n            `;\n          }\n        }\n      }\n    });\n  }\n\n  output() {\n    for (let [selector, rule] of Object.entries(this.rules)) {\n      if (is_parent_selector(selector)) {\n        this.styles.container += `\n          .container {\n            ${ join(rule) }\n          }\n        `;\n      } else {\n        let target = is_host_selector(selector) ? 'host' : 'cells';\n        let value = join(rule).trim();\n        if (value.length) {\n          let name = (target === 'host') ? `${ selector }, .host` : selector;\n          this.styles[target] += `${ name } { ${ value  } }`;\n        }\n      }\n    }\n\n    if (this.uniforms.time) {\n      this.styles.container += `\n        :host, .host {\n          animation: ${ uniform_time.animation };\n        }\n      `;\n      this.styles.keyframes += `\n       @keyframes ${ uniform_time['animation-name'] } {\n         from { --${ uniform_time.name }: 0 }\n         to { --${ uniform_time.name }: ${ uniform_time['animation-duration'] / 10 } }\n       }\n      `;\n    }\n\n    this.coords.forEach((coords, i) => {\n      for (let [name, keyframe] of Object.entries(this.keyframes)) {\n        let aname = this.compose_aname(name, coords.count);\n        this.styles.keyframes += `\n          ${ maybe(i === 0, `@keyframes ${ name } { ${ keyframe(coords) } }`)}\n          @keyframes ${ aname } {\n            ${ keyframe(coords) }\n          }\n        `;\n      }\n    });\n\n    return {\n      props: this.props,\n      styles: this.styles,\n      grid: this.grid,\n      seed: this.seed,\n      random: this.random,\n      doodles: this.doodles,\n      shaders: this.shaders,\n      canvas: this.canvas,\n      pattern: this.pattern,\n      uniforms: this.uniforms,\n      content: this.content,\n    }\n  }\n\n}\n\nfunction remove_quotes(input) {\n  let remove = (input.startsWith('\"') && input.endsWith('\"'))\n    || (input.startsWith(\"'\") && input.endsWith(\"'\"));\n  if (remove) {\n    return input.substring(1, input.length - 1);\n  }\n  return input;\n}\n\nfunction generate_css(tokens, grid_size, seed_value, max_grid, seed_random) {\n  let rules = new Rules(tokens);\n  let random = seed_random || seedrandom(String(seed_value));\n  let context = {};\n\n  function update_random(seed) {\n    random = seedrandom(String(seed));\n  }\n\n  function rand(start = 0, end) {\n    if (arguments.length == 1) {\n      [start, end] = [0, start];\n    }\n    return lerp(random(), start, end);\n  }\n\n  function pick(...items) {\n    let args = items.reduce((acc, n) => acc.concat(n), []);\n    return args[~~(random() * args.length)];\n  }\n\n  function shuffle(arr) {\n    let ret = [...arr];\n    let m = arr.length;\n    while (m) {\n      let i = ~~(random() * m--);\n      let t = ret[m];\n      ret[m] = ret[i];\n      ret[i] = t;\n    }\n    return ret;\n  }\n\n  rules.pre_compose({\n    x: 1, y: 1, z: 1, count: 1, context: {},\n    grid: { x: 1, y: 1, z: 1, count: 1 },\n    random, rand, pick, shuffle,\n    max_grid, update_random,\n    seed_value,\n    rules,\n  });\n\n  let { grid, seed } = rules.output();\n\n  if (grid) {\n    grid_size = grid;\n  }\n\n  if (seed) {\n    seed = String(seed);\n    random = seedrandom(seed);\n  } else {\n    seed = seed_value;\n  }\n\n  if (is_nil(seed)) {\n    seed = Date.now();\n    random = seedrandom(seed);\n  }\n\n  seed = String(seed);\n  rules.seed = seed;\n  rules.random = random;\n  rules.reset();\n\n  if (grid_size.z == 1) {\n    for (let y = 1, count = 0; y <= grid_size.y; ++y) {\n      for (let x = 1; x <= grid_size.x; ++x) {\n        rules.compose({\n          x, y, z: 1,\n          count: ++count, grid: grid_size, context,\n          rand, pick, shuffle,\n          random, seed,\n          max_grid,\n          rules,\n        });\n      }\n    }\n  }\n  else {\n    for (let z = 1, count = 0; z <= grid_size.z; ++z) {\n      rules.compose({\n        x: 1, y: 1, z,\n        count: ++count, grid: grid_size, context,\n        rand, pick, shuffle,\n        random, seed,\n        max_grid,\n        rules,\n      });\n    }\n  }\n\n  return rules.output();\n}\n\nexport {\n  generate_css,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}