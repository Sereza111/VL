{"ast":null,"code":"import _objectSpread from \"/var/www/www-root/data/www/knigavl.ru/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/var/www/www-root/data/www/knigavl.ru/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"curve\", \"oversample\"];\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) => {\n  return (nativeContext, _ref) => {\n    let {\n        curve,\n        oversample\n      } = _ref,\n      audioNodeOptions = _objectWithoutProperties(_ref, _excluded);\n    const negativeWaveShaperNode = nativeContext.createWaveShaper();\n    const positiveWaveShaperNode = nativeContext.createWaveShaper();\n    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n    const inputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: 1\n    }));\n    const invertGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: -1\n    }));\n    const outputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: 1\n    }));\n    const revertGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: -1\n    }));\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    let unmodifiedCurve = null;\n    const nativeWaveShaperNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n      get channelCount() {\n        return negativeWaveShaperNode.channelCount;\n      },\n      set channelCount(value) {\n        inputGainNode.channelCount = value;\n        invertGainNode.channelCount = value;\n        negativeWaveShaperNode.channelCount = value;\n        outputGainNode.channelCount = value;\n        positiveWaveShaperNode.channelCount = value;\n        revertGainNode.channelCount = value;\n      },\n      get channelCountMode() {\n        return negativeWaveShaperNode.channelCountMode;\n      },\n      set channelCountMode(value) {\n        inputGainNode.channelCountMode = value;\n        invertGainNode.channelCountMode = value;\n        negativeWaveShaperNode.channelCountMode = value;\n        outputGainNode.channelCountMode = value;\n        positiveWaveShaperNode.channelCountMode = value;\n        revertGainNode.channelCountMode = value;\n      },\n      get channelInterpretation() {\n        return negativeWaveShaperNode.channelInterpretation;\n      },\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        invertGainNode.channelInterpretation = value;\n        negativeWaveShaperNode.channelInterpretation = value;\n        outputGainNode.channelInterpretation = value;\n        positiveWaveShaperNode.channelInterpretation = value;\n        revertGainNode.channelInterpretation = value;\n      },\n      get context() {\n        return negativeWaveShaperNode.context;\n      },\n      get curve() {\n        return unmodifiedCurve;\n      },\n      set curve(value) {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        if (value !== null && value.length < 2) {\n          throw createInvalidStateError();\n        }\n        if (value === null) {\n          negativeWaveShaperNode.curve = value;\n          positiveWaveShaperNode.curve = value;\n        } else {\n          const curveLength = value.length;\n          const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          negativeCurve[0] = value[0];\n          positiveCurve[0] = -value[curveLength - 1];\n          const length = Math.ceil((curveLength + 1) / 2);\n          const centerIndex = (curveLength + 1) / 2 - 1;\n          for (let i = 1; i < length; i += 1) {\n            const theoreticIndex = i / length * centerIndex;\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n          }\n          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n          negativeWaveShaperNode.curve = negativeCurve;\n          positiveWaveShaperNode.curve = positiveCurve;\n        }\n        unmodifiedCurve = value;\n        if (isConnected) {\n          if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          } else if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        }\n      },\n      get inputs() {\n        return [inputGainNode];\n      },\n      get numberOfInputs() {\n        return negativeWaveShaperNode.numberOfInputs;\n      },\n      get numberOfOutputs() {\n        return negativeWaveShaperNode.numberOfOutputs;\n      },\n      get oversample() {\n        return negativeWaveShaperNode.oversample;\n      },\n      set oversample(value) {\n        negativeWaveShaperNode.oversample = value;\n        positiveWaveShaperNode.oversample = value;\n      },\n      addEventListener() {\n        return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      dispatchEvent() {\n        return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener() {\n        return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n    if (curve !== null) {\n      // Only values of type Float32Array can be assigned to the curve property.\n      nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n    }\n    if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n      nativeWaveShaperNodeFaker.oversample = oversample;\n    }\n    const whenConnected = () => {\n      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n      isConnected = true;\n      if (isDCCurve(unmodifiedCurve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n      }\n    };\n    const whenDisconnected = () => {\n      inputGainNode.disconnect(negativeWaveShaperNode);\n      negativeWaveShaperNode.disconnect(outputGainNode);\n      inputGainNode.disconnect(invertGainNode);\n      invertGainNode.disconnect(positiveWaveShaperNode);\n      positiveWaveShaperNode.disconnect(revertGainNode);\n      revertGainNode.disconnect(outputGainNode);\n      isConnected = false;\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n    return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"names":["assignNativeAudioNodeOptions","interceptConnections","createNativeWaveShaperNodeFakerFactory","createConnectedNativeAudioBufferSourceNode","createInvalidStateError","createNativeGainNode","isDCCurve","monitorConnections","nativeContext","_ref","curve","oversample","audioNodeOptions","_objectWithoutProperties","_excluded","negativeWaveShaperNode","createWaveShaper","positiveWaveShaperNode","inputGainNode","_objectSpread","gain","invertGainNode","outputGainNode","revertGainNode","disconnectNativeAudioBufferSourceNode","isConnected","unmodifiedCurve","nativeWaveShaperNodeFaker","bufferSize","undefined","channelCount","value","channelCountMode","channelInterpretation","context","length","curveLength","negativeCurve","Float32Array","positiveCurve","Math","ceil","centerIndex","i","theoreticIndex","lowerIndex","floor","upperIndex","inputs","numberOfInputs","numberOfOutputs","addEventListener","arguments","dispatchEvent","removeEventListener","whenConnected","connect","whenDisconnected","disconnect"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-faker-factory.ts"],"sourcesContent":["import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeWaveShaperNode, TNativeWaveShaperNodeFakerFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFakerFactory: TNativeWaveShaperNodeFakerFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n        let unmodifiedCurve: null | TNativeWaveShaperNode['curve'] = null;\n\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeWaveShaperNode['channelCountMode'] {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeWaveShaperNode['channelInterpretation'] {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeWaveShaperNode['context'] {\n                return negativeWaveShaperNode.context;\n            },\n            get curve(): TNativeWaveShaperNode['curve'] {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                } else {\n                    const curveLength = value.length;\n\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                  (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n\n                unmodifiedCurve = value;\n\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample(): TNativeWaveShaperNode['oversample'] {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n\n            isConnected = true;\n\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}