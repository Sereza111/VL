{"ast":null,"code":"/**\n * Based on the Shunting-yard algorithm.\n */\n\nimport { last } from './utils/list.js';\nimport { is_invalid_number } from './utils/index.js';\nconst cache = new Map();\nconst default_context = {\n  'π': Math.PI,\n  gcd: (a, b) => {\n    while (b) [a, b] = [b, a % b];\n    return a;\n  }\n};\nconst operator = {\n  '^': 7,\n  '*': 6,\n  '/': 6,\n  '÷': 6,\n  '%': 6,\n  '&': 5,\n  '|': 5,\n  '+': 4,\n  '-': 4,\n  '<': 3,\n  '<<': 3,\n  '>': 3,\n  '>>': 3,\n  '=': 3,\n  '==': 3,\n  '≤': 3,\n  '<=': 3,\n  '≥': 3,\n  '>=': 3,\n  '≠': 3,\n  '!=': 3,\n  '∧': 2,\n  '&&': 2,\n  '∨': 2,\n  '||': 2,\n  '(': 1,\n  ')': 1\n};\nfunction calc(expr, context) {\n  let repeat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let stack = [];\n  while (expr.length) {\n    let {\n      name,\n      value,\n      type\n    } = expr.shift();\n    if (type === 'variable') {\n      let result = context[value];\n      if (is_invalid_number(result)) {\n        result = Math[value];\n      }\n      if (is_invalid_number(result)) {\n        result = expand(value, context, repeat);\n      }\n      if (is_invalid_number(result)) {\n        if (/^\\-\\D/.test(value)) {\n          result = expand('-1' + value.substr(1), context, repeat);\n        }\n      }\n      if (result === undefined) {\n        result = 0;\n      }\n      if (typeof result !== 'number') {\n        repeat.push(result);\n        if (is_cycle(repeat)) {\n          result = 0;\n          repeat = [];\n        } else {\n          result = calc(infix_to_postfix(result), context, repeat);\n        }\n      }\n      stack.push(result);\n    } else if (type === 'function') {\n      let negative = false;\n      if (/^\\-/.test(name)) {\n        negative = true;\n        name = name.substr(1);\n      }\n      let output = value.map(v => calc(v, context, repeat));\n      let fns = name.split('.');\n      let fname;\n      while (fname = fns.pop()) {\n        if (!fname) continue;\n        let fn = context[fname] || Math[fname];\n        output = typeof fn === 'function' ? Array.isArray(output) ? fn(...output) : fn(output) : 0;\n      }\n      if (negative) {\n        output = -1 * output;\n      }\n      stack.push(output);\n    } else {\n      if (/\\d+/.test(value)) stack.push(value);else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(value, Number(left), Number(right)));\n      }\n    }\n  }\n  return Number(stack[0]) || 0;\n}\nfunction get_tokens(input) {\n  if (cache.has(input)) {\n    return cache.get(input);\n  }\n  let expr = String(input);\n  let tokens = [],\n    num = '';\n  for (let i = 0; i < expr.length; ++i) {\n    let c = expr[i];\n    if (operator[c]) {\n      let last_token = last(tokens);\n      if (c == '=' && last_token && /^[!<>=]$/.test(last_token.value)) {\n        last_token.value += c;\n      } else if (/^[|&<>]$/.test(c) && last_token && last_token.value == c) {\n        last_token.value += c;\n      } else if (c == '-' && expr[i - 1] == 'e') {\n        num += c;\n      } else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n        num += c;\n      } else {\n        let {\n          type,\n          value\n        } = last_token || {};\n        if (type == 'operator' && !num.length && /[^()]/.test(c) && /[^()]/.test(value)) {\n          num += c;\n        } else {\n          if (num.length) {\n            tokens.push({\n              type: 'number',\n              value: num\n            });\n            num = '';\n          }\n          tokens.push({\n            type: 'operator',\n            value: c\n          });\n        }\n      }\n    } else if (/\\S/.test(c)) {\n      if (c == ',') {\n        tokens.push({\n          type: 'number',\n          value: num\n        });\n        num = '';\n        tokens.push({\n          type: 'comma',\n          value: c\n        });\n      } else if (c == '!') {\n        tokens.push({\n          type: 'number',\n          value: num\n        });\n        tokens.push({\n          type: 'operator',\n          value: c\n        });\n        num = '';\n      } else {\n        num += c;\n      }\n    }\n  }\n  if (num.length) {\n    tokens.push({\n      type: 'number',\n      value: num\n    });\n  }\n  cache.set(input, tokens);\n  return tokens;\n}\nfunction infix_to_postfix(input) {\n  let tokens = get_tokens(input);\n  const op_stack = [],\n    expr = [];\n  for (let i = 0; i < tokens.length; ++i) {\n    let {\n      type,\n      value\n    } = tokens[i];\n    let next = tokens[i + 1] || {};\n    if (type == 'number') {\n      if (next.value == '(' && /[^\\d.\\-]/.test(value)) {\n        let func_body = '';\n        let stack = [];\n        let values = [];\n        i += 1;\n        while (tokens[i++] !== undefined) {\n          let token = tokens[i];\n          if (token === undefined) break;\n          let c = token.value;\n          if (c == ')') {\n            if (!stack.length) break;\n            stack.pop();\n            func_body += c;\n          } else {\n            if (c == '(') stack.push(c);\n            if (c == ',' && !stack.length) {\n              let arg = infix_to_postfix(func_body);\n              if (arg.length) values.push(arg);\n              func_body = '';\n            } else {\n              func_body += c;\n            }\n          }\n        }\n        if (func_body.length) {\n          values.push(infix_to_postfix(func_body));\n        }\n        expr.push({\n          type: 'function',\n          name: value,\n          value: values\n        });\n      } else if (/[^\\d.\\-]/.test(value)) {\n        expr.push({\n          type: 'variable',\n          value\n        });\n      } else {\n        expr.push({\n          type: 'number',\n          value\n        });\n      }\n    } else if (type == 'operator') {\n      if (value == '(') {\n        op_stack.push(value);\n      } else if (value == ')') {\n        while (op_stack.length && last(op_stack) != '(') {\n          expr.push({\n            type: 'operator',\n            value: op_stack.pop()\n          });\n        }\n        op_stack.pop();\n      } else {\n        while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n          let op = op_stack.pop();\n          if (!/[()]/.test(op)) expr.push({\n            type: 'operator',\n            value: op\n          });\n        }\n        op_stack.push(value);\n      }\n    }\n  }\n  while (op_stack.length) {\n    expr.push({\n      type: 'operator',\n      value: op_stack.pop()\n    });\n  }\n  return expr;\n}\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+':\n      return a + b;\n    case '-':\n      return a - b;\n    case '*':\n      return a * b;\n    case '%':\n      return a % b;\n    case '|':\n      return a | b;\n    case '&':\n      return a & b;\n    case '<':\n      return a < b;\n    case '>':\n      return a > b;\n    case '^':\n      return Math.pow(a, b);\n    case '÷':\n    case '/':\n      return a / b;\n    case '=':\n    case '==':\n      return a == b;\n    case '≤':\n    case '<=':\n      return a <= b;\n    case '≥':\n    case '>=':\n      return a >= b;\n    case '≠':\n    case '!=':\n      return a != b;\n    case '∧':\n    case '&&':\n      return a && b;\n    case '∨':\n    case '||':\n      return a || b;\n    case '<<':\n      return a << b;\n    case '>>':\n      return a >> b;\n  }\n}\nfunction expand(value, context, repeat) {\n  let [_, num, variable] = value.match(/([\\d.\\-]+)(.*)/) || [];\n  let v = context[variable];\n  if (v === undefined) {\n    return v;\n  }\n  if (typeof v === 'number') {\n    return Number(num) * v;\n  } else {\n    repeat.push(v);\n    if (is_cycle(repeat)) {\n      repeat = [];\n      return 0;\n    } else {\n      return num * calc(infix_to_postfix(v), context, repeat);\n    }\n  }\n}\nfunction is_cycle(array) {\n  if (array.length > 50) return true;\n  let tail = last(array);\n  for (let i = 2; i <= 4; ++i) {\n    let item = array[array.length - i];\n    if (item === undefined) return false;\n    if (tail !== item) return false;\n  }\n  return true;\n}\nexport default function (input, context) {\n  const expr = infix_to_postfix(input);\n  return calc(expr, Object.assign({}, default_context, context));\n}","map":{"version":3,"names":["last","is_invalid_number","cache","Map","default_context","Math","PI","gcd","a","b","operator","calc","expr","context","repeat","arguments","length","undefined","stack","name","value","type","shift","result","expand","test","substr","push","is_cycle","infix_to_postfix","negative","output","map","v","fns","split","fname","pop","fn","Array","isArray","right","left","compute","Number","get_tokens","input","has","get","String","tokens","num","i","c","last_token","set","op_stack","next","func_body","values","token","arg","op","pow","_","variable","match","array","tail","item","Object","assign"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/calc.js"],"sourcesContent":["/**\n * Based on the Shunting-yard algorithm.\n */\n\nimport { last } from './utils/list.js';\nimport { is_invalid_number } from './utils/index.js';\n\nconst cache = new Map();\n\nconst default_context = {\n  'π': Math.PI,\n  gcd: (a, b) => {\n    while (b) [a, b] = [b, a % b];\n    return a;\n  }\n}\n\nconst operator = {\n  '^': 7,\n  '*': 6, '/': 6, '÷': 6, '%': 6,\n  '&': 5, '|': 5,\n  '+': 4, '-': 4,\n  '<': 3, '<<': 3,\n  '>': 3, '>>': 3,\n  '=': 3, '==': 3,\n  '≤': 3, '<=': 3,\n  '≥': 3, '>=': 3,\n  '≠': 3, '!=': 3,\n  '∧': 2, '&&': 2,\n  '∨': 2, '||': 2,\n  '(': 1 , ')': 1,\n}\n\nfunction calc(expr, context, repeat = []) {\n  let stack = [];\n  while (expr.length) {\n    let { name, value, type } = expr.shift();\n    if (type === 'variable') {\n      let result = context[value];\n      if (is_invalid_number(result)) {\n        result = Math[value];\n      }\n      if (is_invalid_number(result)) {\n        result = expand(value, context, repeat);\n      }\n      if (is_invalid_number(result)) {\n        if (/^\\-\\D/.test(value)) {\n          result = expand('-1' + value.substr(1), context, repeat);\n        }\n      }\n      if (result === undefined) {\n        result = 0;\n      }\n      if (typeof result !== 'number') {\n        repeat.push(result);\n        if (is_cycle(repeat)) {\n          result = 0;\n          repeat = [];\n        } else {\n          result = calc(infix_to_postfix(result), context, repeat)\n        }\n      }\n      stack.push(result);\n    }\n    else if (type === 'function') {\n      let negative = false;\n      if (/^\\-/.test(name)) {\n        negative = true;\n        name = name.substr(1);\n      }\n      let output = value.map(v => calc(v, context, repeat));\n      let fns = name.split('.');\n      let fname;\n      while (fname = fns.pop()) {\n        if (!fname) continue;\n        let fn = context[fname] || Math[fname];\n        output = (typeof fn === 'function')\n          ? (Array.isArray(output) ? fn(...output) : fn(output))\n          : 0;\n      }\n      if (negative) {\n        output = -1 * output;\n      }\n      stack.push(output);\n    } else {\n      if (/\\d+/.test(value)) stack.push(value);\n      else {\n        let right = stack.pop();\n        let left = stack.pop();\n        stack.push(compute(\n          value, Number(left), Number(right)\n        ));\n      }\n    }\n  }\n  return Number(stack[0]) || 0;\n}\n\nfunction get_tokens(input) {\n  if (cache.has(input)) {\n    return cache.get(input);\n  }\n  let expr = String(input);\n  let tokens = [], num = '';\n\n  for (let i = 0; i < expr.length; ++i) {\n    let c = expr[i];\n    if (operator[c]) {\n      let last_token = last(tokens);\n      if (c == '=' && last_token && /^[!<>=]$/.test(last_token.value)) {\n        last_token.value += c;\n      }\n      else if (/^[|&<>]$/.test(c) && last_token && last_token.value == c) {\n        last_token.value += c;\n      }\n      else if (c == '-' && expr[i - 1] == 'e') {\n        num += c;\n      }\n      else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n        num += c;\n      } else {\n        let { type, value } = last_token || {};\n        if (type == 'operator'\n            && !num.length\n            && /[^()]/.test(c)\n            && /[^()]/.test(value)) {\n          num += c;\n        } else {\n          if (num.length) {\n            tokens.push({ type: 'number', value: num });\n            num = '';\n          }\n          tokens.push({ type: 'operator', value: c });\n        }\n      }\n    }\n    else if (/\\S/.test(c)) {\n      if (c == ',') {\n        tokens.push({ type: 'number', value: num });\n        num = '';\n        tokens.push({ type: 'comma', value: c });\n      } else if (c == '!') {\n        tokens.push({ type: 'number', value: num });\n        tokens.push({ type: 'operator', value: c });\n        num = '';\n      } else {\n        num += c;\n      }\n    }\n  }\n\n  if (num.length) {\n    tokens.push({ type: 'number', value: num });\n  }\n  cache.set(input, tokens);\n  return tokens;\n}\n\nfunction infix_to_postfix(input) {\n  let tokens = get_tokens(input);\n  const op_stack = [], expr = [];\n\n  for (let i = 0; i < tokens.length; ++i) {\n    let { type, value } = tokens[i];\n    let next = tokens[i + 1] || {};\n    if (type == 'number') {\n      if (next.value == '(' && /[^\\d.\\-]/.test(value)) {\n        let func_body = '';\n        let stack = [];\n        let values = [];\n\n        i += 1;\n        while (tokens[i++] !== undefined) {\n          let token = tokens[i];\n          if (token === undefined) break;\n          let c = token.value;\n          if (c == ')') {\n            if (!stack.length) break;\n            stack.pop();\n            func_body += c;\n          }\n          else {\n            if (c == '(') stack.push(c);\n            if (c == ',' && !stack.length) {\n              let arg = infix_to_postfix(func_body);\n              if (arg.length) values.push(arg);\n              func_body = '';\n            } else {\n              func_body += c;\n            }\n          }\n        }\n\n        if (func_body.length) {\n          values.push(infix_to_postfix(func_body));\n        }\n\n        expr.push({\n          type: 'function',\n          name: value,\n          value: values\n        });\n      }\n      else if (/[^\\d.\\-]/.test(value)) {\n        expr.push({ type: 'variable', value });\n      }\n      else {\n        expr.push({ type: 'number', value });\n      }\n    }\n\n    else if (type == 'operator') {\n      if (value == '(') {\n        op_stack.push(value);\n      }\n\n      else if (value == ')') {\n        while (op_stack.length && last(op_stack) != '(') {\n          expr.push({ type: 'operator', value: op_stack.pop() });\n        }\n        op_stack.pop();\n      }\n\n      else {\n        while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n          let op = op_stack.pop();\n          if (!/[()]/.test(op)) expr.push({ type: 'operator', value: op });\n        }\n        op_stack.push(value);\n      }\n    }\n  }\n\n  while (op_stack.length) {\n    expr.push({ type: 'operator', value: op_stack.pop() });\n  }\n\n  return expr;\n}\n\nfunction compute(op, a, b) {\n  switch (op) {\n    case '+': return a + b;\n    case '-': return a - b;\n    case '*': return a * b;\n    case '%': return a % b;\n    case '|': return a | b;\n    case '&': return a & b;\n    case '<': return a < b;\n    case '>': return a > b;\n    case '^': return Math.pow(a, b);\n    case '÷': case '/': return a / b;\n    case '=': case '==': return a == b;\n    case '≤': case '<=': return a <= b;\n    case '≥': case '>=': return a >= b;\n    case '≠': case '!=': return a != b;\n    case '∧': case '&&': return a && b;\n    case '∨': case '||': return a || b;\n    case '<<': return a << b;\n    case '>>': return a >> b;\n  }\n}\n\nfunction expand(value, context, repeat) {\n  let [_, num, variable] = value.match(/([\\d.\\-]+)(.*)/) || [];\n  let v = context[variable];\n  if (v === undefined) {\n    return v;\n  }\n  if (typeof v === 'number') {\n    return Number(num) * v;\n  } else {\n    repeat.push(v);\n    if (is_cycle(repeat)) {\n      repeat = [];\n      return 0;\n    } else {\n      return num * calc(infix_to_postfix(v), context, repeat);\n    }\n  }\n}\n\nfunction is_cycle(array) {\n  if (array.length > 50) return true;\n  let tail = last(array);\n  for (let i = 2; i <= 4; ++i) {\n    let item = array[array.length - i];\n    if (item === undefined) return false;\n    if (tail !== item) return false;\n  }\n  return true;\n}\n\nexport default function(input, context) {\n  const expr = infix_to_postfix(input);\n  return calc(expr, Object.assign({}, default_context, context));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}