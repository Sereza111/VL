{"ast":null,"code":"import Cache from '../utils/cache.js';\nimport parse_pattern from '../parser/parse-pattern.js';\nimport { get_grid } from '../utils/index.js';\nfunction generate_shader(input, grid) {\n  return \"\\n    vec3 mapping(vec2 uv, vec2 grid) {\\n      vec2 _grid = 1.0/grid;\\n      float x = ceil(uv.x/_grid.x);\\n      float y = ceil(grid.y - uv.y/_grid.y);\\n      float i = x + (y - 1.0) * y;\\n      return vec3(x, y, i);\\n    }\\n    vec4 getColor(float x, float y, float i, float I, float X, float Y, float t) {\\n      vec4 color = vec4(0, 0, 0, 0);\\n      \".concat(input, \"\\n      return color;\\n    }\\n    void main() {\\n      vec2 uv = gl_FragCoord.xy/u_resolution.xy;\\n      vec2 grid = vec2(\").concat(grid.x, \", \").concat(grid.y, \");\\n      vec3 p = mapping(uv, grid);\\n      FragColor = getColor(p.x, p.y, p.z, grid.x * grid.y, grid.x, grid.y, u_time);\\n    }\\n  \");\n}\nfunction generate_statement(token, extra) {\n  if (token.name === 'fill') {\n    let {\n      r,\n      g,\n      b,\n      a\n    } = extra.get_rgba_color(token.value);\n    return {\n      type: 'statement',\n      value: \"\\ncolor = vec4(\".concat(float(r / 255), \", \").concat(float(g / 255), \", \").concat(float(b / 255), \", \").concat(float(a), \");\\n\")\n    };\n  }\n  if (token.name == 'grid') {\n    return {\n      type: 'grid',\n      value: token.value\n    };\n  }\n  return {\n    type: 'statement',\n    value: ''\n  };\n}\nfunction generate_block(token, extra) {\n  if (token.name === 'match') {\n    let cond = token.args[0];\n    let values = [];\n    token.value.forEach(t => {\n      let statement = generate_statement(t, extra);\n      if (statement.type == 'statement') {\n        values.push(statement.value);\n      }\n    });\n    return \"\\n      if (\".concat(cond, \") {\\n        \").concat(values.join(''), \"\\n      }\\n    \");\n  }\n  return '';\n}\nfunction float(n) {\n  return String(n).includes('.') ? n : n + '.0';\n}\nfunction draw_pattern(code, extra) {\n  let tokens = parse_pattern(code);\n  let result = [];\n  let grid = {\n    x: 1,\n    y: 1\n  };\n  tokens.forEach(token => {\n    if (token.type === 'statement') {\n      let statement = generate_statement(token, extra);\n      if (statement.type == 'statement') {\n        result.push(statement.value);\n      }\n      if (statement.type === 'grid') {\n        grid = get_grid(statement.value);\n      }\n    } else if (token.type === 'block') {\n      result.push(generate_block(token, extra));\n    }\n  });\n  return generate_shader(result.join(''), grid);\n}\nexport { draw_pattern };","map":{"version":3,"names":["Cache","parse_pattern","get_grid","generate_shader","input","grid","concat","x","y","generate_statement","token","extra","name","r","g","b","a","get_rgba_color","value","type","float","generate_block","cond","args","values","forEach","t","statement","push","join","n","String","includes","draw_pattern","code","tokens","result"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/generator/pattern.js"],"sourcesContent":["import Cache from '../utils/cache.js';\nimport parse_pattern from '../parser/parse-pattern.js';\nimport { get_grid } from '../utils/index.js';\n\nfunction generate_shader(input, grid) {\n  return `\n    vec3 mapping(vec2 uv, vec2 grid) {\n      vec2 _grid = 1.0/grid;\n      float x = ceil(uv.x/_grid.x);\n      float y = ceil(grid.y - uv.y/_grid.y);\n      float i = x + (y - 1.0) * y;\n      return vec3(x, y, i);\n    }\n    vec4 getColor(float x, float y, float i, float I, float X, float Y, float t) {\n      vec4 color = vec4(0, 0, 0, 0);\n      ${input}\n      return color;\n    }\n    void main() {\n      vec2 uv = gl_FragCoord.xy/u_resolution.xy;\n      vec2 grid = vec2(${grid.x}, ${grid.y});\n      vec3 p = mapping(uv, grid);\n      FragColor = getColor(p.x, p.y, p.z, grid.x * grid.y, grid.x, grid.y, u_time);\n    }\n  `;\n}\n\nfunction generate_statement(token, extra) {\n  if (token.name === 'fill') {\n    let {r, g, b, a} = extra.get_rgba_color(token.value);\n    return {\n      type: 'statement',\n      value: `\\ncolor = vec4(${float(r/255)}, ${float(g/255)}, ${float(b/255)}, ${float(a)});\\n`,\n    }\n  }\n  if (token.name == 'grid') {\n    return {\n      type: 'grid',\n      value: token.value,\n    }\n  }\n  return {\n    type: 'statement',\n    value: ''\n  }\n}\n\nfunction generate_block(token, extra) {\n  if (token.name === 'match') {\n    let cond = token.args[0];\n    let values = [];\n    token.value.forEach(t => {\n      let statement = generate_statement(t, extra);\n      if (statement.type == 'statement') {\n        values.push(statement.value);\n      }\n    });\n    return `\n      if (${cond}) {\n        ${values.join('')}\n      }\n    `\n  }\n  return '';\n}\n\nfunction float(n) {\n  return String(n).includes('.') ? n : n + '.0';\n}\n\nfunction draw_pattern(code, extra) {\n  let tokens = parse_pattern(code);\n  let result = [];\n  let grid = {x: 1, y: 1 };\n  tokens.forEach(token => {\n    if (token.type === 'statement') {\n      let statement = generate_statement(token, extra);\n      if (statement.type == 'statement') {\n        result.push(statement.value);\n      }\n      if (statement.type === 'grid') {\n        grid = get_grid(statement.value);\n      }\n    } else if (token.type === 'block') {\n      result.push(generate_block(token, extra));\n    }\n  });\n  return generate_shader(result.join(''), grid);\n}\n\nexport {\n  draw_pattern,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}