{"ast":null,"code":"// I need to rewrite this\n\nimport parse_var from './parse-var.js';\nimport parse_svg from './parse-svg.js';\nimport { generate_svg_extended } from '../generator/svg-extended.js';\nimport { first, last, clone } from '../utils/list.js';\nconst Tokens = {\n  func() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'func',\n      name,\n      arguments: []\n    };\n  },\n  argument() {\n    return {\n      type: 'argument',\n      value: []\n    };\n  },\n  text() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'text',\n      value\n    };\n  },\n  pseudo() {\n    let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'pseudo',\n      selector,\n      styles: []\n    };\n  },\n  cond() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'cond',\n      name,\n      styles: [],\n      arguments: []\n    };\n  },\n  rule() {\n    let property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'rule',\n      property,\n      value: []\n    };\n  },\n  keyframes() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'keyframes',\n      name,\n      steps: []\n    };\n  },\n  step() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return {\n      type: 'step',\n      name,\n      styles: []\n    };\n  }\n};\nconst is = {\n  white_space(c) {\n    return /[\\s\\n\\t]/.test(c);\n  },\n  line_break(c) {\n    return /\\n/.test(c);\n  },\n  number(n) {\n    return !isNaN(n);\n  },\n  pair(n) {\n    return ['\"', '(', ')', \"'\"].includes(n);\n  },\n  pair_of(c, n) {\n    return {\n      '\"': '\"',\n      \"'\": \"'\",\n      '(': ')'\n    }[c] == n;\n  }\n};\n\n// This should not be in the parser\n// but I'll leave it here until the rewriting\nconst symbols = {\n  'π': Math.PI,\n  '∏': Math.PI\n};\nfunction composible(name) {\n  return /^@(canvas|shaders|doodle)/.test(name);\n}\nfunction iterator() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let index = 0,\n    col = 1,\n    line = 1;\n  return {\n    curr() {\n      let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return input[index + n];\n    },\n    end() {\n      return input.length <= index;\n    },\n    info() {\n      return {\n        index,\n        col,\n        line\n      };\n    },\n    index(n) {\n      return n === undefined ? index : index = n;\n    },\n    range(start, end) {\n      return input.substring(start, end);\n    },\n    next() {\n      let next = input[index++];\n      if (next == '\\n') line++, col = 0;else col++;\n      return next;\n    }\n  };\n}\nfunction throw_error(msg, _ref) {\n  let {\n    col,\n    line\n  } = _ref;\n  console.warn(\"(at line \".concat(line, \", column \").concat(col, \") \").concat(msg));\n}\nfunction get_text_value(input) {\n  if (input.trim().length) {\n    return is.number(+input) ? +input : input.trim();\n  } else {\n    return input;\n  }\n}\nfunction read_until(fn) {\n  return function (it, reset) {\n    let index = it.index();\n    let word = '';\n    while (!it.end()) {\n      let c = it.next();\n      if (fn(c)) break;else word += c;\n    }\n    if (reset) {\n      it.index(index);\n    }\n    return word;\n  };\n}\nfunction read_word(it, reset) {\n  let check = c => /[^\\w@]/.test(c);\n  return read_until(check)(it, reset);\n}\nfunction read_keyframe_name(it) {\n  return read_until(c => /[\\s\\{]/.test(c))(it);\n}\nfunction read_line(it, reset) {\n  let check = c => is.line_break(c) || c == '{';\n  return read_until(check)(it, reset);\n}\nfunction read_step(it, extra) {\n  let c,\n    step = Tokens.step();\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else if (!step.name.length) {\n      step.name = read_selector(it);\n    } else {\n      step.styles.push(read_rule(it, extra));\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return step;\n}\nfunction read_steps(it, extra) {\n  const steps = [];\n  let c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;else if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else {\n      steps.push(read_step(it, extra));\n    }\n    it.next();\n  }\n  return steps;\n}\nfunction read_keyframes(it, extra) {\n  let keyframes = Tokens.keyframes(),\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;else if (!keyframes.name.length) {\n      read_word(it);\n      keyframes.name = read_keyframe_name(it);\n      if (!keyframes.name.length) {\n        throw_error('missing keyframes name', it.info());\n        break;\n      }\n      continue;\n    } else if (c == '{' || it.curr(-1) == '{') {\n      it.next();\n      keyframes.steps = read_steps(it, extra);\n      break;\n    }\n    it.next();\n  }\n  return keyframes;\n}\nfunction read_comments(it) {\n  let flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  it.next();\n  while (!it.end()) {\n    let c = it.curr();\n    if (flag.inline) {\n      if (c == '\\n') break;\n    } else {\n      if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n    }\n    it.next();\n  }\n  if (!flag.inline) {\n    it.next();\n    it.next();\n  }\n}\nfunction skip_tag(it) {\n  it.next();\n  while (!it.end()) {\n    let c = it.curr();\n    if (c == '>') break;\n    it.next();\n  }\n}\nfunction read_property(it) {\n  let prop = '',\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == ':') break;else if (!is.white_space(c)) prop += c;\n    it.next();\n  }\n  return prop;\n}\nfunction read_arguments(it, composition, doodle) {\n  let variables = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let args = [],\n    group = [],\n    stack = [],\n    arg = '',\n    c;\n  let raw = '';\n  while (!it.end()) {\n    c = it.curr();\n    let prev = it.curr(-1);\n    let start = it.index();\n    if (/[\\('\"`]/.test(c) && prev !== '\\\\') {\n      if (stack.length) {\n        /*\n        if ((c !== '(') && last(stack) === '(') {\n          stack.pop();\n        }\n        */\n        if (c !== '(' && c === last(stack)) {\n          stack.pop();\n        } else {\n          stack.push(c);\n        }\n      } else {\n        stack.push(c);\n      }\n      arg += c;\n    } else if (!doodle && (c == '@' || c === '$' || prev === '.' && composition)) {\n      if (!group.length) {\n        arg = arg.trimLeft();\n      }\n      if (arg.length) {\n        group.push(Tokens.text(arg));\n        arg = '';\n      }\n      group.push(read_func(it, variables));\n    } else if (doodle && /[)]/.test(c) || !doodle && /[,)]/.test(c)) {\n      if (stack.length) {\n        if (c == ')' && last(stack) === '(') {\n          stack.pop();\n        }\n        arg += c;\n      } else {\n        if (arg.length) {\n          if (!group.length) {\n            group.push(Tokens.text(get_text_value(arg)));\n          } else if (/\\S/.test(arg)) {\n            group.push(Tokens.text(arg));\n          }\n          if (arg.startsWith('±') && !doodle) {\n            let raw = arg.substr(1);\n            let cloned = clone(group);\n            last(cloned).value = '-' + raw;\n            args.push(normalize_argument(cloned));\n            last(group).value = raw;\n          }\n        }\n        args.push(normalize_argument(group));\n        [group, arg] = [[], ''];\n        if (c == ')') break;\n      }\n    } else {\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      arg += c;\n    }\n    if (composition && (it.curr(1) == ')' || it.curr(1) == ';' || !/[0-9a-zA-Z_\\-.]/.test(it.curr())) && !stack.length) {\n      if (group.length) {\n        args.push(normalize_argument(group));\n      }\n      break;\n    } else {\n      raw += it.range(start, it.index() + 1);\n      it.next();\n    }\n  }\n  return [skip_last_empty_args(args), raw];\n}\nfunction skip_last_empty_args(args) {\n  let arg = last(args[0]);\n  if (arg && arg.type === 'text' && !String(arg.value).trim().length) {\n    args[0] = args[0].slice(0, -1);\n  }\n  return args;\n}\nfunction normalize_argument(group) {\n  let result = group.map(arg => {\n    if (arg.type == 'text' && typeof arg.value == 'string') {\n      let value = String(arg.value);\n      if (value.includes('`')) {\n        arg.value = value = value.replace(/`/g, '\"');\n      }\n      arg.value = value;\n    }\n    return arg;\n  });\n  let ft = first(result) || {};\n  let ed = last(result) || {};\n  if (ft.type == 'text' && ed.type == 'text') {\n    let cf = first(ft.value);\n    let ce = last(ed.value);\n    if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n      if (is.pair_of(cf, ce)) {\n        ft.value = ft.value.slice(1);\n        ed.value = ed.value.slice(0, ed.value.length - 1);\n        result.cluster = true;\n      }\n    }\n  }\n  return result;\n}\nfunction seperate_func_name(name) {\n  let fname = '',\n    extra = '';\n  if (/\\D$/.test(name) && !/\\d+[x-]\\d+/.test(name) || Math[name.substr(1)]) {\n    return {\n      fname: name,\n      extra\n    };\n  }\n  for (let i = name.length - 1; i >= 0; i--) {\n    let c = name[i];\n    let prev = name[i - 1];\n    let next = name[i + 1];\n    if (/[\\d.]/.test(c) || (c == 'x' || c == '-') && /\\d/.test(prev) && /\\d/.test(next)) {\n      extra = c + extra;\n    } else {\n      fname = name.substring(0, i + 1);\n      break;\n    }\n  }\n  return {\n    fname,\n    extra\n  };\n}\nfunction has_times_syntax(token) {\n  let str = JSON.stringify(token);\n  return str.includes('pureName') && str.includes('times');\n}\nfunction is_svg(name) {\n  return /^@svg$/i.test(name);\n}\nfunction read_func(it) {\n  let variables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let func = Tokens.func();\n  let name = it.curr(),\n    c;\n  let has_argument = false;\n  let is_calc = name === '$';\n  ;\n  if (name === '@') {\n    it.next();\n  } else {\n    name = '@';\n  }\n  while (!it.end()) {\n    c = it.curr();\n    let next = it.curr(1);\n    let composition = c == '.' && /[a-zA-Z@$]/.test(next);\n    if (c == '(' || composition) {\n      has_argument = true;\n      it.next();\n      let [args, raw_args] = read_arguments(it, composition, composible(name), variables);\n      if (is_svg(name)) {\n        let parsed_svg = parse_svg(raw_args);\n        let line = 0;\n        for (let item of parsed_svg.value) {\n          if (item.variable) {\n            variables[item.name] = parse(\"\".concat('\\n'.repeat(line++), \" \").concat(item.name, \": \").concat(item.value))[0].value;\n          }\n        }\n        if (/\\d\\s*{/.test(raw_args) && has_times_syntax(parsed_svg)) {\n          let svg = generate_svg_extended(parsed_svg);\n          // compatible with old iterator\n          svg += ')';\n          let extended = read_arguments(iterator(svg), composition, composible(name), variables);\n          args = extended[0];\n        }\n      }\n      func.arguments = args;\n      func.variables = variables;\n      break;\n    } else if (/[0-9a-zA-Z_\\-.%]/.test(c)) {\n      name += c;\n    }\n    if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.%]/.test(next)) {\n      break;\n    }\n    it.next();\n  }\n  let {\n    fname,\n    extra\n  } = seperate_func_name(name);\n  func.name = is_calc ? '@$' + name.substr(1) : fname;\n  if (extra.length) {\n    func.arguments.unshift([{\n      type: 'text',\n      value: extra\n    }]);\n  }\n  if (is_calc && func.name.length > 2) {\n    if (!func.arguments.length) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments.push([{\n        type: 'text',\n        value: value\n      }]);\n    }\n    if (/\\d$/.test(func.name)) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments[0][0].value = value;\n    }\n  }\n  func.position = it.info().index;\n  return func;\n}\nfunction read_value(it) {\n  let text = Tokens.text(),\n    idx = 0,\n    skip = true,\n    c;\n  const value = [];\n  value[idx] = [];\n  let stack = [],\n    quote_stack = [];\n  while (!it.end()) {\n    c = it.curr();\n    if (skip && is.white_space(c)) {\n      it.next();\n      continue;\n    } else {\n      skip = false;\n    }\n    if (c == '\\n' && !is.white_space(it.curr(-1))) {\n      text.value += ' ';\n    } else if (c == ',' && !stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[++idx] = [];\n      skip = true;\n    } else if (/[;}<]/.test(c) && !quote_stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      break;\n    } else if ((c === '@' || c === '$') && /[\\w-\\(%]/.test(it.curr(1))) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[idx].push(read_func(it));\n    } else if (c === '\"' || c === \"'\") {\n      let quote = last(quote_stack);\n      if (c === quote) {\n        quote_stack.pop();\n      } else if (!quote_stack.length) {\n        quote_stack.push(c);\n      }\n      text.value += c;\n    } else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n      if (c == '(') stack.push(c);\n      if (c == ')') stack.pop();\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      text.value += c;\n    }\n    if ((it.curr() === ';' || it.curr() == '}') && !quote_stack.length) {\n      break;\n    }\n    it.next();\n  }\n  if (text.value.length) {\n    value[idx].push(text);\n  }\n  return value;\n}\nfunction read_selector(it) {\n  let selector = '',\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '{') break;else {\n      selector += c;\n    }\n    it.next();\n  }\n  selector = selector.trim();\n  return selector;\n}\nfunction read_cond_selector(it) {\n  let selector = {\n      name: '',\n      arguments: []\n    },\n    c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '(') {\n      it.next();\n      selector.arguments = read_arguments(it)[0];\n    } else if (/[){]/.test(c)) break;else selector.name += c;\n    it.next();\n  }\n  let [name, ...addition] = selector.name.trim().split(/\\s+/);\n  selector.name = name;\n  selector.addition = addition;\n  return selector;\n}\nfunction read_pseudo(it, extra) {\n  let pseudo = Tokens.pseudo(),\n    c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == '}') {\n      break;\n    } else if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else if (!pseudo.selector) {\n      pseudo.selector = read_selector(it);\n    } else {\n      let rule = read_rule(it, extra);\n      if (rule.property == '@use') {\n        pseudo.styles = pseudo.styles.concat(rule.value);\n      } else if (rule.property) {\n        pseudo.styles.push(rule);\n      }\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return pseudo;\n}\nfunction read_rule(it, extra) {\n  let rule = Tokens.rule(),\n    c;\n  let start = it.index();\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == ';') {\n      break;\n    } else if (!rule.property.length) {\n      rule.property = read_property(it);\n      if (rule.property == '@use') {\n        rule.value = read_var(it, extra);\n        break;\n      }\n    } else {\n      rule.value = read_value(it);\n      break;\n    }\n    it.next();\n  }\n  let end = it.index();\n  rule.raw = () => it.range(start, end).trim();\n  return rule;\n}\nfunction read_cond(it, extra) {\n  let cond = Tokens.cond(),\n    c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == '}') {\n      break;\n    } else if (!cond.name.length) {\n      Object.assign(cond, read_cond_selector(it));\n    } else if (c == ':') {\n      let pseudo = read_pseudo(it);\n      if (pseudo.selector) cond.styles.push(pseudo);\n    } else if (c == '@' && !read_line(it, true).includes(':')) {\n      cond.styles.push(read_cond(it));\n    } else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) cond.styles.push(rule);\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return cond;\n}\nfunction read_variable(extra, name) {\n  let rule = '';\n  if (extra && extra.get_variable) {\n    rule = extra.get_variable(name);\n  }\n  return rule;\n}\nfunction evaluate_value(values, extra) {\n  values.forEach && values.forEach(v => {\n    if (v.type == 'text' && v.value) {\n      let vars = parse_var(v.value);\n      v.value = vars.reduce((ret, p) => {\n        let rule = '',\n          other = '',\n          parsed;\n        rule = read_variable(extra, p.name);\n        if (!rule && p.fallback) {\n          p.fallback.every(n => {\n            other = read_variable(extra, n.name);\n            if (other) {\n              rule = other;\n              return false;\n            }\n          });\n        }\n        try {\n          parsed = parse(rule, extra);\n        } catch (e) {}\n        if (parsed) {\n          ret.push.apply(ret, parsed);\n        }\n        return ret;\n      }, []);\n    }\n    if (v.type == 'func' && v.arguments) {\n      v.arguments.forEach(arg => {\n        evaluate_value(arg, extra);\n      });\n    }\n  });\n}\nfunction read_var(it, extra) {\n  it.next();\n  let groups = read_value(it) || [];\n  return groups.reduce((ret, group) => {\n    evaluate_value(group, extra);\n    let [token] = group;\n    if (token.value && token.value.length) {\n      ret.push(...token.value);\n    }\n    return ret;\n  }, []);\n}\nexport default function parse(input, extra) {\n  const it = iterator(input);\n  const Tokens = [];\n  while (!it.end()) {\n    let c = it.curr();\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    } else if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    } else if (c == ':') {\n      let pseudo = read_pseudo(it, extra);\n      if (pseudo.selector) Tokens.push(pseudo);\n    } else if (c == '@' && read_word(it, true) === '@keyframes') {\n      let keyframes = read_keyframes(it, extra);\n      Tokens.push(keyframes);\n    } else if (c == '@' && !read_line(it, true).includes(':')) {\n      let cond = read_cond(it, extra);\n      if (cond.name.length) Tokens.push(cond);\n    } else if (c == '<') {\n      skip_tag(it);\n    } else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) Tokens.push(rule);\n    }\n    it.next();\n  }\n  return Tokens;\n}","map":{"version":3,"names":["parse_var","parse_svg","generate_svg_extended","first","last","clone","Tokens","func","name","arguments","length","undefined","type","argument","value","text","pseudo","selector","styles","cond","rule","property","keyframes","steps","step","is","white_space","c","test","line_break","number","n","isNaN","pair","includes","pair_of","symbols","Math","PI","composible","iterator","input","index","col","line","curr","end","info","range","start","substring","next","throw_error","msg","_ref","console","warn","concat","get_text_value","trim","read_until","fn","it","reset","word","read_word","check","read_keyframe_name","read_line","read_step","extra","read_selector","push","read_rule","read_steps","read_keyframes","read_comments","flag","inline","skip_tag","read_property","prop","read_arguments","composition","doodle","variables","args","group","stack","arg","raw","prev","pop","trimLeft","read_func","startsWith","substr","cloned","normalize_argument","skip_last_empty_args","String","slice","result","map","replace","ft","ed","cf","ce","cluster","seperate_func_name","fname","i","has_times_syntax","token","str","JSON","stringify","is_svg","has_argument","is_calc","raw_args","parsed_svg","item","variable","parse","repeat","svg","extended","unshift","position","read_value","idx","skip","quote_stack","quote","read_cond_selector","addition","split","read_pseudo","read_var","read_cond","Object","assign","read_variable","get_variable","evaluate_value","values","forEach","v","vars","reduce","ret","p","other","parsed","fallback","every","e","apply","groups"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/parser/parse-css.js"],"sourcesContent":["// I need to rewrite this\n\nimport parse_var from './parse-var.js';\nimport parse_svg from './parse-svg.js';\nimport { generate_svg_extended } from '../generator/svg-extended.js';\nimport { first, last, clone } from '../utils/list.js';\n\nconst Tokens = {\n  func(name = '') {\n    return {\n      type: 'func',\n      name,\n      arguments: []\n    };\n  },\n  argument() {\n    return {\n      type: 'argument',\n      value: []\n    };\n  },\n  text(value = '') {\n    return {\n      type: 'text',\n      value\n    };\n  },\n  pseudo(selector = '') {\n    return {\n      type: 'pseudo',\n      selector,\n      styles: []\n    };\n  },\n  cond(name = '') {\n    return {\n      type: 'cond',\n      name,\n      styles: [],\n      arguments: []\n    };\n  },\n  rule(property = '') {\n    return {\n      type: 'rule',\n      property,\n      value: []\n    };\n  },\n  keyframes(name = '') {\n    return {\n      type: 'keyframes',\n      name,\n      steps: []\n    }\n  },\n\n  step(name = '') {\n    return {\n      type: 'step',\n      name,\n      styles: []\n    }\n  }\n};\n\nconst is = {\n  white_space(c) {\n    return /[\\s\\n\\t]/.test(c);\n  },\n  line_break(c) {\n    return /\\n/.test(c);\n  },\n  number(n) {\n    return !isNaN(n);\n  },\n  pair(n) {\n    return ['\"', '(', ')', \"'\"].includes(n);\n  },\n  pair_of(c, n) {\n    return ({ '\"': '\"', \"'\": \"'\", '(': ')' })[c] == n;\n  }\n};\n\n// This should not be in the parser\n// but I'll leave it here until the rewriting\nconst symbols = {\n  'π': Math.PI,\n  '∏': Math.PI\n};\n\nfunction composible(name) {\n  return /^@(canvas|shaders|doodle)/.test(name);\n}\n\nfunction iterator(input = '') {\n  let index = 0, col = 1, line = 1;\n  return {\n    curr(n = 0) {\n      return input[index + n];\n    },\n    end() {\n      return input.length <= index;\n    },\n    info() {\n      return { index, col, line };\n    },\n    index(n) {\n      return (n === undefined ? index : index = n);\n    },\n    range(start, end) {\n      return input.substring(start, end);\n    },\n    next() {\n      let next = input[index++];\n      if (next == '\\n') line++, col = 0;\n      else col++;\n      return next;\n    }\n  };\n}\n\nfunction throw_error(msg, { col, line }) {\n  console.warn(\n    `(at line ${ line }, column ${ col }) ${ msg }`\n  );\n}\n\nfunction get_text_value(input) {\n  if (input.trim().length) {\n    return is.number(+input) ? +input : input.trim()\n  } else {\n    return input;\n  }\n}\n\nfunction read_until(fn) {\n  return function(it, reset) {\n    let index = it.index();\n    let word = '';\n    while (!it.end()) {\n      let c = it.next();\n      if (fn(c)) break;\n      else word += c;\n    }\n    if (reset) {\n      it.index(index);\n    }\n    return word;\n  }\n}\n\nfunction read_word(it, reset) {\n  let check = c => /[^\\w@]/.test(c);\n  return read_until(check)(it, reset);\n}\n\nfunction read_keyframe_name(it) {\n  return read_until(c => /[\\s\\{]/.test(c))(it);\n}\n\nfunction read_line(it, reset) {\n  let check = c => is.line_break(c) || c == '{';\n  return read_until(check)(it, reset);\n}\n\nfunction read_step(it, extra) {\n  let c, step = Tokens.step();\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else if (!step.name.length) {\n      step.name = read_selector(it);\n    }\n    else {\n      step.styles.push(read_rule(it, extra));\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return step;\n}\n\nfunction read_steps(it, extra) {\n  const steps = [];\n  let c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    else if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else {\n      steps.push(read_step(it, extra));\n    }\n    it.next();\n  }\n  return steps;\n}\n\nfunction read_keyframes(it, extra) {\n  let keyframes = Tokens.keyframes(), c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '}') break;\n    else if (!keyframes.name.length) {\n      read_word(it);\n      keyframes.name = read_keyframe_name(it);\n      if (!keyframes.name.length) {\n        throw_error('missing keyframes name', it.info());\n        break;\n      }\n      continue;\n    }\n    else if (c == '{' || it.curr(-1) == '{') {\n      it.next();\n      keyframes.steps = read_steps(it, extra);\n      break;\n    }\n    it.next();\n  }\n  return keyframes;\n}\n\nfunction read_comments(it, flag = {}) {\n  it.next();\n  while (!it.end()) {\n    let c = it.curr();\n    if (flag.inline) {\n      if (c == '\\n') break;\n    }\n    else {\n      if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n    }\n    it.next();\n  }\n  if (!flag.inline) {\n    it.next(); it.next();\n  }\n}\n\nfunction skip_tag(it) {\n  it.next();\n  while(!it.end()) {\n    let c = it.curr();\n    if (c == '>') break;\n    it.next();\n  }\n}\n\nfunction read_property(it) {\n  let prop = '', c;\n  while (!it.end()) {\n    if ((c = it.curr()) == ':') break;\n    else if (!is.white_space(c)) prop += c;\n    it.next();\n  }\n  return prop;\n}\n\nfunction read_arguments(it, composition, doodle, variables = {}) {\n  let args = [], group = [], stack = [], arg = '', c;\n  let raw = '';\n  while (!it.end()) {\n    c = it.curr();\n    let prev = it.curr(-1);\n    let start = it.index();\n    if ((/[\\('\"`]/.test(c) && prev !== '\\\\')) {\n      if (stack.length) {\n        /*\n        if ((c !== '(') && last(stack) === '(') {\n          stack.pop();\n        }\n        */\n        if (c !== '(' && c === last(stack)) {\n          stack.pop();\n        } else {\n          stack.push(c);\n        }\n      } else {\n        stack.push(c);\n      }\n      arg += c;\n    }\n    else if (!doodle && ((c == '@' || c === '$') || (prev === '.' && composition))) {\n      if (!group.length) {\n        arg = arg.trimLeft();\n      }\n      if (arg.length) {\n        group.push(Tokens.text(arg));\n        arg = '';\n      }\n      group.push(read_func(it, variables));\n    }\n    else if (doodle && /[)]/.test(c) || (!doodle && /[,)]/.test(c))) {\n      if (stack.length) {\n        if (c == ')' && last(stack) === '(') {\n          stack.pop();\n        }\n        arg += c;\n      }\n      else {\n        if (arg.length) {\n          if (!group.length) {\n            group.push(Tokens.text(get_text_value(arg)));\n          } else if (/\\S/.test(arg)) {\n            group.push(Tokens.text(arg));\n          }\n          if (arg.startsWith('±') && !doodle) {\n            let raw = arg.substr(1);\n            let cloned = clone(group);\n            last(cloned).value = '-' + raw;\n            args.push(normalize_argument(cloned));\n            last(group).value = raw;\n          }\n        }\n\n        args.push(normalize_argument(group));\n\n        [group, arg] = [[], ''];\n\n        if (c == ')') break;\n      }\n    }\n    else {\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      arg += c;\n    }\n    if (composition && ((it.curr(1) == ')' || it.curr(1) == ';') || !/[0-9a-zA-Z_\\-.]/.test(it.curr())) && !stack.length) {\n      if (group.length) {\n        args.push(normalize_argument(group));\n      }\n      break;\n    }\n    else {\n      raw += it.range(start, it.index() + 1);\n      it.next();\n    }\n  }\n  return [skip_last_empty_args(args), raw];\n}\n\nfunction skip_last_empty_args(args) {\n  let arg = last(args[0]);\n  if (arg && arg.type === 'text' && !String(arg.value).trim().length) {\n    args[0] = args[0].slice(0, -1);\n  }\n  return args;\n}\n\nfunction normalize_argument(group) {\n  let result = group.map(arg => {\n    if (arg.type == 'text' && typeof arg.value == 'string') {\n      let value = String(arg.value);\n      if (value.includes('`')) {\n        arg.value = value = value.replace(/`/g, '\"');\n      }\n      arg.value = value;\n    }\n    return arg;\n  });\n\n  let ft = first(result) || {};\n  let ed = last(result) || {};\n  if (ft.type == 'text' && ed.type == 'text') {\n    let cf = first(ft.value);\n    let ce  = last(ed.value);\n    if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n      if (is.pair_of(cf, ce)) {\n        ft.value = ft.value.slice(1);\n        ed.value = ed.value.slice(0, ed.value.length - 1);\n        result.cluster = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction seperate_func_name(name) {\n  let fname = '', extra = '';\n  if ((/\\D$/.test(name) && !/\\d+[x-]\\d+/.test(name)) || Math[name.substr(1)]) {\n    return { fname: name, extra }\n  }\n  for (let i = name.length - 1; i >= 0; i--) {\n    let c = name[i];\n    let prev = name[i - 1];\n    let next = name[i + 1];\n    if (/[\\d.]/.test(c) || ((c == 'x' || c == '-') && /\\d/.test(prev) && /\\d/.test(next))) {\n      extra = c + extra;\n    } else {\n      fname = name.substring(0, i + 1);\n      break;\n    }\n  }\n  return { fname, extra };\n}\n\nfunction has_times_syntax(token) {\n  let str = JSON.stringify(token);\n  return str.includes('pureName') && str.includes('times');\n}\n\nfunction is_svg(name) {\n  return /^@svg$/i.test(name);\n}\n\nfunction read_func(it, variables = {}) {\n  let func = Tokens.func();\n  let name = it.curr(), c;\n  let has_argument = false;\n  let is_calc = name === '$';;\n  if (name === '@') {\n    it.next();\n  } else {\n    name = '@';\n  }\n  while (!it.end()) {\n    c = it.curr();\n    let next = it.curr(1);\n    let composition = (c == '.' && (/[a-zA-Z@$]/.test(next)));\n    if (c == '(' || composition) {\n      has_argument = true;\n      it.next();\n      let [args, raw_args] = read_arguments(it, composition, composible(name), variables);\n      if (is_svg(name)) {\n        let parsed_svg = parse_svg(raw_args);\n        let line = 0;\n        for (let item of parsed_svg.value) {\n          if (item.variable) {\n            variables[item.name] = (parse(`${'\\n'.repeat(line++)} ${item.name}: ${item.value}`))[0].value;\n          }\n        }\n        if (/\\d\\s*{/.test(raw_args) && has_times_syntax(parsed_svg)) {\n          let svg = generate_svg_extended(parsed_svg);\n          // compatible with old iterator\n          svg += ')';\n          let extended = read_arguments(iterator(svg), composition, composible(name), variables);\n          args = extended[0];\n        }\n      }\n      func.arguments = args;\n      func.variables = variables;\n      break;\n    } else if (/[0-9a-zA-Z_\\-.%]/.test(c)) {\n      name += c;\n    }\n    if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.%]/.test(next)) {\n      break;\n    }\n    it.next();\n  }\n  let { fname, extra } = seperate_func_name(name);\n  func.name = is_calc ? '@$' + name.substr(1) : fname;\n  if (extra.length) {\n    func.arguments.unshift([{\n      type: 'text',\n      value: extra\n    }]);\n  }\n\n  if (is_calc && func.name.length > 2) {\n    if (!func.arguments.length) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments.push(\n        [{ type: 'text', value: value }]\n      );\n    }\n    if (/\\d$/.test(func.name)) {\n      let name = func.name.substring(0, 2);\n      let value = func.name.substring(2);\n      func.name = name;\n      func.arguments[0][0].value = value;\n    }\n  }\n\n  func.position = it.info().index;\n  return func;\n}\n\nfunction read_value(it) {\n  let text = Tokens.text(), idx = 0, skip = true, c;\n  const value = [];\n  value[idx] = [];\n  let stack = [], quote_stack = [];\n\n  while (!it.end()) {\n    c = it.curr();\n\n    if (skip && is.white_space(c)) {\n      it.next();\n      continue;\n    } else {\n      skip = false;\n    }\n\n    if (c == '\\n' && !is.white_space(it.curr(-1))) {\n      text.value += ' ';\n    }\n    else if (c == ',' && !stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[++idx] = [];\n      skip = true;\n    }\n    else if (/[;}<]/.test(c) && !quote_stack.length) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      break;\n    }\n    else if ((c === '@' || c === '$') && /[\\w-\\(%]/.test(it.curr(1))) {\n      if (text.value.length) {\n        value[idx].push(text);\n        text = Tokens.text();\n      }\n      value[idx].push(read_func(it));\n    }\n    else if (c === '\"' || c === \"'\") {\n      let quote = last(quote_stack);\n      if (c === quote) {\n        quote_stack.pop();\n      } else if (!quote_stack.length) {\n        quote_stack.push(c);\n      }\n      text.value += c;\n    }\n    else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n      if (c == '(') stack.push(c);\n      if (c == ')') stack.pop();\n\n      if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n        c = symbols[c];\n      }\n      text.value += c;\n    }\n    if ((it.curr() === ';' || it.curr() == '}') && !quote_stack.length) {\n      break;\n    }\n    it.next();\n  }\n  if (text.value.length) {\n    value[idx].push(text);\n  }\n  return value;\n}\n\nfunction read_selector(it) {\n  let selector = '', c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '{') break;\n    else {\n      selector += c;\n    }\n    it.next();\n  }\n  selector = selector.trim();\n  return selector;\n}\n\nfunction read_cond_selector(it) {\n  let selector = { name: '', arguments: [] }, c;\n  while (!it.end()) {\n    if ((c = it.curr()) == '(') {\n      it.next();\n      selector.arguments = read_arguments(it)[0];\n    }\n    else if (/[){]/.test(c)) break;\n    else selector.name += c;\n    it.next();\n  }\n  let [name, ...addition] = selector.name.trim().split(/\\s+/);\n  selector.name = name;\n  selector.addition = addition;\n  return selector;\n}\n\nfunction read_pseudo(it, extra) {\n  let pseudo = Tokens.pseudo(), c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == '}') {\n      break;\n    }\n    else if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else if (!pseudo.selector) {\n      pseudo.selector = read_selector(it);\n    }\n    else {\n      let rule = read_rule(it, extra);\n      if (rule.property == '@use') {\n        pseudo.styles = pseudo.styles.concat(\n          rule.value\n        );\n      } else if (rule.property) {\n        pseudo.styles.push(rule);\n      }\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return pseudo;\n}\n\nfunction read_rule(it, extra) {\n  let rule = Tokens.rule(), c;\n  let start = it.index();\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == ';') {\n      break;\n    }\n    else if (!rule.property.length) {\n      rule.property = read_property(it);\n      if (rule.property == '@use') {\n        rule.value = read_var(it, extra);\n        break;\n      }\n    }\n    else {\n      rule.value = read_value(it);\n      break;\n    }\n    it.next();\n  }\n  let end = it.index();\n  rule.raw = () => it.range(start, end).trim();\n  return rule;\n}\n\nfunction read_cond(it, extra) {\n  let cond = Tokens.cond(), c;\n  while (!it.end()) {\n    c = it.curr();\n    if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == '}') {\n      break;\n    }\n    else if (!cond.name.length) {\n      Object.assign(cond, read_cond_selector(it));\n    }\n    else if (c == ':') {\n      let pseudo = read_pseudo(it);\n      if (pseudo.selector) cond.styles.push(pseudo);\n    }\n    else if (c == '@' && !read_line(it, true).includes(':')) {\n      cond.styles.push(read_cond(it));\n    }\n    else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) cond.styles.push(rule);\n      if (it.curr() == '}') break;\n    }\n    it.next();\n  }\n  return cond;\n}\n\nfunction read_variable(extra, name) {\n  let rule = '';\n  if (extra && extra.get_variable) {\n    rule = extra.get_variable(name);\n  }\n  return rule;\n}\n\nfunction evaluate_value(values, extra) {\n  values.forEach && values.forEach(v => {\n    if (v.type == 'text' && v.value) {\n      let vars = parse_var(v.value);\n      v.value = vars.reduce((ret, p) => {\n        let rule = '', other = '', parsed;\n        rule = read_variable(extra, p.name);\n        if (!rule && p.fallback) {\n          p.fallback.every(n => {\n            other = read_variable(extra, n.name);\n            if (other) {\n              rule = other;\n              return false;\n            }\n          });\n        }\n        try {\n          parsed = parse(rule, extra);\n        } catch (e) { }\n        if (parsed) {\n          ret.push.apply(ret, parsed);\n        }\n        return ret;\n      }, []);\n    }\n    if (v.type == 'func' && v.arguments) {\n      v.arguments.forEach(arg => {\n        evaluate_value(arg, extra);\n      });\n    }\n  });\n}\n\nfunction read_var(it, extra) {\n  it.next();\n  let groups = read_value(it) || [];\n  return groups.reduce((ret, group) => {\n    evaluate_value(group, extra);\n    let [token] = group;\n    if (token.value && token.value.length) {\n      ret.push(...token.value);\n    }\n    return ret;\n  }, []);\n}\n\nexport default function parse(input, extra) {\n  const it = iterator(input);\n  const Tokens = [];\n  while (!it.end()) {\n    let c = it.curr();\n    if (is.white_space(c)) {\n      it.next();\n      continue;\n    }\n    else if (c == '/' && it.curr(1) == '*') {\n      read_comments(it);\n    }\n    else if (c == ':') {\n      let pseudo = read_pseudo(it, extra);\n      if (pseudo.selector) Tokens.push(pseudo);\n    }\n    else if (c == '@' && read_word(it, true) === '@keyframes') {\n      let keyframes = read_keyframes(it, extra);\n      Tokens.push(keyframes);\n    }\n    else if (c == '@' && !read_line(it, true).includes(':')) {\n      let cond = read_cond(it, extra);\n      if (cond.name.length) Tokens.push(cond);\n    }\n    else if (c == '<') {\n      skip_tag(it);\n    }\n    else if (!is.white_space(c)) {\n      let rule = read_rule(it, extra);\n      if (rule.property) Tokens.push(rule);\n    }\n    it.next();\n  }\n  return Tokens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}