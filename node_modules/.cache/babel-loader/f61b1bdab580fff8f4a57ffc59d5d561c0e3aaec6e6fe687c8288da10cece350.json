{"ast":null,"code":"import { next_id, is_nil } from '../utils/index.js';\nconst NS = 'http://www.w3.org/2000/svg';\nconst NSXLink = 'http://www.w3.org/1999/xlink';\nconst nextId = next_id();\nclass Tag {\n  constructor(name) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    if (!name) {\n      throw new Error(\"Tag name is required\");\n    }\n    this.id = Symbol();\n    this.name = name;\n    this.body = [];\n    this.attrs = {};\n    if (this.isTextNode()) {\n      this.body = value;\n    }\n  }\n  isTextNode() {\n    return this.name === 'text-node';\n  }\n  find(target) {\n    let id = target.attrs.id;\n    let name = target.name;\n    if (Array.isArray(this.body) && id !== undefined) {\n      return this.body.find(tag => tag.attrs.id === id && tag.name === name);\n    }\n  }\n  findSpareDefs() {\n    return this.body.find(n => n.name === 'defs' && !n.attrs.id);\n  }\n  append(tags) {\n    if (!Array.isArray(tags)) {\n      tags = [tags];\n    }\n    for (let tag of tags) {\n      if (!this.isTextNode()) {\n        this.body.push(tag);\n      }\n    }\n  }\n  merge(tag) {\n    for (let [name, value] of Object.entries(tag.attrs)) {\n      this.attrs[name] = value;\n    }\n    if (Array.isArray(tag.body)) {\n      this.body.push(...tag.body);\n    }\n  }\n  attr(name, value) {\n    if (!this.isTextNode()) {\n      if (value === undefined) {\n        return this.attrs[name];\n      }\n      return this.attrs[name] = value;\n    }\n  }\n  toString() {\n    if (this.isTextNode()) {\n      return removeQuotes(this.body);\n    }\n    let attrs = [''];\n    let body = [];\n    for (let [name, value] of Object.entries(this.attrs)) {\n      value = removeQuotes(value);\n      attrs.push(\"\".concat(name, \"=\\\"\").concat(value, \"\\\"\"));\n    }\n    for (let tag of this.body) {\n      body.push(tag.toString());\n    }\n    let content = body.join('');\n    if (content.length || /svg/i.test(this.name)) {\n      return \"<\".concat(this.name).concat(attrs.join(' '), \">\").concat(body.join(''), \"</\").concat(this.name, \">\");\n    }\n    return \"<\".concat(this.name).concat(attrs.join(' '), \"/>\");\n  }\n}\nfunction composeStyleRule(name, value) {\n  return \"\".concat(name, \":\").concat(value, \";\");\n}\nfunction removeQuotes(text) {\n  text = String(text);\n  let double = text.startsWith('\"') && text.endsWith('\"');\n  let single = text.startsWith(\"'\") && text.endsWith(\"'\");\n  if (double || single) {\n    return text.substring(1, text.length - 1);\n  }\n  return text;\n}\nfunction transformViewBox(token) {\n  let viewBox = token.detail.value;\n  let p = token.detail.padding || token.detail.p || token.detail.expand;\n  if (!viewBox.length) {\n    return '';\n  }\n  let [x, y, w, h] = viewBox;\n  if (p) {\n    [x, y, w, h] = [x - p, y - p, w + p * 2, h + p * 2];\n  }\n  return \"\".concat(x, \" \").concat(y, \" \").concat(w, \" \").concat(h);\n}\nfunction isGraphicElement(name) {\n  return name === 'path' || name === 'line' || name === 'circle' || name === 'ellipse' || name === 'rect' || name === 'polygon' || name === 'polyline';\n}\nfunction generate(token, element, parent, root) {\n  let inlineId;\n  if (!element) {\n    element = new Tag('root');\n  }\n  if (token.type === 'block') {\n    // style tag\n    if (token.name === 'style') {\n      let el = new Tag('style');\n      el.append(token.value);\n      element.append(el);\n    }\n    // normal svg elements\n    else {\n      let el = new Tag(token.name);\n      if (!root) {\n        root = el;\n        root.attr('xmlns', NS);\n      }\n      if (token.name === 'defs') {\n        let defsElement = root.findSpareDefs();\n        // replace with existing defs\n        if (defsElement) {\n          el = defsElement;\n        }\n      }\n      for (let block of token.value) {\n        token.parent = parent;\n        let id = generate(block, el, token, root);\n        if (id) {\n          inlineId = id;\n        }\n      }\n      let isInlineAndNotDefs = token && token.inline && token.name !== 'defs';\n      let isParentInlineDefs = parent && parent.inline && parent.name === 'defs';\n      let isSingleDefChild = isParentInlineDefs && parent.value.length == 1;\n      if (isInlineAndNotDefs || isParentInlineDefs) {\n        // generate id for inline block if no id is found\n        let found = token.value.find(n => n.type === 'statement' && n.name === 'id');\n        if (found) {\n          inlineId = found.value;\n        } else if (isSingleDefChild || isInlineAndNotDefs) {\n          inlineId = nextId(token.name);\n          el.attr('id', inlineId);\n        }\n      }\n      let existedTag = element.find(el);\n      if (existedTag) {\n        existedTag.merge(el);\n      } else {\n        if (token.name === 'defs') {\n          // append only when there's no defs and spare defs\n          let defsElement = root.findSpareDefs();\n          if (defsElement && !el.attrs.id) {\n            if (el.id !== defsElement.id) {\n              defsElement.append(el.body);\n            }\n          } else {\n            root.append(el);\n          }\n        } else {\n          element.append(el);\n        }\n      }\n    }\n  }\n  if (token.type === 'statement' && !token.variable) {\n    if (token.name === 'content') {\n      let text = new Tag('text-node', token.value);\n      element.append(text);\n    }\n    // inline style\n    else if (token.name.startsWith('style ')) {\n      let name = (token.name.split('style ')[1] || '').trim();\n      if (name.length) {\n        let style = element.attr('style') || '';\n        element.attr('style', style + composeStyleRule(name, token.value));\n      }\n    } else {\n      let value = token.value;\n      // handle inline block value\n      if (value && value.type === 'block') {\n        let id = generate(token.value, root, token, root);\n        if (is_nil(id)) {\n          value = '';\n        } else {\n          value = \"url(#\".concat(id, \")\");\n          if (token.name === 'xlink:href' || token.name === 'href') {\n            value = \"#\".concat(id);\n          }\n        }\n      }\n      if (/viewBox/i.test(token.name)) {\n        value = transformViewBox(token, value);\n        if (value) {\n          element.attr(token.name, value);\n        }\n      } else if ((token.name === 'draw' || token.name === 'animate') && isGraphicElement(parent && parent.name)) {\n        let [dur, repeatCount] = String(value).split(/\\s+/);\n        if (dur === 'indefinite' || dur === 'infinite' || /\\d$/.test(dur)) {\n          [dur, repeatCount] = [repeatCount, dur];\n        }\n        if (repeatCount === 'infinite') {\n          repeatCount = 'indefinite';\n        }\n        element.attr('stroke-dasharray', 10);\n        element.attr('pathLength', 10);\n        let animate = new Tag('animate');\n        animate.attr('attributeName', 'stroke-dashoffset');\n        animate.attr('from', 10);\n        animate.attr('to', 0);\n        animate.attr('dur', dur);\n        if (repeatCount) {\n          animate.attr('repeatCount', repeatCount);\n        }\n        element.append(animate);\n      } else {\n        element.attr(token.name, value);\n      }\n      if (token.name.includes('xlink:')) {\n        root.attr('xmlns:xlink', NSXLink);\n      }\n    }\n  }\n  if (!parent) {\n    return root.toString();\n  }\n  return inlineId;\n}\nfunction generate_svg(token) {\n  return generate(token);\n}\nexport { generate_svg };","map":{"version":3,"names":["next_id","is_nil","NS","NSXLink","nextId","Tag","constructor","name","value","arguments","length","undefined","Error","id","Symbol","body","attrs","isTextNode","find","target","Array","isArray","tag","findSpareDefs","n","append","tags","push","merge","Object","entries","attr","toString","removeQuotes","concat","content","join","test","composeStyleRule","text","String","double","startsWith","endsWith","single","substring","transformViewBox","token","viewBox","detail","p","padding","expand","x","y","w","h","isGraphicElement","generate","element","parent","root","inlineId","type","el","defsElement","block","isInlineAndNotDefs","inline","isParentInlineDefs","isSingleDefChild","found","existedTag","variable","split","trim","style","dur","repeatCount","animate","includes","generate_svg"],"sources":["/var/www/www-root/data/www/knigavl.ru/node_modules/css-doodle/src/generator/svg.js"],"sourcesContent":["import { next_id, is_nil } from '../utils/index.js';\n\nconst NS = 'http://www.w3.org/2000/svg';\nconst NSXLink = 'http://www.w3.org/1999/xlink';\nconst nextId = next_id();\n\nclass Tag {\n  constructor(name, value = '') {\n    if (!name) {\n      throw new Error(\"Tag name is required\");\n    }\n    this.id = Symbol();\n    this.name = name;\n    this.body = [];\n    this.attrs = {};\n    if (this.isTextNode()) {\n      this.body = value;\n    }\n  }\n  isTextNode() {\n    return this.name === 'text-node';\n  }\n  find(target) {\n    let id = target.attrs.id;\n    let name = target.name;\n    if (Array.isArray(this.body) && id !== undefined) {\n      return this.body.find(tag => tag.attrs.id === id && tag.name === name);\n    }\n  }\n  findSpareDefs() {\n    return this.body.find(n => n.name === 'defs' && !n.attrs.id);\n  }\n  append(tags) {\n    if (!Array.isArray(tags)) {\n      tags = [tags];\n    }\n    for (let tag of tags) {\n      if (!this.isTextNode()) {\n        this.body.push(tag);\n      }\n    }\n  }\n  merge(tag) {\n    for (let [name, value] of Object.entries(tag.attrs)) {\n      this.attrs[name] = value;\n    }\n    if (Array.isArray(tag.body)) {\n      this.body.push(...tag.body);\n    }\n  }\n  attr(name, value) {\n    if (!this.isTextNode()) {\n      if (value === undefined) {\n        return this.attrs[name];\n      }\n      return this.attrs[name] = value;\n    }\n  }\n  toString() {\n    if (this.isTextNode()) {\n      return removeQuotes(this.body);\n    }\n    let attrs = [''];\n    let body = [];\n    for (let [name, value] of Object.entries(this.attrs)) {\n      value = removeQuotes(value);\n      attrs.push(`${name}=\"${value}\"`);\n    }\n    for (let tag of this.body) {\n      body.push(tag.toString());\n    }\n    let content = body.join('');\n    if (content.length || /svg/i.test(this.name)) {\n      return `<${this.name}${attrs.join(' ')}>${body.join('')}</${this.name}>`;\n    }\n    return `<${this.name}${attrs.join(' ')}/>`;\n  }\n}\n\nfunction composeStyleRule(name, value) {\n  return `${name}:${value};`\n}\n\nfunction removeQuotes(text) {\n  text = String(text);\n  let double = text.startsWith('\"') && text.endsWith('\"');\n  let single = text.startsWith(\"'\") && text.endsWith(\"'\");\n  if (double || single) {\n    return text.substring(1, text.length - 1);\n  }\n  return text;\n}\n\nfunction transformViewBox(token) {\n  let viewBox = token.detail.value;\n  let p = token.detail.padding || token.detail.p || token.detail.expand;\n  if (!viewBox.length) {\n    return '';\n  }\n  let [x, y, w, h] = viewBox;\n  if (p) {\n    [x, y, w, h] = [x-p, y-p, w+p*2, h+p*2];\n  }\n  return `${x} ${y} ${w} ${h}`;\n}\n\nfunction isGraphicElement(name) {\n  return name === 'path'\n    || name === 'line'\n    || name === 'circle'\n    || name === 'ellipse'\n    || name === 'rect'\n    || name === 'polygon'\n    || name === 'polyline';\n}\n\nfunction generate(token, element, parent, root) {\n  let inlineId;\n  if (!element) {\n    element = new Tag('root');\n  }\n  if (token.type === 'block') {\n    // style tag\n    if (token.name === 'style') {\n      let el = new Tag('style');\n      el.append(token.value);\n      element.append(el);\n    }\n    // normal svg elements\n    else {\n      let el = new Tag(token.name);\n      if (!root) {\n        root = el;\n        root.attr('xmlns', NS);\n      }\n      if (token.name === 'defs') {\n        let defsElement = root.findSpareDefs();\n        // replace with existing defs\n        if (defsElement) {\n          el = defsElement;\n        }\n      }\n      for (let block of token.value) {\n        token.parent = parent;\n        let id = generate(block, el, token, root);\n        if (id) { inlineId = id }\n      }\n      let isInlineAndNotDefs = token && token.inline && token.name !== 'defs';\n      let isParentInlineDefs = parent && parent.inline && parent.name === 'defs';\n      let isSingleDefChild = isParentInlineDefs && parent.value.length == 1;\n\n      if (isInlineAndNotDefs || isParentInlineDefs) {\n        // generate id for inline block if no id is found\n        let found = token.value.find(n => n.type === 'statement' && n.name === 'id');\n        if (found) {\n          inlineId = found.value;\n        } else if (isSingleDefChild || isInlineAndNotDefs) {\n          inlineId = nextId(token.name);\n          el.attr('id', inlineId);\n        }\n      }\n      let existedTag = element.find(el);\n      if (existedTag) {\n        existedTag.merge(el);\n      } else {\n        if (token.name === 'defs') {\n          // append only when there's no defs and spare defs\n          let defsElement = root.findSpareDefs();\n          if (defsElement && !el.attrs.id) {\n            if (el.id !== defsElement.id) {\n              defsElement.append(el.body);\n            }\n          } else {\n            root.append(el);\n          }\n        } else {\n          element.append(el);\n        }\n      }\n    }\n  }\n  if (token.type === 'statement' && !token.variable) {\n    if (token.name === 'content') {\n      let text = new Tag('text-node', token.value);\n      element.append(text);\n    }\n    // inline style\n    else if (token.name.startsWith('style ')) {\n      let name = (token.name.split('style ')[1] || '').trim();\n      if (name.length) {\n        let style = element.attr('style') || '';\n        element.attr('style', style + composeStyleRule(name, token.value));\n      }\n    }\n    else {\n      let value = token.value;\n      // handle inline block value\n      if (value && value.type === 'block') {\n        let id = generate(token.value, root, token, root);\n        if (is_nil(id)) {\n          value = '';\n        } else {\n          value = `url(#${id})`;\n          if (token.name === 'xlink:href' || token.name === 'href') {\n            value = `#${id}`;\n          }\n        }\n      }\n      if (/viewBox/i.test(token.name)) {\n        value = transformViewBox(token, value);\n        if (value) {\n          element.attr(token.name, value);\n        }\n      }\n      else if ((token.name === 'draw' || token.name === 'animate') && isGraphicElement(parent && parent.name)) {\n        let [dur, repeatCount] = String(value).split(/\\s+/);\n        if (dur === 'indefinite' || dur === 'infinite' || /\\d$/.test(dur)) {\n          [dur, repeatCount] = [repeatCount, dur];\n        }\n        if (repeatCount === 'infinite') {\n          repeatCount = 'indefinite';\n        }\n        element.attr('stroke-dasharray', 10);\n        element.attr('pathLength', 10);\n        let animate = new Tag('animate');\n        animate.attr('attributeName', 'stroke-dashoffset');\n        animate.attr('from', 10);\n        animate.attr('to', 0);\n        animate.attr('dur', dur);\n        if (repeatCount) {\n          animate.attr('repeatCount', repeatCount);\n        }\n        element.append(animate);\n      }\n      else {\n        element.attr(token.name, value);\n      }\n      if (token.name.includes('xlink:')) {\n        root.attr('xmlns:xlink', NSXLink);\n      }\n    }\n  }\n  if (!parent) {\n    return root.toString();\n  }\n  return inlineId;\n}\n\nfunction generate_svg(token) {\n  return generate(token);\n}\n\nexport {\n  generate_svg,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}